<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API reference - Ghidralib</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API reference";
        var mkdocs_page_input_path = "reference.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Ghidralib
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Ghidralib</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../compatibility/">Compatibility</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../emulator/">Emulator</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../getting_started/">Getting Started</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">API reference</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Ghidralib</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">API reference</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api-reference">API reference</h1>


<div class="doc doc-object doc-module">



<h1 id="ghidralib" class="doc doc-heading">
            <code>ghidralib</code>


</h1>

    <div class="doc doc-contents first">

        <p>This library is an attempt to provide a Pythonic standard library for Ghidra.</p>
<p>The main goal is to make writing quick&amp;dirty scripts actually quick, and not that dirty.</p>
<p>There is no equivalent of FlatProgramAPI from GHidra. You are expected to start
by getting an object of interest by calling instance methods, for example</p>
<pre><code>&gt;&gt;&gt; Function("main")
main
</code></pre>
<p>to get a function called "main". When you want to do something this library
doesn't support (yet), you can always excape back to Ghidra's wrapped Java
types, by getting a <code>.raw</code> property, for example:</p>
<pre><code>&gt;&gt;&gt; Function("main").raw.UNKNOWN_STACK_DEPTH_CHANGE
2147483647
</code></pre>
<p>For more details, see the documentation at https://msm-code.github.io/ghidralib/.</p>









  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.Addr" class="doc doc-heading">
            <code class="highlight language-python">Addr = GenericAddress | int | str</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.DataT" class="doc doc-heading">
            <code class="highlight language-python">DataT = GhidraWrapper | JavaObject | str</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.HIGHLIGHT_COLOR" class="doc doc-heading">
            <code class="highlight language-python">HIGHLIGHT_COLOR = SearchConstants.SEARCH_HIGHLIGHT_COLOR</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.Reg" class="doc doc-heading">
            <code class="highlight language-python">Reg = GhRegister | str</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.Str" class="doc doc-heading">
            <code class="highlight language-python">Str = (str, bytes, unicode)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.T" class="doc doc-heading">
            <code class="highlight language-python">T = TypeVar('T')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.__version__" class="doc doc-heading">
            <code class="highlight language-python">__version__ = '0.2.0'</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.bytes" class="doc doc-heading">
            <code class="highlight language-python">bytes = str</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.interpreter" class="doc doc-heading">
            <code class="highlight language-python">interpreter = get_current_interpreter()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h2 id="ghidralib.long" class="doc doc-heading">
            <code class="highlight language-python">long = int</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

    </div>

</div>


<div class="doc doc-object doc-class">



<h2 id="ghidralib.AddressRange" class="doc doc-heading">
            <code>AddressRange</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra AddressRange object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class AddressRange(GhidraWrapper):
    """Wraps a Ghidra AddressRange object."""

    @property
    def addresses(self):  # type: () -&gt; list[int]
        """Return the addresses in this range."""
        return [a.getOffset() for a in self.raw.getAddresses(True)]

    def __iter__(self):  # type: () -&gt; Iterator[int]
        """Iterate over the addresses in this range."""
        return self.addresses.__iter__()

    @property
    def start(self):  # type: () -&gt; int
        """Get the first address in this range."""
        return self.raw.getMinAddress().getOffset()

    @property
    def end(self):  # type: () -&gt; int
        """Get the last address in this range."""
        return self.raw.getMaxAddress().getOffset()

    @property
    def length(self):  # type: () -&gt; int
        """Get the length of this range."""
        return self.raw.getLength()

    def __len__(self):  # type: () -&gt; int
        """Get the length of this range."""
        return self.length

    def contains(self, addr):  # type: (Addr) -&gt; bool
        """Return True if the given address is in this range.

        :param addr: address to check"""
        return self.raw.contains(resolve(addr))

    def __contains__(self, addr):  # type: (Addr) -&gt; bool
        """Return True if the given address is in this range.
        :param addr: address to check"""
        return self.contains(addr)

    @property
    def is_empty(self):  # type: () -&gt; bool
        """Return True if this range is empty."""
        return self.raw.isEmpty()

    def __nonzero__(self):  # type: () -&gt; bool
        """Return True if this range is not empty."""
        return not self.is_empty

    def __and__(self, other):  # type: (AddressRange) -&gt; AddressRange
        """Return the intersection of this range and the given range."""
        return AddressRange(self.raw.intersect(other.raw))</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressRange.addresses" class="doc doc-heading">
            <code class="highlight language-python">addresses</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the addresses in this range.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressRange.end" class="doc doc-heading">
            <code class="highlight language-python">end</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the last address in this range.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressRange.is_empty" class="doc doc-heading">
            <code class="highlight language-python">is_empty</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this range is empty.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressRange.length" class="doc doc-heading">
            <code class="highlight language-python">length</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this range.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressRange.start" class="doc doc-heading">
            <code class="highlight language-python">start</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the first address in this range.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.__and__" class="doc doc-heading">
            <code class="highlight language-python">__and__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the intersection of this range and the given range.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __and__(self, other):  # type: (AddressRange) -&gt; AddressRange
    """Return the intersection of this range and the given range."""
    return AddressRange(self.raw.intersect(other.raw))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.__contains__" class="doc doc-heading">
            <code class="highlight language-python">__contains__(addr)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the given address is in this range.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>address to check</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __contains__(self, addr):  # type: (Addr) -&gt; bool
    """Return True if the given address is in this range.
    :param addr: address to check"""
    return self.contains(addr)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.__iter__" class="doc doc-heading">
            <code class="highlight language-python">__iter__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Iterate over the addresses in this range.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __iter__(self):  # type: () -&gt; Iterator[int]
    """Iterate over the addresses in this range."""
    return self.addresses.__iter__()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.__len__" class="doc doc-heading">
            <code class="highlight language-python">__len__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this range.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __len__(self):  # type: () -&gt; int
    """Get the length of this range."""
    return self.length</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.__nonzero__" class="doc doc-heading">
            <code class="highlight language-python">__nonzero__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this range is not empty.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __nonzero__(self):  # type: () -&gt; bool
    """Return True if this range is not empty."""
    return not self.is_empty</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressRange.contains" class="doc doc-heading">
            <code class="highlight language-python">contains(addr)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the given address is in this range.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>address to check</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def contains(self, addr):  # type: (Addr) -&gt; bool
    """Return True if the given address is in this range.

    :param addr: address to check"""
    return self.raw.contains(resolve(addr))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.AddressSet" class="doc doc-heading">
            <code>AddressSet</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra AddressSetView object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class AddressSet(GhidraWrapper):
    """Wraps a Ghidra AddressSetView object."""

    @staticmethod
    def empty():  # type: () -&gt; AddressSet
        """Create a new empty address set"""
        return AddressSet(GhAddressSet())

    @staticmethod
    def create(start, length):  # type: (Addr, int) -&gt; AddressSet
        """Create a new AddressSet with given address and length."""
        addr = resolve(start)
        return AddressSet(GhAddressSet(addr, addr.add(length - 1)))

    @property
    def addresses(self):  # type: () -&gt; list[int]
        """Return the addresses in this set."""
        return [a.getOffset() for a in self.raw.getAddresses(True)]

    @property
    def ranges(self):  # type: () -&gt; list[AddressRange]
        return [AddressRange(r) for r in self.raw.iterator(True)]

    def __iter__(self):  # type: () -&gt; Iterator[int]
        return self.addresses.__iter__()

    def contains(self, addr):  # type: (Addr) -&gt; bool
        """Return True if the given address is in this range."""
        return self.raw.contains(resolve(addr))

    def __contains__(self, addr):  # type: (Addr) -&gt; bool
        """Return True if the given address is in this range."""
        return self.contains(addr)

    @property
    def is_empty(self):  # type: () -&gt; bool
        """Return True if this range is empty."""
        return self.raw.isEmpty()

    def __nonzero__(self):  # type: () -&gt; bool
        """Return True if this range is not empty."""
        return not self.is_empty

    def __and__(self, other):  # type: (AddressSet) -&gt; AddressSet
        """Return the intersection of this set and the given set."""
        return AddressSet(self.raw.intersect(other.raw))

    def __sub__(self, other):  # type: (AddressSet) -&gt; AddressSet
        """Subtract the given set from this set."""
        return AddressSet(self.raw.subtract(other.raw))

    def __xor__(self, other):  # type: (AddressSet) -&gt; AddressSet
        """Computes the symmetric difference of this set and the given set."""
        return AddressSet(self.raw.xor(other.raw))

    def __or__(self, other):  # type: (AddressSet) -&gt; AddressSet
        """Computes the union of this set and the given set."""
        return AddressSet(self.raw.union(other.raw))

    def __get_highlighter(self):  # type: () -&gt; Any
        tool = getState().getTool()
        service = tool.getService(ColorizingService)
        if service is None:
            raise RuntimeError("Cannot highlight without the ColorizingService")
        return service

    def highlight(self, color=HIGHLIGHT_COLOR):  # type: (Color) -&gt; None
        service = self.__get_highlighter()
        service.setBackgroundColor(self.raw, color)

    def unhighlight(self):  # type: (Color) -&gt; None
        service = self.__get_highlighter()
        service.clearBackgroundColor(self.raw)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressSet.addresses" class="doc doc-heading">
            <code class="highlight language-python">addresses</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the addresses in this set.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressSet.is_empty" class="doc doc-heading">
            <code class="highlight language-python">is_empty</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this range is empty.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.AddressSet.ranges" class="doc doc-heading">
            <code class="highlight language-python">ranges</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__and__" class="doc doc-heading">
            <code class="highlight language-python">__and__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the intersection of this set and the given set.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __and__(self, other):  # type: (AddressSet) -&gt; AddressSet
    """Return the intersection of this set and the given set."""
    return AddressSet(self.raw.intersect(other.raw))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__contains__" class="doc doc-heading">
            <code class="highlight language-python">__contains__(addr)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the given address is in this range.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __contains__(self, addr):  # type: (Addr) -&gt; bool
    """Return True if the given address is in this range."""
    return self.contains(addr)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__get_highlighter" class="doc doc-heading">
            <code class="highlight language-python">__get_highlighter()</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __get_highlighter(self):  # type: () -&gt; Any
    tool = getState().getTool()
    service = tool.getService(ColorizingService)
    if service is None:
        raise RuntimeError("Cannot highlight without the ColorizingService")
    return service</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__iter__" class="doc doc-heading">
            <code class="highlight language-python">__iter__()</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __iter__(self):  # type: () -&gt; Iterator[int]
    return self.addresses.__iter__()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__nonzero__" class="doc doc-heading">
            <code class="highlight language-python">__nonzero__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this range is not empty.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __nonzero__(self):  # type: () -&gt; bool
    """Return True if this range is not empty."""
    return not self.is_empty</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__or__" class="doc doc-heading">
            <code class="highlight language-python">__or__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Computes the union of this set and the given set.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __or__(self, other):  # type: (AddressSet) -&gt; AddressSet
    """Computes the union of this set and the given set."""
    return AddressSet(self.raw.union(other.raw))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__sub__" class="doc doc-heading">
            <code class="highlight language-python">__sub__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Subtract the given set from this set.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __sub__(self, other):  # type: (AddressSet) -&gt; AddressSet
    """Subtract the given set from this set."""
    return AddressSet(self.raw.subtract(other.raw))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.__xor__" class="doc doc-heading">
            <code class="highlight language-python">__xor__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Computes the symmetric difference of this set and the given set.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __xor__(self, other):  # type: (AddressSet) -&gt; AddressSet
    """Computes the symmetric difference of this set and the given set."""
    return AddressSet(self.raw.xor(other.raw))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.contains" class="doc doc-heading">
            <code class="highlight language-python">contains(addr)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the given address is in this range.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def contains(self, addr):  # type: (Addr) -&gt; bool
    """Return True if the given address is in this range."""
    return self.raw.contains(resolve(addr))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.create" class="doc doc-heading">
            <code class="highlight language-python">create(start, length)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new AddressSet with given address and length.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create(start, length):  # type: (Addr, int) -&gt; AddressSet
    """Create a new AddressSet with given address and length."""
    addr = resolve(start)
    return AddressSet(GhAddressSet(addr, addr.add(length - 1)))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.empty" class="doc doc-heading">
            <code class="highlight language-python">empty()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new empty address set</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def empty():  # type: () -&gt; AddressSet
    """Create a new empty address set"""
    return AddressSet(GhAddressSet())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.highlight" class="doc doc-heading">
            <code class="highlight language-python">highlight(color=HIGHLIGHT_COLOR)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def highlight(self, color=HIGHLIGHT_COLOR):  # type: (Color) -&gt; None
    service = self.__get_highlighter()
    service.setBackgroundColor(self.raw, color)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.AddressSet.unhighlight" class="doc doc-heading">
            <code class="highlight language-python">unhighlight()</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def unhighlight(self):  # type: (Color) -&gt; None
    service = self.__get_highlighter()
    service.clearBackgroundColor(self.raw)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.BasicBlock" class="doc doc-heading">
            <code>BasicBlock</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="AddressSet (ghidralib.AddressSet)" href="#ghidralib.AddressSet">AddressSet</a></code>, <code><a class="autorefs autorefs-internal" title="BodyTrait (ghidralib.BodyTrait)" href="#ghidralib.BodyTrait">BodyTrait</a></code></p>


        <p>Wraps a Ghidra CodeBlock object</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class BasicBlock(AddressSet, BodyTrait):
    """Wraps a Ghidra CodeBlock object"""

    @staticmethod
    def _model(model):  # type: (str) -&gt; Callable[[JavaObject], JavaObject]
        if model == "basic":
            return BasicBlockModel
        elif model == "simple":
            return SimpleBlockModel
        else:
            raise ValueError("Unsupported model type: %s" % model)

    @staticmethod
    def get(
        raw_or_address, model="basic"
    ):  # type: (JavaObject|str|Addr, str) -&gt; BasicBlock|None
        """Get a BasicBlock object containing the given address, or return None.

        This function is tolerant and will accept different types of arguments:
        * address as int
        * Address object
        * symbol as string (will be resolved)
        * BasicBlock object (wrapped or unwrapped)

        :param raw_or_address: find basicblock that contains the given address.
        :param model: Ghidra supports different types of basic block "models".
        Supported options are "basic" and "simple"."""

        if raw_or_address is None:
            return None
        if can_resolve(raw_or_address):
            block_model = BasicBlock._model(model)(Program.current())
            addr = try_resolve(raw_or_address)
            if addr is None:
                return None
            raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY)
            if raw is None:
                return None
        else:
            raw = raw_or_address
        return BasicBlock(raw)

    @staticmethod
    def all(model="basic"):  # type: (str) -&gt; list[BasicBlock]
        """Get a list of all basic blocks in the program."""
        block_model = BasicBlock._model(model)(Program.current())
        return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)]

    @property
    def name(self):  # type: () -&gt; str
        """Get the name of this basic block.

        Return the symbol at the start of this basic block, if any. Otherwise,
        return the address of the first instruction as string."""
        return self.raw.getName()

    @property
    def address(self):  # type: () -&gt; int
        """Get the address of the first instruction in this basic block."""
        return self.start_address

    @property
    def start_address(self):  # type: () -&gt; int
        """Get the address of the first instruction in this basic block."""
        return self.raw.getMinAddress().getOffset()

    @property
    def end_address(self):  # type: () -&gt; int
        """Get the address of the last byte in this basic block.

        Note: this is not the address of the last instruction.
        Note: end_address - start_address is equal to length - 1. For example,
        for one-byte basic block, start_address == end_address."""
        return self.raw.getMaxAddress().getOffset()

    @property
    def length(self):  # type: () -&gt; int
        """Get the length of this basic block in bytes."""
        return self.end_address - self.start_address + 1

    @property
    def bytes(self):  # type: () -&gt; bytes
        """Get the bytes of this basic block.

        :return: bytes of this basic block."""
        return read_bytes(self.start_address, self.length)

    @property
    def instructions(self):  # type: () -&gt; list[Instruction]
        """Get a list of instructions in this basic block."""
        result = []
        instruction = getInstructionAt(resolve(self.start_address))
        while instruction and instruction.getAddress().getOffset() &lt;= self.end_address:
            result.append(Instruction(instruction))
            instruction = instruction.getNext()
        return result

    @property
    def pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get a list of Pcode operations that this basic block was parsed to"""
        result = []
        for instruction in self.instructions:
            result.extend(instruction.pcode)
        return result

    @property
    def destinations(self):  # type: () -&gt; list[BasicBlock]
        """Get a list of basic blocks that this basic block jumps to"""
        raw_refs = collect_iterator(self.raw.getDestinations(TaskMonitor.DUMMY))
        return [BasicBlock(raw.getDestinationBlock()) for raw in raw_refs]

    @property
    def sources(self):  # type: () -&gt; list[BasicBlock]
        """Get a list of basic blocks that jump to this basic block"""
        raw_refs = collect_iterator(self.raw.getSources(TaskMonitor.DUMMY))
        return [BasicBlock(raw.getSourceBlock()) for raw in raw_refs]

    @property
    def body(self):  # type: () -&gt; AddressSet
        """Get the address set of this basic block

        Technically BasicBlock (CodeBlock) is is already an AddressSet,
        but I think this is a useful distinction to keep."""
        return AddressSet(self.raw)

    @property
    def flow_type(self):  # type: () -&gt; FlowType
        """Get the flow type of this basic block.

        In other words, if any weird things with control flow are happening
        in this node."""
        return FlowType(self.raw.getFlowType())

    def __eq__(self, other):  # type: (object) -&gt; bool
        """Compare two basic blocks for equality.

        Apparently Ghidra doesn't know how to do this"""
        if not isinstance(other, BasicBlock):
            return False
        # This is not fully correct, but more correct than the default.
        return self.address == other.address</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of the first instruction in this basic block.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address set of this basic block</p>
<p>Technically BasicBlock (CodeBlock) is is already an AddressSet,
but I think this is a useful distinction to keep.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.bytes" class="doc doc-heading">
            <code class="highlight language-python">bytes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the bytes of this basic block.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>bytes of this basic block.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.destinations" class="doc doc-heading">
            <code class="highlight language-python">destinations</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of basic blocks that this basic block jumps to</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.end_address" class="doc doc-heading">
            <code class="highlight language-python">end_address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of the last byte in this basic block.</p>
<p>Note: this is not the address of the last instruction.
Note: end_address - start_address is equal to length - 1. For example,
for one-byte basic block, start_address == end_address.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.flow_type" class="doc doc-heading">
            <code class="highlight language-python">flow_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the flow type of this basic block.</p>
<p>In other words, if any weird things with control flow are happening
in this node.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.instructions" class="doc doc-heading">
            <code class="highlight language-python">instructions</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of instructions in this basic block.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.length" class="doc doc-heading">
            <code class="highlight language-python">length</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this basic block in bytes.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the name of this basic block.</p>
<p>Return the symbol at the start of this basic block, if any. Otherwise,
return the address of the first instruction as string.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.pcode" class="doc doc-heading">
            <code class="highlight language-python">pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of Pcode operations that this basic block was parsed to</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.sources" class="doc doc-heading">
            <code class="highlight language-python">sources</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of basic blocks that jump to this basic block</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BasicBlock.start_address" class="doc doc-heading">
            <code class="highlight language-python">start_address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of the first instruction in this basic block.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.BasicBlock.__eq__" class="doc doc-heading">
            <code class="highlight language-python">__eq__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Compare two basic blocks for equality.</p>
<p>Apparently Ghidra doesn't know how to do this</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __eq__(self, other):  # type: (object) -&gt; bool
    """Compare two basic blocks for equality.

    Apparently Ghidra doesn't know how to do this"""
    if not isinstance(other, BasicBlock):
        return False
    # This is not fully correct, but more correct than the default.
    return self.address == other.address</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.BasicBlock.all" class="doc doc-heading">
            <code class="highlight language-python">all(model='basic')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of all basic blocks in the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all(model="basic"):  # type: (str) -&gt; list[BasicBlock]
    """Get a list of all basic blocks in the program."""
    block_model = BasicBlock._model(model)(Program.current())
    return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.BasicBlock.get" class="doc doc-heading">
            <code class="highlight language-python">get(raw_or_address, model='basic')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a BasicBlock object containing the given address, or return None.</p>
<p>This function is tolerant and will accept different types of arguments:
* address as int
* Address object
* symbol as string (will be resolved)
* BasicBlock object (wrapped or unwrapped)</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>raw_or_address</code></b>
              –
              <div class="doc-md-description">
                <p>find basicblock that contains the given address.</p>
              </div>
            </li>
            <li>
              <b><code>model</code></b>
              –
              <div class="doc-md-description">
                <p>Ghidra supports different types of basic block "models". Supported options are "basic" and "simple".</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(
    raw_or_address, model="basic"
):  # type: (JavaObject|str|Addr, str) -&gt; BasicBlock|None
    """Get a BasicBlock object containing the given address, or return None.

    This function is tolerant and will accept different types of arguments:
    * address as int
    * Address object
    * symbol as string (will be resolved)
    * BasicBlock object (wrapped or unwrapped)

    :param raw_or_address: find basicblock that contains the given address.
    :param model: Ghidra supports different types of basic block "models".
    Supported options are "basic" and "simple"."""

    if raw_or_address is None:
        return None
    if can_resolve(raw_or_address):
        block_model = BasicBlock._model(model)(Program.current())
        addr = try_resolve(raw_or_address)
        if addr is None:
            return None
        raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY)
        if raw is None:
            return None
    else:
        raw = raw_or_address
    return BasicBlock(raw)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.BlockGraph" class="doc doc-heading">
            <code>BlockGraph</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="PcodeBlock (ghidralib.PcodeBlock)" href="#ghidralib.PcodeBlock">PcodeBlock</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class BlockGraph(PcodeBlock):
    @property
    def blocks(self):  # type: () -&gt; list[PcodeBlock]
        return [_pcode_node(self.raw.getBlock(i)) for i in range(self.raw.getSize())]</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BlockGraph.blocks" class="doc doc-heading">
            <code class="highlight language-python">blocks</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.BodyTrait" class="doc doc-heading">
            <code>BodyTrait</code>


</h2>


    <div class="doc doc-contents ">


        <p>A trait for objects that have a body.</p>
<p>It provides generic methods that work with anything that has a body
(an assigned set of addresses in the program), such as highlighting.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class BodyTrait:
    """A trait for objects that have a body.

    It provides generic methods that work with anything that has a body
    (an assigned set of addresses in the program), such as highlighting."""

    @property
    @abstractmethod
    def body(self):  # type: () -&gt; AddressSet
        """The body of this object"""

    def highlight(self, color=HIGHLIGHT_COLOR):  # type: (Color) -&gt; None
        """Highlight this instruction in the listing."""
        self.body.highlight(color)

    def unhighlight(self):  # type: () -&gt; None
        """Clear the highlight from this instruction."""
        self.body.unhighlight()</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.BodyTrait.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>The body of this object</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.BodyTrait.highlight" class="doc doc-heading">
            <code class="highlight language-python">highlight(color=HIGHLIGHT_COLOR)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Highlight this instruction in the listing.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def highlight(self, color=HIGHLIGHT_COLOR):  # type: (Color) -&gt; None
    """Highlight this instruction in the listing."""
    self.body.highlight(color)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.BodyTrait.unhighlight" class="doc doc-heading">
            <code class="highlight language-python">unhighlight()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Clear the highlight from this instruction.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def unhighlight(self):  # type: () -&gt; None
    """Clear the highlight from this instruction."""
    self.body.unhighlight()</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.ClangTokenGroup" class="doc doc-heading">
            <code>ClangTokenGroup</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Represents a group of clang tokens from a decompiler.</p>
<p>Warning: Currently this class is experimental, and should not be relied upon,
except to get the Java object (with .raw) or maybe dump (.dump()).</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class ClangTokenGroup(GhidraWrapper):
    """Represents a group of clang tokens from a decompiler.

    Warning: Currently this class is experimental, and should not be relied upon,
    except to get the Java object (with .raw) or maybe dump (.dump())."""

    def _cleanup(self, token):  # type: (JavaObject) -&gt; JavaObject
        new = GhClangTokenGroup(token.Parent())
        for token in list(token.iterator()):
            if isinstance(token, (ClangCommentToken, ClangBreak)):
                continue
            if isinstance(token, ClangSyntaxToken):
                if not token.getText() or token.getText().isspace():
                    continue
            if isinstance(token, GhClangTokenGroup):
                token = self._cleanup(token)
            new.AddTokenGroup(token)
        return new

    @property
    def cleaned(self):  # type: () -&gt; ClangTokenGroup
        """Remove all whitespace and comments from this token group, recursively."""
        return ClangTokenGroup(self._cleanup(self.raw))

    def _dump(self, token, indent=0):  # type: (JavaObject, int) -&gt; None
        if isinstance(token, GhClangTokenGroup):
            print("{}[group]".format(indent * "  ", token.__class__.__name__))
            for child in token.iterator():
                self._dump(child, indent + 1)
        else:
            print("{}{} ({})".format(indent * "  ", token, token.__class__.__name__))

    def dump(self):  # type: () -&gt; None
        self._dump(self.raw)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.ClangTokenGroup.cleaned" class="doc doc-heading">
            <code class="highlight language-python">cleaned</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Remove all whitespace and comments from this token group, recursively.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.ClangTokenGroup.dump" class="doc doc-heading">
            <code class="highlight language-python">dump()</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def dump(self):  # type: () -&gt; None
    self._dump(self.raw)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Data" class="doc doc-heading">
            <code>Data</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a structure for convenient access by field name</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Data(GhidraWrapper):
    """ Wraps a structure for convenient access by field name """

    @staticmethod
    def get(addr):  # type: (JavaObject|str|Addr) -&gt; Data|None
        """Return a Data instance at the given address, or None if there is
        no Data defined there."""
        if isinstance(addr, GhData):
            return Data(addr)
        addr = try_resolve(addr)
        if addr is None:
            return None
        raw = getDataAt(addr)
        if raw is None:
            return None
        return Data(raw)  # type: ignore

    def __getattr__(self, name):
        for i in range(self.raw.getNumComponents()):
            field = self.raw.getComponent(i)
            if field.getFieldName() == name:
                if field.isStructure():
                    return Data(field)
                return GhidraWrapper(field)
        raise AttributeError("Field %s does not exist" % name)</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ghidralib.Data.__getattr__" class="doc doc-heading">
            <code class="highlight language-python">__getattr__(name)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __getattr__(self, name):
    for i in range(self.raw.getNumComponents()):
        field = self.raw.getComponent(i)
        if field.getFieldName() == name:
            if field.isStructure():
                return Data(field)
            return GhidraWrapper(field)
    raise AttributeError("Field %s does not exist" % name)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Data.get" class="doc doc-heading">
            <code class="highlight language-python">get(addr)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return a Data instance at the given address, or None if there is
no Data defined there.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(addr):  # type: (JavaObject|str|Addr) -&gt; Data|None
    """Return a Data instance at the given address, or None if there is
    no Data defined there."""
    if isinstance(addr, GhData):
        return Data(addr)
    addr = try_resolve(addr)
    if addr is None:
        return None
    raw = getDataAt(addr)
    if raw is None:
        return None
    return Data(raw)  # type: ignore</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.DataType" class="doc doc-heading">
            <code>DataType</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class DataType(GhidraWrapper):
    @staticmethod
    def get(name_or_raw):  # type: (DataT) -&gt; DataType|None
        """Gets a data type by name, or returns None if not found.

        Warning: this method is relatively slow, since it scans
        all data types in all data type managers.

            &gt;&gt;&gt; DataType.get("int")
            int

        :param name_or_raw: the name of the data type
        :return: the data type, or None if not found"""
        if not isinstance(name_or_raw, Str):
            return DataType(name_or_raw)

        for datatype in DataType.all():
            if datatype.name == name_or_raw:
                return DataType(datatype)
        return None

    @staticmethod
    def all(only_local=False):  # type: (bool) -&gt; list[DataType]
        """Get all data types

        :param only_local: if True, return only local data types. Otherwise,
          will scan all data types in all data type managers."""
        datatypes = list(Program.current().getDataTypeManager().getAllDataTypes())
        if not only_local:
            managers = (
                getState()
                .getTool()
                .getService(DataTypeManagerService)
                .getDataTypeManagers()
            )
            for manager in managers:
                for datatype in manager.getAllDataTypes():
                    datatypes.append(datatype)
        return [DataType(raw) for raw in datatypes]

    @property
    def name(self):  # type: () -&gt; str
        """Get a name of this data type

            &gt;&gt;&gt; DataType('int').name
            'int'
        .
        """
        return self.raw.getName()

    def get_name(self, value):  # type: (int) -&gt; str
        """If this data type is an enum, get the name of the value.

        :param value: the value to get the name of"""
        return self.raw.getName(value)

    def length(self):  # type: () -&gt; int
        """Get the length of this data type in bytes

            &gt;&gt;&gt; DataType('int').length()
            4
        .
        """
        return self.raw.getLength()

    __len__ = length

    @staticmethod
    def from_c(c_code, insert=True):  # type: (str, bool) -&gt; DataType
        """Parse C structure definition and return the parsed DataType.

        If insert (true by default), add it to current program.
        Example of a valid c_code is `typedef void* HINTERNET;`

            &gt;&gt;&gt; DataType.from_c('typedef void* HINTERNET;')
            HINTERNET
            &gt;&gt;&gt; DataType.from_c("struct test { short a; short b; short c;};")
            pack()
            Structure test {
            0   short   2   a   ""
            2   short   2   b   ""
            4   short   2   c   ""
            }
            Length: 6 Alignment: 2

        :param c_code: the C structure definition
        :param insert: if True, add the data type to the current program
        """
        dtm = Program.current().getDataTypeManager()
        parser = CParser(dtm)

        new_dt = parser.parse(c_code)

        if insert:
            transaction = dtm.startTransaction("Adding new data")
            dtm.addDataType(new_dt, None)
            dtm.endTransaction(transaction, True)

        return new_dt</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.DataType.__len__" class="doc doc-heading">
            <code class="highlight language-python">__len__ = length</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.DataType.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a name of this data type</p>
<pre><code>&gt;&gt;&gt; DataType('int').name
'int'
</code></pre>
<p>.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.DataType.all" class="doc doc-heading">
            <code class="highlight language-python">all(only_local=False)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all data types</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>only_local</code></b>
              –
              <div class="doc-md-description">
                <p>if True, return only local data types. Otherwise, will scan all data types in all data type managers.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all(only_local=False):  # type: (bool) -&gt; list[DataType]
    """Get all data types

    :param only_local: if True, return only local data types. Otherwise,
      will scan all data types in all data type managers."""
    datatypes = list(Program.current().getDataTypeManager().getAllDataTypes())
    if not only_local:
        managers = (
            getState()
            .getTool()
            .getService(DataTypeManagerService)
            .getDataTypeManagers()
        )
        for manager in managers:
            for datatype in manager.getAllDataTypes():
                datatypes.append(datatype)
    return [DataType(raw) for raw in datatypes]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.DataType.from_c" class="doc doc-heading">
            <code class="highlight language-python">from_c(c_code, insert=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Parse C structure definition and return the parsed DataType.</p>
<p>If insert (true by default), add it to current program.
Example of a valid c_code is <code>typedef void* HINTERNET;</code></p>
<pre><code>&gt;&gt;&gt; DataType.from_c('typedef void* HINTERNET;')
HINTERNET
&gt;&gt;&gt; DataType.from_c("struct test { short a; short b; short c;};")
pack()
Structure test {
0   short   2   a   ""
2   short   2   b   ""
4   short   2   c   ""
}
Length: 6 Alignment: 2
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>c_code</code></b>
              –
              <div class="doc-md-description">
                <p>the C structure definition</p>
              </div>
            </li>
            <li>
              <b><code>insert</code></b>
              –
              <div class="doc-md-description">
                <p>if True, add the data type to the current program</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def from_c(c_code, insert=True):  # type: (str, bool) -&gt; DataType
    """Parse C structure definition and return the parsed DataType.

    If insert (true by default), add it to current program.
    Example of a valid c_code is `typedef void* HINTERNET;`

        &gt;&gt;&gt; DataType.from_c('typedef void* HINTERNET;')
        HINTERNET
        &gt;&gt;&gt; DataType.from_c("struct test { short a; short b; short c;};")
        pack()
        Structure test {
        0   short   2   a   ""
        2   short   2   b   ""
        4   short   2   c   ""
        }
        Length: 6 Alignment: 2

    :param c_code: the C structure definition
    :param insert: if True, add the data type to the current program
    """
    dtm = Program.current().getDataTypeManager()
    parser = CParser(dtm)

    new_dt = parser.parse(c_code)

    if insert:
        transaction = dtm.startTransaction("Adding new data")
        dtm.addDataType(new_dt, None)
        dtm.endTransaction(transaction, True)

    return new_dt</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.DataType.get" class="doc doc-heading">
            <code class="highlight language-python">get(name_or_raw)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Gets a data type by name, or returns None if not found.</p>
<p>Warning: this method is relatively slow, since it scans
all data types in all data type managers.</p>
<pre><code>&gt;&gt;&gt; DataType.get("int")
int
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>name_or_raw</code></b>
              –
              <div class="doc-md-description">
                <p>the name of the data type</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>the data type, or None if not found</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(name_or_raw):  # type: (DataT) -&gt; DataType|None
    """Gets a data type by name, or returns None if not found.

    Warning: this method is relatively slow, since it scans
    all data types in all data type managers.

        &gt;&gt;&gt; DataType.get("int")
        int

    :param name_or_raw: the name of the data type
    :return: the data type, or None if not found"""
    if not isinstance(name_or_raw, Str):
        return DataType(name_or_raw)

    for datatype in DataType.all():
        if datatype.name == name_or_raw:
            return DataType(datatype)
    return None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.DataType.get_name" class="doc doc-heading">
            <code class="highlight language-python">get_name(value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>If this data type is an enum, get the name of the value.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>the value to get the name of</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_name(self, value):  # type: (int) -&gt; str
    """If this data type is an enum, get the name of the value.

    :param value: the value to get the name of"""
    return self.raw.getName(value)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.DataType.length" class="doc doc-heading">
            <code class="highlight language-python">length()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this data type in bytes</p>
<pre><code>&gt;&gt;&gt; DataType('int').length()
4
</code></pre>
<p>.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def length(self):  # type: () -&gt; int
    """Get the length of this data type in bytes

        &gt;&gt;&gt; DataType('int').length()
        4
    .
    """
    return self.raw.getLength()</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Emulator" class="doc doc-heading">
            <code>Emulator</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra EmulatorHelper object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Emulator(GhidraWrapper):
    """Wraps a Ghidra EmulatorHelper object."""

    def __init__(self):  # type: () -&gt; None
        """Create a new Emulator object."""
        raw = EmulatorHelper(Program.current())
        GhidraWrapper.__init__(self, raw)

        # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU.
        max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset()
        max_pointer = max_pointer % 2**64  # Java signed ints everywhere strike again.
        stack_off = ((max_pointer + 1) &gt;&gt; 1) - 0x8000
        self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off)

        # TODO: add a simple allocation manager
        self._hooks = {}  # type: dict[int, Callable[[Emulator], str|None]]

    def add_hook(
        self, address, hook
    ):  # type: (Addr, Callable[[Emulator], str|None]) -&gt; None
        """Add a hook at a specified address.

        Hook is a function that gets emulator as parameter. It can return one of:

        * 'continue' or None, to continue execution normally
        * 'break' to stop execution
        * 'skip' to skip the next instruction

        Note: multiple hooks at the same address are not currently supported."""
        addr = resolve(address).getOffset()
        if addr in self._hooks:
            raise ValueError("Multiple hooks at the same address are not supported")
        self._hooks[addr] = hook

    def has_hook_at(self, address):  # type: (Addr) -&gt; bool
        addr = resolve(address).getOffset()
        return addr in self._hooks

    def delete_hook_at(self, address):  # type: (Addr) -&gt; None
        addr = resolve(address).getOffset()
        del self._hooks[addr]

    @property
    def pc(self):  # type: () -&gt; int
        """Get the program counter of the emulated program."""
        return self.raw.getExecutionAddress().getOffset()

    @pc.setter
    def pc(self, address):  # type: (Addr) -&gt; None
        """Set the program counter of the emulated program."""
        self.set_pc(address)

    def set_pc(self, address):  # type: (Addr) -&gt; None
        """Set the program counter of the emulated program."""
        pc = self.raw.getPCRegister()
        self.raw.writeRegister(pc, resolve(address).getOffset())

    @property
    def sp_register(self):  # type: () -&gt; str
        """Get the stack pointer register name for the emulated architecture."""
        return self.raw.getStackPointerRegister().getName()

    @property
    def sp(self):  # type: () -&gt; int
        """Get the current stack pointer register value."""
        return self.read_register(self.sp_register)

    @sp.setter
    def sp(self, value):  # type: (Addr) -&gt; None
        """Set the current stack pointer register value.

        :param value: new stack pointer value."""
        self.set_sp(value)

    def set_sp(self, value):  # type: (Addr) -&gt; None
        """Set the current stack pointer register value.

        :param value: new stack pointer value."""
        self.write_register(self.sp_register, resolve(value).getOffset())

    def __getitem__(self, reg):  # type: (Reg|int) -&gt; int
        """Read the register of the emulated program.

            &gt;&gt;&gt; emulator.write_register("eax", 1337)
            &gt;&gt;&gt; emulator["eax"]
            1337

        :param reg: the register or address to read from"""
        return self.read_register(reg)

    def __setitem__(self, reg, value):  # type: (Reg, int) -&gt; None
        """Write to the register of the emulated program.

            &gt;&gt;&gt; emulator["eax"] = 1234
            &gt;&gt;&gt; emulator.read_register("eax")
            1337

        :param reg: the register to write to
        :param value: the value to write"""
        self.write_register(reg, value)

    def read_register(self, reg):  # type: (Reg) -&gt; int
        """Read from the register of the emulated program.

            &gt;&gt;&gt; emulator.write_register("eax", 1337)
            &gt;&gt;&gt; emulator.read_register("eax")
            1337

        :param reg: the register to read from."""
        return _python_int(self.raw.readRegister(reg))

    def read_bytes(self, address, length):  # type: (Addr, int) -&gt; bytes
        """Read `length` bytes at `address` from the emulated program.

            &gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
            &gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
            '1'

        :param address: the address to read from
        :param length: the length to read"""
        bytelist = self.raw.readMemory(resolve(address), length)
        return _bytes_from_bytelist(bytelist)

    def read_u8(self, address):  # type: (Addr) -&gt; int
        """Read a byte from the emulated program.

            &gt;&gt;&gt; emulator.write_u8(0x1000, 13)
            &gt;&gt;&gt; emulator.read_u8(0x1000)
            13

        :param address: the address to read from"""
        return from_bytes(self.read_bytes(address, 1))

    def read_u16(self, address):  # type: (Addr) -&gt; int
        """Read a 16bit unsigned integer from the emulated program.

            &gt;&gt;&gt; emulator.write_u16(0x1000, 123)
            &gt;&gt;&gt; emulator.read_u16(0x1000)
            123

        :param address: the address to read from"""
        return from_bytes(self.read_bytes(address, 2))

    def read_u32(self, address):  # type: (Addr) -&gt; int
        """Read a 32bit unsigned integer from the emulated program.

            &gt;&gt;&gt; emulator.write_u32(0x1000, 123)
            &gt;&gt;&gt; emulator.read_u32(0x1000)
            123

        :param address: the address to read from"""
        return from_bytes(self.read_bytes(address, 4))

    def read_u64(self, address):  # type: (Addr) -&gt; int
        """Read a 64bit unsigned integer from the emulated program.

            &gt;&gt;&gt; emulator.write_u64(0x1000, 123)
            &gt;&gt;&gt; emulator.read_u64(0x1000)
            123

        :param address: the address to read from"""
        return from_bytes(self.read_bytes(address, 8))

    def read_cstring(self, address):  # type: (Addr) -&gt; str
        """Read a null-terminated string from the emulated program.

        This function reads bytes until a nullbyte is encountered.

            &gt;&gt;&gt; emu.read_cstring(0x1000)
            'Hello, world!'

        :param address: address from which to start reading."""
        addr = resolve(address)
        string = ""
        while True:
            c = self.read_u8(addr)
            if c == 0:
                break
            string += chr(c)
            addr = addr.add(1)
        return string

    def read_unicode(self, address):  # type: (Addr) -&gt; str
        """Read a null-terminated utf-16 string from the emulated program.

        This function reads bytes until a null character is encountered.

            &gt;&gt;&gt; emu.read_unicode(0x1000)
            'Hello, world!'

        :param address: address from which to start reading."""
        addr = resolve(address)
        string = ""
        while True:
            c = self.read_u16(addr)
            if c == 0:
                break
            string += chr(c)
            addr = addr.add(2)
        return string

    def read_varnode(self, varnode):  # type: (Varnode) -&gt; int
        """Read from the varnode from the emulated program.

        This method can't read hash varnodes.

            &gt;&gt;&gt; fnc = Function("AddNumbers")
            &gt;&gt;&gt; emu = Emulator()
            &gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
            &gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
            &gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
            &gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
            4

        :param varnode: the varnode to read from."""
        varnode = Varnode(varnode)
        if varnode.is_constant:
            return varnode.offset
        elif varnode.is_address:
            rawnum = self.read_bytes(varnode.offset, varnode.size)
            return from_bytes(rawnum)
        elif varnode.is_unique:
            space = Program.current().getAddressFactory().getUniqueSpace()
            offset = space.getAddress(varnode.offset)
            rawnum = self.read_bytes(offset, varnode.size)
            return from_bytes(rawnum)
        elif varnode.is_stack:
            return self.raw.readStackValue(varnode.offset, varnode.size, False)
        elif varnode.is_register:
            language = Program.current().getLanguage()
            reg = language.getRegister(varnode.raw.getAddress(), varnode.size)
            return self.read_register(reg)
        raise RuntimeError("Unsupported varnode type")

    def write_register(self, reg, value):  # type: (Reg, int) -&gt; None
        """Write to the register of the emulated program.

            &gt;&gt;&gt; emulator.write_register("eax", 1)
            &gt;&gt;&gt; emulator.read_register("eax")
            1

        :param reg: the register to write to
        :param value: the value to write"""
        self.raw.writeRegister(reg, value)

    def write_bytes(self, address, value):  # type: (Addr, bytes) -&gt; None
        """Write to the memory of the emulated program.

            &gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
            &gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
            '1'

        :param address: the address to write to
        :param value: the value to write"""
        self.raw.writeMemory(resolve(address), value)

    def write_u8(self, address, value):  # type: (Addr, int) -&gt; None
        """Write a byte to the emulated program.

            &gt;&gt;&gt; emulator.write_u8(0x1000, 13)
            &gt;&gt;&gt; emulator.read_u8(0x1000)
            13

        :param address: the address to write to"""
        assert 0 &lt;= value &lt; 2**8, "value out of range"
        self.write_bytes(address, to_bytes(value, 1))

    def write_u16(self, address, value):  # type: (Addr, int) -&gt; None
        """Write a 16bit unsigned integer to the emulated program.

            &gt;&gt;&gt; emulator.write_u16(0x1000, 13)
            &gt;&gt;&gt; emulator.read_u16(0x1000)
            13

        :param address: the address to write to"""
        assert 0 &lt;= value &lt; 2**16, "value out of range"
        self.write_bytes(address, to_bytes(value, 2))

    def write_u32(self, address, value):  # type: (Addr, int) -&gt; None
        """Write a 32bit unsigned integer to the emulated program.

            &gt;&gt;&gt; emulator.write_u32(0x1000, 13)
            &gt;&gt;&gt; emulator.read_u32(0x1000)
            13

        :param address: the address to write to"""
        assert 0 &lt;= value &lt; 2**32, "value out of range"
        self.write_bytes(address, to_bytes(value, 4))

    def write_u64(self, address, value):  # type: (Addr, int) -&gt; None
        """Write a 64bit unsigned integer to the emulated program.

            &gt;&gt;&gt; emulator.write_u64(0x1000, 13)
            &gt;&gt;&gt; emulator.read_u64(0x1000)
            13

        :param address: the address to write to"""
        assert 0 &lt;= value &lt; 2**64, "value out of range"
        self.write_bytes(address, to_bytes(value, 8))

    def write_varnode(self, varnode, value):  # type: (Varnode, int) -&gt; None
        """Set a varnode value in the emulated context.

        This method can't set hash and constant varnodes.

            &gt;&gt;&gt; fnc = Function("AddNumbers")
            &gt;&gt;&gt; emu = Emulator()
            &gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
            &gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
            &gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
            &gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
            4

        :param varnode: the varnode to read from."""
        varnode = Varnode(varnode)
        if varnode.is_constant:
            raise ValueError("Can't set value of a constant varnodes")
        elif varnode.is_address:
            self.write_bytes(varnode.offset, to_bytes(value, varnode.size))
        elif varnode.is_unique:
            space = Program.current().getAddressFactory().getUniqueSpace()
            offset = space.getAddress(varnode.offset)
            self.write_bytes(offset, to_bytes(value, varnode.size))
        elif varnode.is_stack:
            self.raw.writeStackValue(varnode.offset, varnode.size, value)
        elif varnode.is_register:
            language = Program.current().getLanguage()
            reg = language.getRegister(varnode.raw.getAddress(), varnode.size)
            self.raw.writeRegister(reg, value)
        else:
            raise RuntimeError("Unsupported varnode type")

    def __run_with_hooks(self):  # type: () -&gt; bool
        """Run the Ghidra emulator, and transparently handle all hooks.

        :return: True if emulator stopped at a breakpoint, or
          hook asked emulator to stop (by returning break)."""

        while not getMonitor().isCancelled():
            is_breakpoint = self.raw.run(getMonitor())
            if self.pc not in self._hooks:
                return is_breakpoint

            result = self._hooks[self.pc](self)
            if self.__handle_hook_result(result):
                return True

        return False

    def add_breakpoint(self, address):  # type: (Addr) -&gt; None
        """Add a breakpoint at the given address.

        :param address: the address to break on"""
        self.raw.setBreakpoint(resolve(address))

    def clear_breakpoint(self, address):  # type: (Addr) -&gt; None
        """Clear a breakpoint at the given address.

        :param address: the address to clear breakpoint from"""
        self.raw.clearBreakpoint(resolve(address))

    def emulate_fast(self, start, ends):  # type: (Addr, Addr|list[Addr]) -&gt; None
        """Emulate from start to end address, using Ghidra for fast emulation.

        The main loop of this function is in Java, which makes it faster, but makes
        some features (like callbacks) impossible. This function stops on error,
        when PC reaches one of the ends, and will also call hooks.

        This method will set a breakpoint at the end address, and clear it after
        the emulation is done.

            &gt;&gt;&gt; emulator.write_bytes(0x2000, "1")
            &gt;&gt;&gt; emulator.emulate_fast(0x1000, 0x1005)
            &gt;&gt;&gt; emulator.read_bytes(0x2000, 1)
            '0'

        :param start: the start address to emulate
        :param ends: one or many end address"""
        self.set_pc(start)

        if not isinstance(ends, (list, tuple)):
            ends = [ends]

        for end in ends:
            self.add_breakpoint(end)

        is_breakpoint = self.__run_with_hooks()

        for end in ends:
            self.clear_breakpoint(end)

        if not is_breakpoint:
            err = self.raw.getLastError()
            raise RuntimeError("Error when running: {}".format(err))

    def __handle_hook_result(self, result):  # type: (str|None) -&gt; bool
        """Handle a hook return value and return True if emulation should stop."""
        if result is None or result == "continue":
            return False
        elif result == "skip":
            self.pc = Instruction(self.pc).next.address
            return False
        elif result == "break":
            return True
        else:
            raise RuntimeError("Invalid hook return value: {}".format(result))

    def single_step(self):  # type: () -&gt; bool
        """Do a single emulation step. This will step into calls.

        Note: This method *will* call hooks.

        :return: True if the emulation should be stopped, False otherwise."""
        success = self.raw.step(getMonitor())
        if not success:
            err = self.raw.getLastError()
            raise RuntimeError("Error at {}: {}".format(self.pc, err))

        if self.pc in self._hooks:
            result = self._hooks[self.pc](self)
            return self.__handle_hook_result(result)
        if self.is_at_breakpoint:
            return True
        return False

    @staticmethod
    def new(
        start,
        ends=[],
        callback=lambda emu: None,
        stop_when=lambda emu: False,
        maxsteps=2**48,
    ):  # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -&gt; Emulator
        """Emulate from start to end address, with callback for each executed address.

            &gt;&gt;&gt; Emulator.new("main", maxsteps=100)["EAX"]
            128

        This function is a convenience wrapper around emulate and can be always
        replaced by three lines of code. The above is equivalent to:

            &gt;&gt;&gt; emu = Emulator()
            &gt;&gt;&gt; emu.emulate("main", maxsteps=100)
            &gt;&gt;&gt; emu["EAX"]
            128

        This function may be used for quickly doing one-off emulations.

        See `emulate` documentation for info about this method parameters."""
        emu = Emulator()
        emu.emulate(start, ends, callback, stop_when, maxsteps)
        return emu

    def emulate(
        self,
        start,
        ends=[],
        callback=lambda emu: None,
        stop_when=lambda emu: False,
        maxsteps=2**48,
    ):  # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -&gt; None
        """Emulate from start to end address, with callback for each executed address.

            &gt;&gt;&gt; emu = Emulator()
            &gt;&gt;&gt; def callback(emu):
            &gt;&gt;&gt;     print("executing {:x}'.format(emu.pc))
            &gt;&gt;&gt; emu.emulate(Function("main").entrypoint, callback=callback, maxsteps=3)
            SUB ESP,0x2d4
            PUSH EBX
            PUSH EBP

        Callback should return one of:

        * 'continue' or None, to continue execution normally
        * 'break' to stop execution
        * 'skip' to skip the next instruction
        * 'retry' like continue, but call the callback again (useful after pc change)
        * 'continue_then_break' to execute one last instruction before stopping

        Returning another value will cause an exception Callback is executed before
        stop_when condition is checked.

        This method is very flexible, but because of that it may be slower than
        pure Ghidra implementation. Consider .emulate_fast() when this method is too
        slow for you.

        :param start: the start address to emulate
        :param end: the end address to emulate
        :param callback: the callback to call before each executed instruction.
          Return one of the predefined constants here (see the docs for more info).
        :param stop_when: the callback to call before each executed instruction.
          Return True here to stop emulation.
        :param maxsteps: the maximum number of steps to execute"""
        self.set_pc(start)

        if not isinstance(ends, (list, tuple)):
            ends = [ends]
        ends = [resolve(e).getOffset() for e in ends]

        while maxsteps &gt; 0:
            maxsteps -= 1
            if self.pc in ends:
                break

            command = callback(self)
            if command == "retry":
                continue
            elif command == "continue_then_break":
                maxsteps = 0
            elif self.__handle_hook_result(command):
                return

            if stop_when(self):
                return

            if self.single_step():
                return

    @property
    def is_at_breakpoint(self):  # type: () -&gt; bool
        """Check if the emulator is at a breakpoint"""
        return self.raw.getEmulator().isAtBreakpoint()

    # Basic unicorn compatibility, because why not
    # You may prefer these aliases if you already know Unicorn API.
    reg_write = write_register
    reg_read = read_register
    mem_write = write_bytes
    mem_read = read_bytes
    mem_map = (
        lambda _1, _2, _3: None
    )  # This is a noop - all memory is already available.
    emu_start = lambda self, begin, until: self.emulate(begin, until)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.emu_start" class="doc doc-heading">
            <code class="highlight language-python">emu_start = lambda self, begin, until: self.emulate(begin, until)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.is_at_breakpoint" class="doc doc-heading">
            <code class="highlight language-python">is_at_breakpoint</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if the emulator is at a breakpoint</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.mem_map" class="doc doc-heading">
            <code class="highlight language-python">mem_map = lambda _1, _2, _3: None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.mem_read" class="doc doc-heading">
            <code class="highlight language-python">mem_read = read_bytes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.mem_write" class="doc doc-heading">
            <code class="highlight language-python">mem_write = write_bytes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.pc" class="doc doc-heading">
            <code class="highlight language-python">pc</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the program counter of the emulated program.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.reg_read" class="doc doc-heading">
            <code class="highlight language-python">reg_read = read_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.reg_write" class="doc doc-heading">
            <code class="highlight language-python">reg_write = write_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.sp" class="doc doc-heading">
            <code class="highlight language-python">sp</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the current stack pointer register value.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Emulator.sp_register" class="doc doc-heading">
            <code class="highlight language-python">sp_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the stack pointer register name for the emulated architecture.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.__getitem__" class="doc doc-heading">
            <code class="highlight language-python">__getitem__(reg)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read the register of the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_register("eax", 1337)
&gt;&gt;&gt; emulator["eax"]
1337
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>reg</code></b>
              –
              <div class="doc-md-description">
                <p>the register or address to read from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __getitem__(self, reg):  # type: (Reg|int) -&gt; int
    """Read the register of the emulated program.

        &gt;&gt;&gt; emulator.write_register("eax", 1337)
        &gt;&gt;&gt; emulator["eax"]
        1337

    :param reg: the register or address to read from"""
    return self.read_register(reg)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.__handle_hook_result" class="doc doc-heading">
            <code class="highlight language-python">__handle_hook_result(result)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Handle a hook return value and return True if emulation should stop.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __handle_hook_result(self, result):  # type: (str|None) -&gt; bool
    """Handle a hook return value and return True if emulation should stop."""
    if result is None or result == "continue":
        return False
    elif result == "skip":
        self.pc = Instruction(self.pc).next.address
        return False
    elif result == "break":
        return True
    else:
        raise RuntimeError("Invalid hook return value: {}".format(result))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new Emulator object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self):  # type: () -&gt; None
    """Create a new Emulator object."""
    raw = EmulatorHelper(Program.current())
    GhidraWrapper.__init__(self, raw)

    # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU.
    max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset()
    max_pointer = max_pointer % 2**64  # Java signed ints everywhere strike again.
    stack_off = ((max_pointer + 1) &gt;&gt; 1) - 0x8000
    self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off)

    # TODO: add a simple allocation manager
    self._hooks = {}  # type: dict[int, Callable[[Emulator], str|None]]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.__run_with_hooks" class="doc doc-heading">
            <code class="highlight language-python">__run_with_hooks()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Run the Ghidra emulator, and transparently handle all hooks.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break).</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __run_with_hooks(self):  # type: () -&gt; bool
    """Run the Ghidra emulator, and transparently handle all hooks.

    :return: True if emulator stopped at a breakpoint, or
      hook asked emulator to stop (by returning break)."""

    while not getMonitor().isCancelled():
        is_breakpoint = self.raw.run(getMonitor())
        if self.pc not in self._hooks:
            return is_breakpoint

        result = self._hooks[self.pc](self)
        if self.__handle_hook_result(result):
            return True

    return False</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.__setitem__" class="doc doc-heading">
            <code class="highlight language-python">__setitem__(reg, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write to the register of the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator["eax"] = 1234
&gt;&gt;&gt; emulator.read_register("eax")
1337
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>reg</code></b>
              –
              <div class="doc-md-description">
                <p>the register to write to</p>
              </div>
            </li>
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>the value to write</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __setitem__(self, reg, value):  # type: (Reg, int) -&gt; None
    """Write to the register of the emulated program.

        &gt;&gt;&gt; emulator["eax"] = 1234
        &gt;&gt;&gt; emulator.read_register("eax")
        1337

    :param reg: the register to write to
    :param value: the value to write"""
    self.write_register(reg, value)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.add_breakpoint" class="doc doc-heading">
            <code class="highlight language-python">add_breakpoint(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Add a breakpoint at the given address.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to break on</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_breakpoint(self, address):  # type: (Addr) -&gt; None
    """Add a breakpoint at the given address.

    :param address: the address to break on"""
    self.raw.setBreakpoint(resolve(address))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.add_hook" class="doc doc-heading">
            <code class="highlight language-python">add_hook(address, hook)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Add a hook at a specified address.</p>
<p>Hook is a function that gets emulator as parameter. It can return one of:</p>
<ul>
<li>'continue' or None, to continue execution normally</li>
<li>'break' to stop execution</li>
<li>'skip' to skip the next instruction</li>
</ul>
<p>Note: multiple hooks at the same address are not currently supported.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_hook(
    self, address, hook
):  # type: (Addr, Callable[[Emulator], str|None]) -&gt; None
    """Add a hook at a specified address.

    Hook is a function that gets emulator as parameter. It can return one of:

    * 'continue' or None, to continue execution normally
    * 'break' to stop execution
    * 'skip' to skip the next instruction

    Note: multiple hooks at the same address are not currently supported."""
    addr = resolve(address).getOffset()
    if addr in self._hooks:
        raise ValueError("Multiple hooks at the same address are not supported")
    self._hooks[addr] = hook</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.clear_breakpoint" class="doc doc-heading">
            <code class="highlight language-python">clear_breakpoint(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Clear a breakpoint at the given address.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to clear breakpoint from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def clear_breakpoint(self, address):  # type: (Addr) -&gt; None
    """Clear a breakpoint at the given address.

    :param address: the address to clear breakpoint from"""
    self.raw.clearBreakpoint(resolve(address))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.delete_hook_at" class="doc doc-heading">
            <code class="highlight language-python">delete_hook_at(address)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def delete_hook_at(self, address):  # type: (Addr) -&gt; None
    addr = resolve(address).getOffset()
    del self._hooks[addr]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.emulate" class="doc doc-heading">
            <code class="highlight language-python">emulate(start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2 ** 48)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate from start to end address, with callback for each executed address.</p>
<pre><code>&gt;&gt;&gt; emu = Emulator()
&gt;&gt;&gt; def callback(emu):
&gt;&gt;&gt;     print("executing {:x}'.format(emu.pc))
&gt;&gt;&gt; emu.emulate(Function("main").entrypoint, callback=callback, maxsteps=3)
SUB ESP,0x2d4
PUSH EBX
PUSH EBP
</code></pre>
<p>Callback should return one of:</p>
<ul>
<li>'continue' or None, to continue execution normally</li>
<li>'break' to stop execution</li>
<li>'skip' to skip the next instruction</li>
<li>'retry' like continue, but call the callback again (useful after pc change)</li>
<li>'continue_then_break' to execute one last instruction before stopping</li>
</ul>
<p>Returning another value will cause an exception Callback is executed before
stop_when condition is checked.</p>
<p>This method is very flexible, but because of that it may be slower than
pure Ghidra implementation. Consider .emulate_fast() when this method is too
slow for you.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>start</code></b>
              –
              <div class="doc-md-description">
                <p>the start address to emulate</p>
              </div>
            </li>
            <li>
              <b><code>end</code></b>
              –
              <div class="doc-md-description">
                <p>the end address to emulate</p>
              </div>
            </li>
            <li>
              <b><code>callback</code></b>
              –
              <div class="doc-md-description">
                <p>the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info).</p>
              </div>
            </li>
            <li>
              <b><code>stop_when</code></b>
              –
              <div class="doc-md-description">
                <p>the callback to call before each executed instruction. Return True here to stop emulation.</p>
              </div>
            </li>
            <li>
              <b><code>maxsteps</code></b>
              –
              <div class="doc-md-description">
                <p>the maximum number of steps to execute</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def emulate(
    self,
    start,
    ends=[],
    callback=lambda emu: None,
    stop_when=lambda emu: False,
    maxsteps=2**48,
):  # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -&gt; None
    """Emulate from start to end address, with callback for each executed address.

        &gt;&gt;&gt; emu = Emulator()
        &gt;&gt;&gt; def callback(emu):
        &gt;&gt;&gt;     print("executing {:x}'.format(emu.pc))
        &gt;&gt;&gt; emu.emulate(Function("main").entrypoint, callback=callback, maxsteps=3)
        SUB ESP,0x2d4
        PUSH EBX
        PUSH EBP

    Callback should return one of:

    * 'continue' or None, to continue execution normally
    * 'break' to stop execution
    * 'skip' to skip the next instruction
    * 'retry' like continue, but call the callback again (useful after pc change)
    * 'continue_then_break' to execute one last instruction before stopping

    Returning another value will cause an exception Callback is executed before
    stop_when condition is checked.

    This method is very flexible, but because of that it may be slower than
    pure Ghidra implementation. Consider .emulate_fast() when this method is too
    slow for you.

    :param start: the start address to emulate
    :param end: the end address to emulate
    :param callback: the callback to call before each executed instruction.
      Return one of the predefined constants here (see the docs for more info).
    :param stop_when: the callback to call before each executed instruction.
      Return True here to stop emulation.
    :param maxsteps: the maximum number of steps to execute"""
    self.set_pc(start)

    if not isinstance(ends, (list, tuple)):
        ends = [ends]
    ends = [resolve(e).getOffset() for e in ends]

    while maxsteps &gt; 0:
        maxsteps -= 1
        if self.pc in ends:
            break

        command = callback(self)
        if command == "retry":
            continue
        elif command == "continue_then_break":
            maxsteps = 0
        elif self.__handle_hook_result(command):
            return

        if stop_when(self):
            return

        if self.single_step():
            return</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.emulate_fast" class="doc doc-heading">
            <code class="highlight language-python">emulate_fast(start, ends)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate from start to end address, using Ghidra for fast emulation.</p>
<p>The main loop of this function is in Java, which makes it faster, but makes
some features (like callbacks) impossible. This function stops on error,
when PC reaches one of the ends, and will also call hooks.</p>
<p>This method will set a breakpoint at the end address, and clear it after
the emulation is done.</p>
<pre><code>&gt;&gt;&gt; emulator.write_bytes(0x2000, "1")
&gt;&gt;&gt; emulator.emulate_fast(0x1000, 0x1005)
&gt;&gt;&gt; emulator.read_bytes(0x2000, 1)
'0'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>start</code></b>
              –
              <div class="doc-md-description">
                <p>the start address to emulate</p>
              </div>
            </li>
            <li>
              <b><code>ends</code></b>
              –
              <div class="doc-md-description">
                <p>one or many end address</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def emulate_fast(self, start, ends):  # type: (Addr, Addr|list[Addr]) -&gt; None
    """Emulate from start to end address, using Ghidra for fast emulation.

    The main loop of this function is in Java, which makes it faster, but makes
    some features (like callbacks) impossible. This function stops on error,
    when PC reaches one of the ends, and will also call hooks.

    This method will set a breakpoint at the end address, and clear it after
    the emulation is done.

        &gt;&gt;&gt; emulator.write_bytes(0x2000, "1")
        &gt;&gt;&gt; emulator.emulate_fast(0x1000, 0x1005)
        &gt;&gt;&gt; emulator.read_bytes(0x2000, 1)
        '0'

    :param start: the start address to emulate
    :param ends: one or many end address"""
    self.set_pc(start)

    if not isinstance(ends, (list, tuple)):
        ends = [ends]

    for end in ends:
        self.add_breakpoint(end)

    is_breakpoint = self.__run_with_hooks()

    for end in ends:
        self.clear_breakpoint(end)

    if not is_breakpoint:
        err = self.raw.getLastError()
        raise RuntimeError("Error when running: {}".format(err))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.has_hook_at" class="doc doc-heading">
            <code class="highlight language-python">has_hook_at(address)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def has_hook_at(self, address):  # type: (Addr) -&gt; bool
    addr = resolve(address).getOffset()
    return addr in self._hooks</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.new" class="doc doc-heading">
            <code class="highlight language-python">new(start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2 ** 48)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate from start to end address, with callback for each executed address.</p>
<pre><code>&gt;&gt;&gt; Emulator.new("main", maxsteps=100)["EAX"]
128
</code></pre>
<p>This function is a convenience wrapper around emulate and can be always
replaced by three lines of code. The above is equivalent to:</p>
<pre><code>&gt;&gt;&gt; emu = Emulator()
&gt;&gt;&gt; emu.emulate("main", maxsteps=100)
&gt;&gt;&gt; emu["EAX"]
128
</code></pre>
<p>This function may be used for quickly doing one-off emulations.</p>
<p>See <code>emulate</code> documentation for info about this method parameters.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def new(
    start,
    ends=[],
    callback=lambda emu: None,
    stop_when=lambda emu: False,
    maxsteps=2**48,
):  # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -&gt; Emulator
    """Emulate from start to end address, with callback for each executed address.

        &gt;&gt;&gt; Emulator.new("main", maxsteps=100)["EAX"]
        128

    This function is a convenience wrapper around emulate and can be always
    replaced by three lines of code. The above is equivalent to:

        &gt;&gt;&gt; emu = Emulator()
        &gt;&gt;&gt; emu.emulate("main", maxsteps=100)
        &gt;&gt;&gt; emu["EAX"]
        128

    This function may be used for quickly doing one-off emulations.

    See `emulate` documentation for info about this method parameters."""
    emu = Emulator()
    emu.emulate(start, ends, callback, stop_when, maxsteps)
    return emu</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_bytes" class="doc doc-heading">
            <code class="highlight language-python">read_bytes(address, length)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read <code>length</code> bytes at <code>address</code> from the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
&gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
'1'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to read from</p>
              </div>
            </li>
            <li>
              <b><code>length</code></b>
              –
              <div class="doc-md-description">
                <p>the length to read</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_bytes(self, address, length):  # type: (Addr, int) -&gt; bytes
    """Read `length` bytes at `address` from the emulated program.

        &gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
        &gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
        '1'

    :param address: the address to read from
    :param length: the length to read"""
    bytelist = self.raw.readMemory(resolve(address), length)
    return _bytes_from_bytelist(bytelist)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_cstring" class="doc doc-heading">
            <code class="highlight language-python">read_cstring(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a null-terminated string from the emulated program.</p>
<p>This function reads bytes until a nullbyte is encountered.</p>
<pre><code>&gt;&gt;&gt; emu.read_cstring(0x1000)
'Hello, world!'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to start reading.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_cstring(self, address):  # type: (Addr) -&gt; str
    """Read a null-terminated string from the emulated program.

    This function reads bytes until a nullbyte is encountered.

        &gt;&gt;&gt; emu.read_cstring(0x1000)
        'Hello, world!'

    :param address: address from which to start reading."""
    addr = resolve(address)
    string = ""
    while True:
        c = self.read_u8(addr)
        if c == 0:
            break
        string += chr(c)
        addr = addr.add(1)
    return string</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_register" class="doc doc-heading">
            <code class="highlight language-python">read_register(reg)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read from the register of the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_register("eax", 1337)
&gt;&gt;&gt; emulator.read_register("eax")
1337
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>reg</code></b>
              –
              <div class="doc-md-description">
                <p>the register to read from.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_register(self, reg):  # type: (Reg) -&gt; int
    """Read from the register of the emulated program.

        &gt;&gt;&gt; emulator.write_register("eax", 1337)
        &gt;&gt;&gt; emulator.read_register("eax")
        1337

    :param reg: the register to read from."""
    return _python_int(self.raw.readRegister(reg))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_u16" class="doc doc-heading">
            <code class="highlight language-python">read_u16(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a 16bit unsigned integer from the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u16(0x1000, 123)
&gt;&gt;&gt; emulator.read_u16(0x1000)
123
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to read from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u16(self, address):  # type: (Addr) -&gt; int
    """Read a 16bit unsigned integer from the emulated program.

        &gt;&gt;&gt; emulator.write_u16(0x1000, 123)
        &gt;&gt;&gt; emulator.read_u16(0x1000)
        123

    :param address: the address to read from"""
    return from_bytes(self.read_bytes(address, 2))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_u32" class="doc doc-heading">
            <code class="highlight language-python">read_u32(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a 32bit unsigned integer from the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u32(0x1000, 123)
&gt;&gt;&gt; emulator.read_u32(0x1000)
123
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to read from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u32(self, address):  # type: (Addr) -&gt; int
    """Read a 32bit unsigned integer from the emulated program.

        &gt;&gt;&gt; emulator.write_u32(0x1000, 123)
        &gt;&gt;&gt; emulator.read_u32(0x1000)
        123

    :param address: the address to read from"""
    return from_bytes(self.read_bytes(address, 4))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_u64" class="doc doc-heading">
            <code class="highlight language-python">read_u64(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a 64bit unsigned integer from the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u64(0x1000, 123)
&gt;&gt;&gt; emulator.read_u64(0x1000)
123
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to read from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u64(self, address):  # type: (Addr) -&gt; int
    """Read a 64bit unsigned integer from the emulated program.

        &gt;&gt;&gt; emulator.write_u64(0x1000, 123)
        &gt;&gt;&gt; emulator.read_u64(0x1000)
        123

    :param address: the address to read from"""
    return from_bytes(self.read_bytes(address, 8))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_u8" class="doc doc-heading">
            <code class="highlight language-python">read_u8(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a byte from the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u8(0x1000, 13)
&gt;&gt;&gt; emulator.read_u8(0x1000)
13
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to read from</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u8(self, address):  # type: (Addr) -&gt; int
    """Read a byte from the emulated program.

        &gt;&gt;&gt; emulator.write_u8(0x1000, 13)
        &gt;&gt;&gt; emulator.read_u8(0x1000)
        13

    :param address: the address to read from"""
    return from_bytes(self.read_bytes(address, 1))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_unicode" class="doc doc-heading">
            <code class="highlight language-python">read_unicode(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read a null-terminated utf-16 string from the emulated program.</p>
<p>This function reads bytes until a null character is encountered.</p>
<pre><code>&gt;&gt;&gt; emu.read_unicode(0x1000)
'Hello, world!'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to start reading.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_unicode(self, address):  # type: (Addr) -&gt; str
    """Read a null-terminated utf-16 string from the emulated program.

    This function reads bytes until a null character is encountered.

        &gt;&gt;&gt; emu.read_unicode(0x1000)
        'Hello, world!'

    :param address: address from which to start reading."""
    addr = resolve(address)
    string = ""
    while True:
        c = self.read_u16(addr)
        if c == 0:
            break
        string += chr(c)
        addr = addr.add(2)
    return string</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.read_varnode" class="doc doc-heading">
            <code class="highlight language-python">read_varnode(varnode)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Read from the varnode from the emulated program.</p>
<p>This method can't read hash varnodes.</p>
<pre><code>&gt;&gt;&gt; fnc = Function("AddNumbers")
&gt;&gt;&gt; emu = Emulator()
&gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
&gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
&gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
&gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
4
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>varnode</code></b>
              –
              <div class="doc-md-description">
                <p>the varnode to read from.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_varnode(self, varnode):  # type: (Varnode) -&gt; int
    """Read from the varnode from the emulated program.

    This method can't read hash varnodes.

        &gt;&gt;&gt; fnc = Function("AddNumbers")
        &gt;&gt;&gt; emu = Emulator()
        &gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
        &gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
        &gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
        &gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
        4

    :param varnode: the varnode to read from."""
    varnode = Varnode(varnode)
    if varnode.is_constant:
        return varnode.offset
    elif varnode.is_address:
        rawnum = self.read_bytes(varnode.offset, varnode.size)
        return from_bytes(rawnum)
    elif varnode.is_unique:
        space = Program.current().getAddressFactory().getUniqueSpace()
        offset = space.getAddress(varnode.offset)
        rawnum = self.read_bytes(offset, varnode.size)
        return from_bytes(rawnum)
    elif varnode.is_stack:
        return self.raw.readStackValue(varnode.offset, varnode.size, False)
    elif varnode.is_register:
        language = Program.current().getLanguage()
        reg = language.getRegister(varnode.raw.getAddress(), varnode.size)
        return self.read_register(reg)
    raise RuntimeError("Unsupported varnode type")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.set_pc" class="doc doc-heading">
            <code class="highlight language-python">set_pc(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the program counter of the emulated program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_pc(self, address):  # type: (Addr) -&gt; None
    """Set the program counter of the emulated program."""
    pc = self.raw.getPCRegister()
    self.raw.writeRegister(pc, resolve(address).getOffset())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.set_sp" class="doc doc-heading">
            <code class="highlight language-python">set_sp(value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the current stack pointer register value.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>new stack pointer value.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_sp(self, value):  # type: (Addr) -&gt; None
    """Set the current stack pointer register value.

    :param value: new stack pointer value."""
    self.write_register(self.sp_register, resolve(value).getOffset())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.single_step" class="doc doc-heading">
            <code class="highlight language-python">single_step()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Do a single emulation step. This will step into calls.</p>
<p>Note: This method <em>will</em> call hooks.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>True if the emulation should be stopped, False otherwise.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_step(self):  # type: () -&gt; bool
    """Do a single emulation step. This will step into calls.

    Note: This method *will* call hooks.

    :return: True if the emulation should be stopped, False otherwise."""
    success = self.raw.step(getMonitor())
    if not success:
        err = self.raw.getLastError()
        raise RuntimeError("Error at {}: {}".format(self.pc, err))

    if self.pc in self._hooks:
        result = self._hooks[self.pc](self)
        return self.__handle_hook_result(result)
    if self.is_at_breakpoint:
        return True
    return False</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_bytes" class="doc doc-heading">
            <code class="highlight language-python">write_bytes(address, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write to the memory of the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
&gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
'1'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to write to</p>
              </div>
            </li>
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>the value to write</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_bytes(self, address, value):  # type: (Addr, bytes) -&gt; None
    """Write to the memory of the emulated program.

        &gt;&gt;&gt; emulator.write_bytes(0x1000, "1")
        &gt;&gt;&gt; emulator.read_bytes(0x1000, 1)
        '1'

    :param address: the address to write to
    :param value: the value to write"""
    self.raw.writeMemory(resolve(address), value)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_register" class="doc doc-heading">
            <code class="highlight language-python">write_register(reg, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write to the register of the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_register("eax", 1)
&gt;&gt;&gt; emulator.read_register("eax")
1
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>reg</code></b>
              –
              <div class="doc-md-description">
                <p>the register to write to</p>
              </div>
            </li>
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>the value to write</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_register(self, reg, value):  # type: (Reg, int) -&gt; None
    """Write to the register of the emulated program.

        &gt;&gt;&gt; emulator.write_register("eax", 1)
        &gt;&gt;&gt; emulator.read_register("eax")
        1

    :param reg: the register to write to
    :param value: the value to write"""
    self.raw.writeRegister(reg, value)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_u16" class="doc doc-heading">
            <code class="highlight language-python">write_u16(address, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write a 16bit unsigned integer to the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u16(0x1000, 13)
&gt;&gt;&gt; emulator.read_u16(0x1000)
13
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to write to</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_u16(self, address, value):  # type: (Addr, int) -&gt; None
    """Write a 16bit unsigned integer to the emulated program.

        &gt;&gt;&gt; emulator.write_u16(0x1000, 13)
        &gt;&gt;&gt; emulator.read_u16(0x1000)
        13

    :param address: the address to write to"""
    assert 0 &lt;= value &lt; 2**16, "value out of range"
    self.write_bytes(address, to_bytes(value, 2))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_u32" class="doc doc-heading">
            <code class="highlight language-python">write_u32(address, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write a 32bit unsigned integer to the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u32(0x1000, 13)
&gt;&gt;&gt; emulator.read_u32(0x1000)
13
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to write to</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_u32(self, address, value):  # type: (Addr, int) -&gt; None
    """Write a 32bit unsigned integer to the emulated program.

        &gt;&gt;&gt; emulator.write_u32(0x1000, 13)
        &gt;&gt;&gt; emulator.read_u32(0x1000)
        13

    :param address: the address to write to"""
    assert 0 &lt;= value &lt; 2**32, "value out of range"
    self.write_bytes(address, to_bytes(value, 4))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_u64" class="doc doc-heading">
            <code class="highlight language-python">write_u64(address, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write a 64bit unsigned integer to the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u64(0x1000, 13)
&gt;&gt;&gt; emulator.read_u64(0x1000)
13
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to write to</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_u64(self, address, value):  # type: (Addr, int) -&gt; None
    """Write a 64bit unsigned integer to the emulated program.

        &gt;&gt;&gt; emulator.write_u64(0x1000, 13)
        &gt;&gt;&gt; emulator.read_u64(0x1000)
        13

    :param address: the address to write to"""
    assert 0 &lt;= value &lt; 2**64, "value out of range"
    self.write_bytes(address, to_bytes(value, 8))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_u8" class="doc doc-heading">
            <code class="highlight language-python">write_u8(address, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write a byte to the emulated program.</p>
<pre><code>&gt;&gt;&gt; emulator.write_u8(0x1000, 13)
&gt;&gt;&gt; emulator.read_u8(0x1000)
13
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to write to</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_u8(self, address, value):  # type: (Addr, int) -&gt; None
    """Write a byte to the emulated program.

        &gt;&gt;&gt; emulator.write_u8(0x1000, 13)
        &gt;&gt;&gt; emulator.read_u8(0x1000)
        13

    :param address: the address to write to"""
    assert 0 &lt;= value &lt; 2**8, "value out of range"
    self.write_bytes(address, to_bytes(value, 1))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Emulator.write_varnode" class="doc doc-heading">
            <code class="highlight language-python">write_varnode(varnode, value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set a varnode value in the emulated context.</p>
<p>This method can't set hash and constant varnodes.</p>
<pre><code>&gt;&gt;&gt; fnc = Function("AddNumbers")
&gt;&gt;&gt; emu = Emulator()
&gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
&gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
&gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
&gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
4
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>varnode</code></b>
              –
              <div class="doc-md-description">
                <p>the varnode to read from.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_varnode(self, varnode, value):  # type: (Varnode, int) -&gt; None
    """Set a varnode value in the emulated context.

    This method can't set hash and constant varnodes.

        &gt;&gt;&gt; fnc = Function("AddNumbers")
        &gt;&gt;&gt; emu = Emulator()
        &gt;&gt;&gt; emu.write_varnode(fnc.parameters[0].varnode, 2)
        &gt;&gt;&gt; emu.write_varnode(fnc.parameters[1].varnode, 2)
        &gt;&gt;&gt; emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body)
        &gt;&gt;&gt; emu.read_varnode(func.return_variable.varnode)
        4

    :param varnode: the varnode to read from."""
    varnode = Varnode(varnode)
    if varnode.is_constant:
        raise ValueError("Can't set value of a constant varnodes")
    elif varnode.is_address:
        self.write_bytes(varnode.offset, to_bytes(value, varnode.size))
    elif varnode.is_unique:
        space = Program.current().getAddressFactory().getUniqueSpace()
        offset = space.getAddress(varnode.offset)
        self.write_bytes(offset, to_bytes(value, varnode.size))
    elif varnode.is_stack:
        self.raw.writeStackValue(varnode.offset, varnode.size, value)
    elif varnode.is_register:
        language = Program.current().getLanguage()
        reg = language.getRegister(varnode.raw.getAddress(), varnode.size)
        self.raw.writeRegister(reg, value)
    else:
        raise RuntimeError("Unsupported varnode type")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.FlowType" class="doc doc-heading">
            <code>FlowType</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra FlowType object</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class FlowType(GhidraWrapper):
    """Wraps a Ghidra FlowType object"""

    # TODO is class this necessary? This is just a subclass of RefType.

    @property
    def is_call(self):  # type: () -&gt; bool
        """Return True if this flow is a call."""
        return self.raw.isCall()

    @property
    def is_jump(self):  # type: () -&gt; bool
        """Return True if this flow is a jump."""
        return self.raw.isJump()

    @property
    def is_computed(self):  # type: () -&gt; bool
        """Return True if this flow is a computed jump."""
        return self.raw.isComputed()

    @property
    def is_conditional(self):  # type: () -&gt; bool
        """Return True if this flow is a conditional jump."""
        return self.raw.isConditional()

    @property
    def is_unconditional(self):  # type: () -&gt; bool
        """Return True if this flow is an unconditional jump."""
        return not self.is_conditional

    @property
    def is_terminal(self):  # type: () -&gt; bool
        """Return True if this flow is a terminator."""
        return self.raw.isTerminal()

    @property
    def has_fallthrough(self):  # type: () -&gt; bool
        """Return True if this flow has a fallthrough."""
        return self.raw.hasFallthrough()

    @property
    def is_override(self):  # type: () -&gt; bool
        """Return True if this flow is an override."""
        return self.raw.isOverride()</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.has_fallthrough" class="doc doc-heading">
            <code class="highlight language-python">has_fallthrough</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow has a fallthrough.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_call" class="doc doc-heading">
            <code class="highlight language-python">is_call</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is a call.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_computed" class="doc doc-heading">
            <code class="highlight language-python">is_computed</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is a computed jump.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_conditional" class="doc doc-heading">
            <code class="highlight language-python">is_conditional</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is a conditional jump.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_jump" class="doc doc-heading">
            <code class="highlight language-python">is_jump</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is a jump.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_override" class="doc doc-heading">
            <code class="highlight language-python">is_override</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is an override.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_terminal" class="doc doc-heading">
            <code class="highlight language-python">is_terminal</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is a terminator.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FlowType.is_unconditional" class="doc doc-heading">
            <code class="highlight language-python">is_unconditional</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this flow is an unconditional jump.</p>

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Function" class="doc doc-heading">
            <code>Function</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code>, <code><a class="autorefs autorefs-internal" title="BodyTrait (ghidralib.BodyTrait)" href="#ghidralib.BodyTrait">BodyTrait</a></code></p>


        <p>Wraps a Ghidra Function object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Function(GhidraWrapper, BodyTrait):
    """Wraps a Ghidra Function object."""

    UNDERLYING_CLASS = GhFunction

    @staticmethod
    def get(addr):  # type: (JavaObject|str|Addr) -&gt; Function|None
        """Return a function at the given address, or None if no function
        exists there."""
        if isinstance(addr, GhFunction):
            return Function(addr)
        if isinstance(addr, Function):
            return Function(addr.raw)
        addr = try_resolve(addr)
        if addr is None:
            return None
        raw = Program.current().getListing().getFunctionContaining(addr)
        if raw is None:
            return None
        return Function(raw)  # type: ignore

    @staticmethod
    def all():  # type: () -&gt; list[Function]
        """Return all functions in the current program."""
        raw_functions = Program.current().getFunctionManager().getFunctions(True)
        return [Function(f) for f in raw_functions]

    @staticmethod
    def create(address, name):  # type: (Addr, str) -&gt; Function
        """Create a new function at the given address with the given name."""
        func = createFunction(resolve(address), name)
        return Function(func)

    @property
    def return_type(self):  # type: () -&gt; DataType
        """Get the return type of this function."""
        return DataType(self.raw.getReturnType())

    @property
    def return_variable(self):  # type: () -&gt; Parameter
        """Get the variable representing a return value of this function."""
        return Parameter(self.raw.getReturn())

    @property
    def entrypoint(self):  # type: () -&gt; int
        """Get the entrypoint of this function."""
        return self.raw.getEntryPoint().getOffset()

    @property
    def address(self):  # type: () -&gt; int
        """Get the address of this function."""
        return self.entrypoint

    @property
    def exitpoints(self):  # type: () -&gt; list[int]
        """Get a list of exit points for the function.

        This will return a list of addresses of function terminators. For example,
        if a function has two RETs, this function will return their addresses."""
        return [i.address for i in self.instructions if i.flow_type.is_terminal]

    @property
    def name(self):  # type: () -&gt; str
        """Get the name of this function."""
        return self.raw.getName()

    @property
    def comment(self):  # type: () -&gt; str|None
        """Get the comment of this function, if any."""
        return self.raw.getComment()

    def set_comment(self, comment):  # type: (str|None) -&gt; None
        """Set the comment of this function."""
        self.raw.setComment(comment)

    @property
    def is_thunk(self):  # type: () -&gt; bool
        """Return True if this function is a thunk."""
        return self.raw.isThunk()

    @property
    def is_external(self):  # type: () -&gt; bool
        """Return True if this function is external."""
        return self.raw.isExternal()

    @property
    def repeatable_comment(self):  # type: () -&gt; str|None
        """Get the repeatable comment of this function, if any."""
        return self.raw.getRepeatableComment()

    def set_repeatable_comment(self, comment):  # type: (str|None) -&gt; None
        """Set the repeatable comment of this function."""
        self.raw.setRepeatableComment(comment)

    @property
    def parameters(self):  # type: () -&gt; list[Parameter]
        """Get the parameters of this function."""
        return [Parameter(raw) for raw in self.raw.getParameters()]

    def add_named_parameter(self, datatype, name):  # type: (DataT, str) -&gt; None
        """Add a parameter with a specified name to this function.

        Warning: adding a register parameter will switch the function into
        custom storage mode. Adding named parameters in custom storage is not
        implemented"""
        if self.raw.hasCustomVariableStorage():
            raise ValueError(
                "Sorry, adding named parameters is not implemented "
                "for functions with custom storage"
            )
        data = DataType(datatype)
        param = ParameterImpl(name, data.raw, 0, Program.current())
        self.raw.addParameter(param, SourceType.USER_DEFINED)

    def add_register_parameter(
        self, datatype, register, name
    ):  # type: (DataT, Reg, str) -&gt; None
        """Add a parameter stored in a specified register to this function.

        Warning: adding a register parameter will switch the function into
        custom storage mode. Adding named parameters in custom storage will
        not work anymore"""
        if not self.raw.hasCustomVariableStorage():
            self.raw.setCustomVariableStorage(True)
        reg = Register(register)
        data = DataType(datatype)
        param = ParameterImpl(name, data.raw, reg.raw, Program.current())
        self.raw.addParameter(param, SourceType.USER_DEFINED)

    def fixup_body(self):  # type: () -&gt; bool
        """Fixup the function body: follow control flow and add thunks."""
        return CreateFunctionCmd.fixupFunctionBody(
            Program.current(), self.raw, getMonitor()
        )

    @property
    def local_variables(self):  # type: () -&gt; list[Variable]
        """Get the local variables of this function."""
        return [Variable(raw) for raw in self.raw.getLocalVariables()]

    @property
    def variables(self):  # type: () -&gt; list[Variable]
        """Get all variables defined in this function."""
        return [Variable(raw) for raw in self.raw.getAllVariables()]

    @property
    def varnodes(self):  # type: () -&gt; list[Varnode]
        """Get all varnodes associated with a variable in this function."""
        varnodes = []
        for var in self.variables:
            varnodes.extend(var.varnodes)
        return varnodes

    @property
    def high_variables(self):  # type: () -&gt; list[HighVariable]
        """Get all variables defined in this function.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.high_function.variables

    @property
    def stack(self):  # type: () -&gt; list[Variable]
        """Get the defined stack variables (both parameters and locals)."""
        raw_vars = self.raw.getStackFrame().getStackVariables()
        return [Variable(raw) for raw in raw_vars]

    def rename(self, name):  # type: (str) -&gt; None
        """Change the name of this function."""
        self.raw.setName(name, SourceType.USER_DEFINED)

    @property
    def instructions(self):  # type: () -&gt; list[Instruction]
        """Get the assembler instructions for this function."""
        listing = Program.current().getListing()
        raw_instructions = listing.getInstructions(self.raw.getBody(), True)
        return [Instruction(raw) for raw in raw_instructions]

    @property
    def xrefs(self):  # type: () -&gt; list[Reference]
        """Get the references to this function."""
        raw_refs = getReferencesTo(resolve(self.entrypoint))
        return [Reference(raw) for raw in raw_refs]

    xrefs_to = xrefs

    @property
    def xref_addrs(self):  # type: () -&gt; list[int]
        """Get the source addresses of references to this function."""
        return [xref.from_address for xref in self.xrefs]

    @property
    def callers(self):  # type: () -&gt; list[Function]
        """Get all functions that call this function."""
        return [
            Function(raw) for raw in self.raw.getCallingFunctions(TaskMonitor.DUMMY)
        ]

    @property
    def called(self):  # type: () -&gt; list[Function]
        """Get all functions that are called by this function."""
        return [Function(raw) for raw in self.raw.getCalledFunctions(TaskMonitor.DUMMY)]

    @property
    def fixup(self):  # type: () -&gt; str|None
        """Get the fixup of this function."""
        return self.raw.getCallFixup()

    @fixup.setter
    def fixup(self, fixup):  # type: (str|None) -&gt; None
        """Set the fixup of this function.

        :param fixup: The new fixup to set."""
        self.raw.setCallFixup(fixup)

    @property
    def calls(self):  # type: () -&gt; list[FunctionCall]
        """Get all function calls to this function."""
        calls = []
        for ref in self.xrefs:
            if ref.is_call:
                calls.append(FunctionCall(self, ref.from_address))
        return calls

    @property
    def basicblocks(self):  # type: () -&gt; list[BasicBlock]
        """Get the basic blocks of this function."""
        block_model = BasicBlockModel(Program.current())
        blocks = block_model.getCodeBlocksContaining(
            self.raw.getBody(), TaskMonitor.DUMMY
        )
        return [BasicBlock(block) for block in blocks]

    def _decompile(self, simplify="decompile"):  # type: (str) -&gt; JavaObject
        """Decompile this function (internal helper)."""
        decompiler = DecompInterface()
        decompiler.openProgram(Program.current())
        decompiler.setSimplificationStyle(simplify)
        decompiled = decompiler.decompileFunction(self.raw, 5, TaskMonitor.DUMMY)
        decompiler.closeProgram()
        decompiler.dispose()
        if decompiled is None:
            raise RuntimeError("Failed to decompile function {}".format(self.name))
        return decompiled

    def decompile(self):  # type: () -&gt; str
        """Get decompiled C code for the function as string."""
        decompiled = self._decompile()
        return decompiled.getDecompiledFunction().getC()

    @property
    def clang_tokens(self):  # type: () -&gt; ClangTokenGroup
        """Get clang tokens for the decompiled function.

        This returns a ClangTokenGroup object. TODO: wrap the return value."""
        decompiled = self._decompile()
        return ClangTokenGroup(decompiled.getCCodeMarkup())

    @property
    def high_function(self):  # type: () -&gt; HighFunction
        """Decompile this function, and return a high-level function.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.get_high_function()

    def get_high_function(self, simplify="decompile"):  # type: (str) -&gt; HighFunction
        """Decompile this function, and return a high-level function.

        Warning: this method needs to decompile the function, and is therefore slow.

        :simplify: the simplification style to use.
        See DecompilerInterface.setSimplificationStyle."""
        decompiled = self._decompile(simplify)
        return HighFunction(decompiled.getHighFunction())

    def get_high_pcode(self, simplify="decompile"):  # type: (str) -&gt; list[PcodeOp]
        """Decompile this function, and return its high-level Pcode.

        Warning: this method needs to decompile the function, and is therefore slow.

        :simplify: the simplification style to use.
        See DecompilerInterface.setSimplificationStyle."""
        return self.get_high_function(simplify).pcode

    @property
    def pcode_tree(self):  # type: () -&gt; BlockGraph
        """Get an AST-like representation of the function's Pcode.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.get_high_function().pcode_tree

    @property
    def pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get the (low-level) Pcode for this function."""
        result = []
        for block in self.basicblocks:
            result.extend(block.pcode)
        return result

    @property
    def high_pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get the (high-level) Pcode for this function.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.get_high_pcode()

    @property
    def high_basicblocks(self):  # type: () -&gt; list[PcodeBlock]
        """Get the (high-level) Pcode basic blocks for this function.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.high_function.basicblocks

    def get_high_pcode_at(self, address):  # type: (Addr) -&gt; list[PcodeOp]
        """Get the high-level Pcode at the given address.

        Do not use this function in a loop! Better decompile the whole function first.

        Warning: this method needs to decompile the function, and is therefore slow.

        :param address: the address to get the Pcode for."""
        return self.get_high_function().get_pcode_at(address)

    @property
    def high_symbols(self):  # type: () -&gt; list[HighSymbol]
        """Get the high-level symbols for this function.

        Warning: this method needs to decompile the function, and is therefore slow."""
        return self.get_high_function().symbols

    @property
    def primary_symbols(self):  # type: () -&gt; list[Symbol]
        """Get the primary symbols for this function."""
        symtable = Program.current().getSymbolTable()
        syms = symtable.getPrimarySymbolIterator(self.raw.getBody(), True)
        return [Symbol(s) for s in syms]

    @property
    def symbols(self):  # type: () -&gt; list[Symbol]
        """Get the symbols for this function.

        Unfortunately, the implementation of this function has to iterate over
        all function addresses (because SymbolTable doesn't export the right method),
        so it may be quite slow when called frequently. Consider using primary_symbols
        if adequate."""
        body = self.raw.getBody()
        symbols = []
        symtable = Program.current().getSymbolTable()
        for rng in body:
            for addr in rng:
                symbols.extend(symtable.getSymbols(addr))
        return [Symbol(raw) for raw in symbols]

    @property
    def body(self):  # type: () -&gt; AddressSet
        """Get the set of addresses of this function."""
        return AddressSet(self.raw.getBody())

    @property
    def control_flow(self):  # type: () -&gt; Graph[BasicBlock]
        """Get the control flow graph of this function.

        In other words, get a graph that represents how the control flow
        can move between basic blocks in this function."""
        return Graph.construct(self.basicblocks, lambda v: v.destinations)

    def emulate(self, *args, **kwargs):  # type: (int, Emulator) -&gt; Emulator
        """Emulate the function call with given args, and return final emulation state.

        The arguments are passed using a calling convention defined in Ghidra. If
        you want to use a different calling convention, or do additional setup,
        you have to use the Emulator class directly.

        You can pass your own emulator using the `emulator` kwarg. You can use this
        to do a pre-call setup (for example, write string parameters to memory). But
        don't use this to change call parameters, as they are always overwriten.

            &gt;&gt;&gt; fnc = Function("ResolveName")
            &gt;&gt;&gt; emu = fnc.emulate(1379010213)
            &gt;&gt;&gt; emu.read_unicode(emu["eax"])
            "HKEY_CLASSES_ROOT"

        :param args: The arguments to pass to the function.
        :param kwargs: pass `emulator` kwarg to use the provided emulator
          (default: create a new one)."""
        if "emulator" in kwargs:
            # Jython doesn't support keyword arguments after args, apparently
            emulator = kwargs["emulator"]
        else:
            emulator = Emulator()

        if len(args) != len(self.raw.getParameters()):
            raise ValueError(
                "Wrong number of arguments for {} - got {} expected {}".format(
                    self.name, len(args), len(self.raw.getParameters())
                )
            )

        for param, value in zip(self.parameters, args):
            emulator.write_varnode(param.varnode, value)

        emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body)
        return emulator

    def emulate_simple(self, *args, **kwargs):  # type: (int, Emulator) -&gt; int
        """Emulate the function call with given args, and return the return value.

        The arguments are passed using a calling convention defined in Ghidra. If
        you want to use a different calling convention, or do additional setup,
        you have to use the Emulator class directly.

        You can pass your own emulator using the `emulator` kwarg. You can use this
        to do a pre-call setup (for example, write string parameters to memory). But
        don't use this to change call parameters, as they are always overwriten.

        Note: the name is not great, but I can't think of a better name that is
        not also very long.

            &gt;&gt;&gt; fnc = Function("CustomHash")
            &gt;&gt;&gt; fnc.emulate_simple("HKEY_CLASSES_ROOT")
            1379010213

        :param args: The arguments to pass to the function.
        :param kwargs: pass `emulator` kwarg to use the provided emulator
          (default: create a new one)."""
        context = self.emulate(*args, **kwargs)
        return context.read_varnode(self.return_variable.varnode)

    def symbolic_context(self):  # type: () -&gt; SymbolicPropogator
        """Returns a SymbolicPropogator instance for this function.

        This can be used to get a known values of registers at various addresses.

            &gt;&gt;&gt; fnc = Function(0x004061EC)
            &gt;&gt;&gt; ctx = fnc.symbolic_context()
            &gt;&gt;&gt; print(ctx.register(0x004061fb, "eax"))

        TODO: This method should implement a hack described in
        https://github.com/NationalSecurityAgency/ghidra/issues/3581
        because built-in Ghidra symbolic propagator doesn't support memory accesses.

        :return: a SymbolicPropogator instance with this function context."""
        propagator = SymbolicPropogator.create()
        evaluator = ConstantPropagationContextEvaluator(getMonitor())
        propagator.flow_constants(self.entrypoint, self.body, evaluator)
        return propagator</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.UNDERLYING_CLASS" class="doc doc-heading">
            <code class="highlight language-python">UNDERLYING_CLASS = GhFunction</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.basicblocks" class="doc doc-heading">
            <code class="highlight language-python">basicblocks</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the basic blocks of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the set of addresses of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.called" class="doc doc-heading">
            <code class="highlight language-python">called</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all functions that are called by this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.callers" class="doc doc-heading">
            <code class="highlight language-python">callers</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all functions that call this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.calls" class="doc doc-heading">
            <code class="highlight language-python">calls</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all function calls to this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.clang_tokens" class="doc doc-heading">
            <code class="highlight language-python">clang_tokens</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get clang tokens for the decompiled function.</p>
<p>This returns a ClangTokenGroup object. TODO: wrap the return value.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.comment" class="doc doc-heading">
            <code class="highlight language-python">comment</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the comment of this function, if any.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.control_flow" class="doc doc-heading">
            <code class="highlight language-python">control_flow</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the control flow graph of this function.</p>
<p>In other words, get a graph that represents how the control flow
can move between basic blocks in this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.entrypoint" class="doc doc-heading">
            <code class="highlight language-python">entrypoint</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the entrypoint of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.exitpoints" class="doc doc-heading">
            <code class="highlight language-python">exitpoints</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of exit points for the function.</p>
<p>This will return a list of addresses of function terminators. For example,
if a function has two RETs, this function will return their addresses.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.fixup" class="doc doc-heading">
            <code class="highlight language-python">fixup</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the fixup of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.high_basicblocks" class="doc doc-heading">
            <code class="highlight language-python">high_basicblocks</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the (high-level) Pcode basic blocks for this function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.high_function" class="doc doc-heading">
            <code class="highlight language-python">high_function</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Decompile this function, and return a high-level function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.high_pcode" class="doc doc-heading">
            <code class="highlight language-python">high_pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the (high-level) Pcode for this function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.high_symbols" class="doc doc-heading">
            <code class="highlight language-python">high_symbols</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the high-level symbols for this function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.high_variables" class="doc doc-heading">
            <code class="highlight language-python">high_variables</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all variables defined in this function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.instructions" class="doc doc-heading">
            <code class="highlight language-python">instructions</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the assembler instructions for this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.is_external" class="doc doc-heading">
            <code class="highlight language-python">is_external</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this function is external.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.is_thunk" class="doc doc-heading">
            <code class="highlight language-python">is_thunk</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this function is a thunk.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.local_variables" class="doc doc-heading">
            <code class="highlight language-python">local_variables</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the local variables of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the name of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.parameters" class="doc doc-heading">
            <code class="highlight language-python">parameters</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the parameters of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.pcode" class="doc doc-heading">
            <code class="highlight language-python">pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the (low-level) Pcode for this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.pcode_tree" class="doc doc-heading">
            <code class="highlight language-python">pcode_tree</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get an AST-like representation of the function's Pcode.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.primary_symbols" class="doc doc-heading">
            <code class="highlight language-python">primary_symbols</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the primary symbols for this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.repeatable_comment" class="doc doc-heading">
            <code class="highlight language-python">repeatable_comment</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the repeatable comment of this function, if any.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.return_type" class="doc doc-heading">
            <code class="highlight language-python">return_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the return type of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.return_variable" class="doc doc-heading">
            <code class="highlight language-python">return_variable</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the variable representing a return value of this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.stack" class="doc doc-heading">
            <code class="highlight language-python">stack</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the defined stack variables (both parameters and locals).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.symbols" class="doc doc-heading">
            <code class="highlight language-python">symbols</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the symbols for this function.</p>
<p>Unfortunately, the implementation of this function has to iterate over
all function addresses (because SymbolTable doesn't export the right method),
so it may be quite slow when called frequently. Consider using primary_symbols
if adequate.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.variables" class="doc doc-heading">
            <code class="highlight language-python">variables</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all variables defined in this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.varnodes" class="doc doc-heading">
            <code class="highlight language-python">varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all varnodes associated with a variable in this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.xref_addrs" class="doc doc-heading">
            <code class="highlight language-python">xref_addrs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the source addresses of references to this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.xrefs" class="doc doc-heading">
            <code class="highlight language-python">xrefs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the references to this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Function.xrefs_to" class="doc doc-heading">
            <code class="highlight language-python">xrefs_to = xrefs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.add_named_parameter" class="doc doc-heading">
            <code class="highlight language-python">add_named_parameter(datatype, name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Add a parameter with a specified name to this function.</p>
<p>Warning: adding a register parameter will switch the function into
custom storage mode. Adding named parameters in custom storage is not
implemented</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_named_parameter(self, datatype, name):  # type: (DataT, str) -&gt; None
    """Add a parameter with a specified name to this function.

    Warning: adding a register parameter will switch the function into
    custom storage mode. Adding named parameters in custom storage is not
    implemented"""
    if self.raw.hasCustomVariableStorage():
        raise ValueError(
            "Sorry, adding named parameters is not implemented "
            "for functions with custom storage"
        )
    data = DataType(datatype)
    param = ParameterImpl(name, data.raw, 0, Program.current())
    self.raw.addParameter(param, SourceType.USER_DEFINED)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.add_register_parameter" class="doc doc-heading">
            <code class="highlight language-python">add_register_parameter(datatype, register, name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Add a parameter stored in a specified register to this function.</p>
<p>Warning: adding a register parameter will switch the function into
custom storage mode. Adding named parameters in custom storage will
not work anymore</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_register_parameter(
    self, datatype, register, name
):  # type: (DataT, Reg, str) -&gt; None
    """Add a parameter stored in a specified register to this function.

    Warning: adding a register parameter will switch the function into
    custom storage mode. Adding named parameters in custom storage will
    not work anymore"""
    if not self.raw.hasCustomVariableStorage():
        self.raw.setCustomVariableStorage(True)
    reg = Register(register)
    data = DataType(datatype)
    param = ParameterImpl(name, data.raw, reg.raw, Program.current())
    self.raw.addParameter(param, SourceType.USER_DEFINED)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.all" class="doc doc-heading">
            <code class="highlight language-python">all()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return all functions in the current program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all():  # type: () -&gt; list[Function]
    """Return all functions in the current program."""
    raw_functions = Program.current().getFunctionManager().getFunctions(True)
    return [Function(f) for f in raw_functions]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.create" class="doc doc-heading">
            <code class="highlight language-python">create(address, name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new function at the given address with the given name.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create(address, name):  # type: (Addr, str) -&gt; Function
    """Create a new function at the given address with the given name."""
    func = createFunction(resolve(address), name)
    return Function(func)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.decompile" class="doc doc-heading">
            <code class="highlight language-python">decompile()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get decompiled C code for the function as string.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def decompile(self):  # type: () -&gt; str
    """Get decompiled C code for the function as string."""
    decompiled = self._decompile()
    return decompiled.getDecompiledFunction().getC()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.emulate" class="doc doc-heading">
            <code class="highlight language-python">emulate(*args, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate the function call with given args, and return final emulation state.</p>
<p>The arguments are passed using a calling convention defined in Ghidra. If
you want to use a different calling convention, or do additional setup,
you have to use the Emulator class directly.</p>
<p>You can pass your own emulator using the <code>emulator</code> kwarg. You can use this
to do a pre-call setup (for example, write string parameters to memory). But
don't use this to change call parameters, as they are always overwriten.</p>
<pre><code>&gt;&gt;&gt; fnc = Function("ResolveName")
&gt;&gt;&gt; emu = fnc.emulate(1379010213)
&gt;&gt;&gt; emu.read_unicode(emu["eax"])
"HKEY_CLASSES_ROOT"
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>args</code></b>
              –
              <div class="doc-md-description">
                <p>The arguments to pass to the function.</p>
              </div>
            </li>
            <li>
              <b><code>kwargs</code></b>
              –
              <div class="doc-md-description">
                <p>pass <code>emulator</code> kwarg to use the provided emulator (default: create a new one).</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def emulate(self, *args, **kwargs):  # type: (int, Emulator) -&gt; Emulator
    """Emulate the function call with given args, and return final emulation state.

    The arguments are passed using a calling convention defined in Ghidra. If
    you want to use a different calling convention, or do additional setup,
    you have to use the Emulator class directly.

    You can pass your own emulator using the `emulator` kwarg. You can use this
    to do a pre-call setup (for example, write string parameters to memory). But
    don't use this to change call parameters, as they are always overwriten.

        &gt;&gt;&gt; fnc = Function("ResolveName")
        &gt;&gt;&gt; emu = fnc.emulate(1379010213)
        &gt;&gt;&gt; emu.read_unicode(emu["eax"])
        "HKEY_CLASSES_ROOT"

    :param args: The arguments to pass to the function.
    :param kwargs: pass `emulator` kwarg to use the provided emulator
      (default: create a new one)."""
    if "emulator" in kwargs:
        # Jython doesn't support keyword arguments after args, apparently
        emulator = kwargs["emulator"]
    else:
        emulator = Emulator()

    if len(args) != len(self.raw.getParameters()):
        raise ValueError(
            "Wrong number of arguments for {} - got {} expected {}".format(
                self.name, len(args), len(self.raw.getParameters())
            )
        )

    for param, value in zip(self.parameters, args):
        emulator.write_varnode(param.varnode, value)

    emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body)
    return emulator</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.emulate_simple" class="doc doc-heading">
            <code class="highlight language-python">emulate_simple(*args, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate the function call with given args, and return the return value.</p>
<p>The arguments are passed using a calling convention defined in Ghidra. If
you want to use a different calling convention, or do additional setup,
you have to use the Emulator class directly.</p>
<p>You can pass your own emulator using the <code>emulator</code> kwarg. You can use this
to do a pre-call setup (for example, write string parameters to memory). But
don't use this to change call parameters, as they are always overwriten.</p>
<p>Note: the name is not great, but I can't think of a better name that is
not also very long.</p>
<pre><code>&gt;&gt;&gt; fnc = Function("CustomHash")
&gt;&gt;&gt; fnc.emulate_simple("HKEY_CLASSES_ROOT")
1379010213
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>args</code></b>
              –
              <div class="doc-md-description">
                <p>The arguments to pass to the function.</p>
              </div>
            </li>
            <li>
              <b><code>kwargs</code></b>
              –
              <div class="doc-md-description">
                <p>pass <code>emulator</code> kwarg to use the provided emulator (default: create a new one).</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def emulate_simple(self, *args, **kwargs):  # type: (int, Emulator) -&gt; int
    """Emulate the function call with given args, and return the return value.

    The arguments are passed using a calling convention defined in Ghidra. If
    you want to use a different calling convention, or do additional setup,
    you have to use the Emulator class directly.

    You can pass your own emulator using the `emulator` kwarg. You can use this
    to do a pre-call setup (for example, write string parameters to memory). But
    don't use this to change call parameters, as they are always overwriten.

    Note: the name is not great, but I can't think of a better name that is
    not also very long.

        &gt;&gt;&gt; fnc = Function("CustomHash")
        &gt;&gt;&gt; fnc.emulate_simple("HKEY_CLASSES_ROOT")
        1379010213

    :param args: The arguments to pass to the function.
    :param kwargs: pass `emulator` kwarg to use the provided emulator
      (default: create a new one)."""
    context = self.emulate(*args, **kwargs)
    return context.read_varnode(self.return_variable.varnode)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.fixup_body" class="doc doc-heading">
            <code class="highlight language-python">fixup_body()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Fixup the function body: follow control flow and add thunks.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def fixup_body(self):  # type: () -&gt; bool
    """Fixup the function body: follow control flow and add thunks."""
    return CreateFunctionCmd.fixupFunctionBody(
        Program.current(), self.raw, getMonitor()
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.get" class="doc doc-heading">
            <code class="highlight language-python">get(addr)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return a function at the given address, or None if no function
exists there.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(addr):  # type: (JavaObject|str|Addr) -&gt; Function|None
    """Return a function at the given address, or None if no function
    exists there."""
    if isinstance(addr, GhFunction):
        return Function(addr)
    if isinstance(addr, Function):
        return Function(addr.raw)
    addr = try_resolve(addr)
    if addr is None:
        return None
    raw = Program.current().getListing().getFunctionContaining(addr)
    if raw is None:
        return None
    return Function(raw)  # type: ignore</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.get_high_function" class="doc doc-heading">
            <code class="highlight language-python">get_high_function(simplify='decompile')</code>

</h3>


    <div class="doc doc-contents ">

        <p>Decompile this function, and return a high-level function.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>
<p>:simplify: the simplification style to use.
See DecompilerInterface.setSimplificationStyle.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_high_function(self, simplify="decompile"):  # type: (str) -&gt; HighFunction
    """Decompile this function, and return a high-level function.

    Warning: this method needs to decompile the function, and is therefore slow.

    :simplify: the simplification style to use.
    See DecompilerInterface.setSimplificationStyle."""
    decompiled = self._decompile(simplify)
    return HighFunction(decompiled.getHighFunction())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.get_high_pcode" class="doc doc-heading">
            <code class="highlight language-python">get_high_pcode(simplify='decompile')</code>

</h3>


    <div class="doc doc-contents ">

        <p>Decompile this function, and return its high-level Pcode.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>
<p>:simplify: the simplification style to use.
See DecompilerInterface.setSimplificationStyle.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_high_pcode(self, simplify="decompile"):  # type: (str) -&gt; list[PcodeOp]
    """Decompile this function, and return its high-level Pcode.

    Warning: this method needs to decompile the function, and is therefore slow.

    :simplify: the simplification style to use.
    See DecompilerInterface.setSimplificationStyle."""
    return self.get_high_function(simplify).pcode</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.get_high_pcode_at" class="doc doc-heading">
            <code class="highlight language-python">get_high_pcode_at(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the high-level Pcode at the given address.</p>
<p>Do not use this function in a loop! Better decompile the whole function first.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to get the Pcode for.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_high_pcode_at(self, address):  # type: (Addr) -&gt; list[PcodeOp]
    """Get the high-level Pcode at the given address.

    Do not use this function in a loop! Better decompile the whole function first.

    Warning: this method needs to decompile the function, and is therefore slow.

    :param address: the address to get the Pcode for."""
    return self.get_high_function().get_pcode_at(address)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Change the name of this function.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(self, name):  # type: (str) -&gt; None
    """Change the name of this function."""
    self.raw.setName(name, SourceType.USER_DEFINED)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.set_comment" class="doc doc-heading">
            <code class="highlight language-python">set_comment(comment)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the comment of this function.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_comment(self, comment):  # type: (str|None) -&gt; None
    """Set the comment of this function."""
    self.raw.setComment(comment)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.set_repeatable_comment" class="doc doc-heading">
            <code class="highlight language-python">set_repeatable_comment(comment)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the repeatable comment of this function.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_repeatable_comment(self, comment):  # type: (str|None) -&gt; None
    """Set the repeatable comment of this function."""
    self.raw.setRepeatableComment(comment)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Function.symbolic_context" class="doc doc-heading">
            <code class="highlight language-python">symbolic_context()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a SymbolicPropogator instance for this function.</p>
<p>This can be used to get a known values of registers at various addresses.</p>
<pre><code>&gt;&gt;&gt; fnc = Function(0x004061EC)
&gt;&gt;&gt; ctx = fnc.symbolic_context()
&gt;&gt;&gt; print(ctx.register(0x004061fb, "eax"))
</code></pre>
<p>TODO: This method should implement a hack described in
https://github.com/NationalSecurityAgency/ghidra/issues/3581
because built-in Ghidra symbolic propagator doesn't support memory accesses.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>a SymbolicPropogator instance with this function context.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def symbolic_context(self):  # type: () -&gt; SymbolicPropogator
    """Returns a SymbolicPropogator instance for this function.

    This can be used to get a known values of registers at various addresses.

        &gt;&gt;&gt; fnc = Function(0x004061EC)
        &gt;&gt;&gt; ctx = fnc.symbolic_context()
        &gt;&gt;&gt; print(ctx.register(0x004061fb, "eax"))

    TODO: This method should implement a hack described in
    https://github.com/NationalSecurityAgency/ghidra/issues/3581
    because built-in Ghidra symbolic propagator doesn't support memory accesses.

    :return: a SymbolicPropogator instance with this function context."""
    propagator = SymbolicPropogator.create()
    evaluator = ConstantPropagationContextEvaluator(getMonitor())
    propagator.flow_constants(self.entrypoint, self.body, evaluator)
    return propagator</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.FunctionCall" class="doc doc-heading">
            <code>FunctionCall</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BodyTrait (ghidralib.BodyTrait)" href="#ghidralib.BodyTrait">BodyTrait</a></code></p>


        <p>Represents a function call at a given location in the program.</p>
<p>Can be used to get the function being called and the parameters passed to it.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class FunctionCall(BodyTrait):
    """Represents a function call at a given location in the program.

    Can be used to get the function being called and the parameters passed to it."""

    def __init__(self, function, address):  # type: (Function, Addr) -&gt; None
        self.called_function = function
        self._address = resolve(address)

    @property
    def address(self):  # type: () -&gt; int
        return self._address.getOffset()

    @property
    def caller(self):  # type: () -&gt; Function|None
        """Get the function where this function call takes place."""
        return Function.get(self._address)

    calling_function = caller

    @property
    def instruction(self):  # type: () -&gt; Instruction
        return Instruction(self._address)

    @property
    def callee(self):  # type: () -&gt; Function
        """Get the function being called."""
        return self.called_function

    def infer_context(self):  # type: () -&gt; Emulator
        """Emulate the code before this function call, and return the state.

        The goal of this function is to recover the state of the CPU
        before the function call, as well as possible. This will work well when
        parameters are constants written just before the call, for example:

            mov eax, 30
            mov ebx, DAT_encrypted_string
            call decrypt_string

        Then recovering eax is as simple as call.infer_context()["eax"]."""
        basicblock = BasicBlock(self._address)
        return Emulator.new(basicblock.start_address, self._address)

    @property
    def high_pcodeop(self):  # type: () -&gt; PcodeOp|None
        """Get the high-level PcodeOp for this function call.

        High-level Pcode `call` ops have the parameters resolved, so we
        can use them to read them when analysing Pcode.

        Warning: this works on decompiled functions only, so it will work
          if the call is done from a region not recognised as function.
        Warning: this method needs to decompile the function, and is therefore slow."""
        for pcode_op in PcodeOp.get_high_pcode_at(self._address):
            if pcode_op.opcode != pcode_op.CALL:
                continue
            return pcode_op

        raise RuntimeError("No CALL at {}".format(self.address))

    @property
    def high_varnodes(self):  # type: () -&gt; list[Varnode]
        """Get a list of the arguments passed to this function call, as high varnodes.

        In other words, decompile the function, and return the varnodes associated with
        the function parameters, as seen by Ghidra decompiler.

        Warning: this works on decompiled functions only, so it will work
          if the call is done from a region not recognised as function.
        Warning: this method needs to decompile the function, and is therefore slow."""
        op = self.high_pcodeop
        if not op:
            return []
        return op.inputs[1:]  # skip function addr

    def infer_args(self):  # type: () -&gt; list[int|None]
        """Get a list of the arguments passed to this function call, as integers.

        This method tries to get arguments of this function, as seen by Ghidra
        decompiler. A limited symbolic execution is performed to resolve the pointers.
        If it's not possible to get an argument, None is stored in its place.

        Warning: this works on decompiled functions only, so it will work
          if the call is done from a region not recognised as function.
        Warning: this method needs to decompile the function, and is therefore slow.
        """
        args = []
        for varnode in self.high_varnodes:
            if varnode.value is not None:
                args.append(varnode.value)
            else:
                args.append(None)
        return args

    @property
    def body(self):
        return self.instruction.body</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.called_function" class="doc doc-heading">
            <code class="highlight language-python">called_function = function</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.callee" class="doc doc-heading">
            <code class="highlight language-python">callee</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the function being called.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.caller" class="doc doc-heading">
            <code class="highlight language-python">caller</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the function where this function call takes place.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.calling_function" class="doc doc-heading">
            <code class="highlight language-python">calling_function = caller</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.high_pcodeop" class="doc doc-heading">
            <code class="highlight language-python">high_pcodeop</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the high-level PcodeOp for this function call.</p>
<p>High-level Pcode <code>call</code> ops have the parameters resolved, so we
can use them to read them when analysing Pcode.</p>
<p>Warning: this works on decompiled functions only, so it will work
  if the call is done from a region not recognised as function.
Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.high_varnodes" class="doc doc-heading">
            <code class="highlight language-python">high_varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of the arguments passed to this function call, as high varnodes.</p>
<p>In other words, decompile the function, and return the varnodes associated with
the function parameters, as seen by Ghidra decompiler.</p>
<p>Warning: this works on decompiled functions only, so it will work
  if the call is done from a region not recognised as function.
Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.FunctionCall.instruction" class="doc doc-heading">
            <code class="highlight language-python">instruction</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.FunctionCall.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(function, address)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, function, address):  # type: (Function, Addr) -&gt; None
    self.called_function = function
    self._address = resolve(address)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.FunctionCall.infer_args" class="doc doc-heading">
            <code class="highlight language-python">infer_args()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of the arguments passed to this function call, as integers.</p>
<p>This method tries to get arguments of this function, as seen by Ghidra
decompiler. A limited symbolic execution is performed to resolve the pointers.
If it's not possible to get an argument, None is stored in its place.</p>
<p>Warning: this works on decompiled functions only, so it will work
  if the call is done from a region not recognised as function.
Warning: this method needs to decompile the function, and is therefore slow.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def infer_args(self):  # type: () -&gt; list[int|None]
    """Get a list of the arguments passed to this function call, as integers.

    This method tries to get arguments of this function, as seen by Ghidra
    decompiler. A limited symbolic execution is performed to resolve the pointers.
    If it's not possible to get an argument, None is stored in its place.

    Warning: this works on decompiled functions only, so it will work
      if the call is done from a region not recognised as function.
    Warning: this method needs to decompile the function, and is therefore slow.
    """
    args = []
    for varnode in self.high_varnodes:
        if varnode.value is not None:
            args.append(varnode.value)
        else:
            args.append(None)
    return args</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.FunctionCall.infer_context" class="doc doc-heading">
            <code class="highlight language-python">infer_context()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Emulate the code before this function call, and return the state.</p>
<p>The goal of this function is to recover the state of the CPU
before the function call, as well as possible. This will work well when
parameters are constants written just before the call, for example:</p>
<pre><code>mov eax, 30
mov ebx, DAT_encrypted_string
call decrypt_string
</code></pre>
<p>Then recovering eax is as simple as call.infer_context()["eax"].</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def infer_context(self):  # type: () -&gt; Emulator
    """Emulate the code before this function call, and return the state.

    The goal of this function is to recover the state of the CPU
    before the function call, as well as possible. This will work well when
    parameters are constants written just before the call, for example:

        mov eax, 30
        mov ebx, DAT_encrypted_string
        call decrypt_string

    Then recovering eax is as simple as call.infer_context()["eax"]."""
    basicblock = BasicBlock(self._address)
    return Emulator.new(basicblock.start_address, self._address)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.GenericT" class="doc doc-heading">
            <code>GenericT</code>


</h2>


    <div class="doc doc-contents ">








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class GenericT:
    pass</code></pre>
              </details>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.GhidraWrapper" class="doc doc-heading">
            <code>GhidraWrapper</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="object">object</span></code></p>


        <p>The base class for all Ghidra wrappers.</p>
<p>This function tries to be as transparent as possible - for example, it will
not raise an error on double-wrapping, or when passed instead of a
Java type.</p>
<pre><code>&gt;&gt;&gt; instr = getInstructionAt(getAddr(0x1234))
&gt;&gt;&gt; GhidraWrapper(instr)
&lt;Instruction 0x1234&gt;
&gt;&gt;&gt; GhidraWrapper(GhidraWrapper(instr))
&lt;Instruction 0x1234&gt;
&gt;&gt;&gt; getInstructionBefore(Instruction(instr))
&lt;Instruction 0x1233&gt;
</code></pre>
<p>Similarly, equality is based on the underlying Java object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class GhidraWrapper(object):
    """The base class for all Ghidra wrappers.

    This function tries to be as transparent as possible - for example, it will
    not raise an error on double-wrapping, or when passed instead of a
    Java type.

        &gt;&gt;&gt; instr = getInstructionAt(getAddr(0x1234))
        &gt;&gt;&gt; GhidraWrapper(instr)
        &lt;Instruction 0x1234&gt;
        &gt;&gt;&gt; GhidraWrapper(GhidraWrapper(instr))
        &lt;Instruction 0x1234&gt;
        &gt;&gt;&gt; getInstructionBefore(Instruction(instr))
        &lt;Instruction 0x1233&gt;

    Similarly, equality is based on the underlying Java object."""

    def __init__(self, raw):  # type: (JavaObject|int|str|GhidraWrapper) -&gt; None
        """Initialize the wrapper.

        This function will try to resolve the given object to a Ghidra object.
        The algorithm is as follows:

        * If "raw" is a primitive type (int, long, str, unicode, Address),
          try to resolve it with a static "get" method of the subclass.
        * If "raw" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x))
          is always the same as GhidraWrapper(x).
        * If "raw" is None at this point, raise an exception.
        * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped
          type is of the expected type.
        * Save the final "raw" value."""

        if isinstance(raw, (int, long, str, unicode, GenericAddress)):
            # Someone passed a primitive type to us.
            # If possible, try to resolve it with a "get" method.
            if hasattr(self, "get"):
                new_raw = self.get(raw)  # type: ignore
                if new_raw is None:
                    # Show original data for better error messages
                    raise RuntimeError("Unable to wrap " + str(raw))
                raw = new_raw
            else:
                raise RuntimeError("Unable to wrap a primitive: " + str(raw))

        while isinstance(raw, GhidraWrapper):
            # In case someone tries to Function(Function("main")) us
            raw = raw.raw

        if raw is None:
            raise RuntimeError("Object doesn't exist (refusing to wrap None)")

        # TODO - remove the conditional checks and implement this everywhere
        if hasattr(self, "UNDERLYING_CLASS"):
            wrapped_type = getattr(self, "UNDERLYING_CLASS")
            if not isinstance(raw, wrapped_type):
                raise RuntimeError(
                    "You are trying to wrap {} as {}".format(
                        raw.__class__.__name__, self.__class__.__name__
                    )
                )

        def _java_cast(raw):  # type: (Any) -&gt; JavaObject
            """This function exists only to make type-checker happy"""
            return raw

        self.raw = _java_cast(raw)

    def __str__(self):  # type: () -&gt; str
        """Return a string representation of this object.

        This just forwards the call to the underlying object."""
        return self.raw.__str__()

    def __repr__(self):  # type: () -&gt; str
        """Return a string representation of this object.

        This just forwards the call to the underlying object."""
        return self.raw.__repr__()

    def __tojava__(self, klass):
        """Make it possible to pass this object to Java methods.

        This only works in Jython, I didn't find a way to do this in JPype yet."""
        return self.raw

    def __hash__(self):  # type: () -&gt; int
        """Return the hash of this object.

        This just forwards the call to the underlying object."""
        return self.raw.hashCode()

    def __eq__(self, other):  # type: (object) -&gt; bool
        """Check if this object is equal to another.

        This just forwards the call to the underlying object."""
        if isinstance(other, GhidraWrapper):
            return self.raw.equals(other.raw)
        return self.raw.equals(other)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.GhidraWrapper.raw" class="doc doc-heading">
            <code class="highlight language-python">raw = _java_cast(raw)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__eq__" class="doc doc-heading">
            <code class="highlight language-python">__eq__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this object is equal to another.</p>
<p>This just forwards the call to the underlying object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __eq__(self, other):  # type: (object) -&gt; bool
    """Check if this object is equal to another.

    This just forwards the call to the underlying object."""
    if isinstance(other, GhidraWrapper):
        return self.raw.equals(other.raw)
    return self.raw.equals(other)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__hash__" class="doc doc-heading">
            <code class="highlight language-python">__hash__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the hash of this object.</p>
<p>This just forwards the call to the underlying object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __hash__(self):  # type: () -&gt; int
    """Return the hash of this object.

    This just forwards the call to the underlying object."""
    return self.raw.hashCode()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(raw)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize the wrapper.</p>
<p>This function will try to resolve the given object to a Ghidra object.
The algorithm is as follows:</p>
<ul>
<li>If "raw" is a primitive type (int, long, str, unicode, Address),
  try to resolve it with a static "get" method of the subclass.</li>
<li>If "raw" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x))
  is always the same as GhidraWrapper(x).</li>
<li>If "raw" is None at this point, raise an exception.</li>
<li>If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped
  type is of the expected type.</li>
<li>Save the final "raw" value.</li>
</ul>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, raw):  # type: (JavaObject|int|str|GhidraWrapper) -&gt; None
    """Initialize the wrapper.

    This function will try to resolve the given object to a Ghidra object.
    The algorithm is as follows:

    * If "raw" is a primitive type (int, long, str, unicode, Address),
      try to resolve it with a static "get" method of the subclass.
    * If "raw" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x))
      is always the same as GhidraWrapper(x).
    * If "raw" is None at this point, raise an exception.
    * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped
      type is of the expected type.
    * Save the final "raw" value."""

    if isinstance(raw, (int, long, str, unicode, GenericAddress)):
        # Someone passed a primitive type to us.
        # If possible, try to resolve it with a "get" method.
        if hasattr(self, "get"):
            new_raw = self.get(raw)  # type: ignore
            if new_raw is None:
                # Show original data for better error messages
                raise RuntimeError("Unable to wrap " + str(raw))
            raw = new_raw
        else:
            raise RuntimeError("Unable to wrap a primitive: " + str(raw))

    while isinstance(raw, GhidraWrapper):
        # In case someone tries to Function(Function("main")) us
        raw = raw.raw

    if raw is None:
        raise RuntimeError("Object doesn't exist (refusing to wrap None)")

    # TODO - remove the conditional checks and implement this everywhere
    if hasattr(self, "UNDERLYING_CLASS"):
        wrapped_type = getattr(self, "UNDERLYING_CLASS")
        if not isinstance(raw, wrapped_type):
            raise RuntimeError(
                "You are trying to wrap {} as {}".format(
                    raw.__class__.__name__, self.__class__.__name__
                )
            )

    def _java_cast(raw):  # type: (Any) -&gt; JavaObject
        """This function exists only to make type-checker happy"""
        return raw

    self.raw = _java_cast(raw)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__repr__" class="doc doc-heading">
            <code class="highlight language-python">__repr__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return a string representation of this object.</p>
<p>This just forwards the call to the underlying object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __repr__(self):  # type: () -&gt; str
    """Return a string representation of this object.

    This just forwards the call to the underlying object."""
    return self.raw.__repr__()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__str__" class="doc doc-heading">
            <code class="highlight language-python">__str__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return a string representation of this object.</p>
<p>This just forwards the call to the underlying object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __str__(self):  # type: () -&gt; str
    """Return a string representation of this object.

    This just forwards the call to the underlying object."""
    return self.raw.__str__()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.GhidraWrapper.__tojava__" class="doc doc-heading">
            <code class="highlight language-python">__tojava__(klass)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Make it possible to pass this object to Java methods.</p>
<p>This only works in Jython, I didn't find a way to do this in JPype yet.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __tojava__(self, klass):
    """Make it possible to pass this object to Java methods.

    This only works in Jython, I didn't find a way to do this in JPype yet."""
    return self.raw</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Graph" class="doc doc-heading">
            <code>Graph</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GenericT (ghidralib.GenericT)" href="#ghidralib.GenericT">GenericT</a></code>, <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra AttributedGraph object.</p>
<p>We'd like to store arbitrary object in the graph, but it only supports
strings for keys (and names). We have a way to convert objects we are
interested in to strings - see _get_unique_string() method.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Graph(GenericT, GhidraWrapper):
    """Wraps a Ghidra AttributedGraph object.

    We'd like to store arbitrary object in the graph, but it only supports
    strings for keys (and names). We have a way to convert objects we are
    interested in to strings - see _get_unique_string() method."""

    # TODO: maybe this should be a GDirectedGraph, so we get some algorithms
    # for free, and we can just convert it for display.

    def __init__(self, raw):  # type: (AttributedGraph) -&gt; None
        """Create a new Graph wrapper.

        We have to keep track of additional data, since AttributedGraph is a bit
        clunky and can only store string IDs and string values.

        :param raw: The AttributedGraph object to wrap."""
        GhidraWrapper.__init__(self, raw)
        self.data = {}

    @staticmethod
    def create(name=None, description=None):  # type: (str|None, str|None) -&gt; Graph[Any]
        """Create a new Graph.

        :param name: The name of the graph. If None, a default name will be used.
        :param description: The description of the graph. If
        None, a default description will be used.
        :returns: a new Graph object.
        """
        name = name or "Graph"
        description = description or "Graph"
        graphtype = GraphType(name, description, ArrayList([]), ArrayList([]))
        return Graph(AttributedGraph(name, graphtype, description))

    @staticmethod
    def construct(
        vertexlist, getedges
    ):  # type: (list[T], Callable[[T], list[T]]) -&gt; Graph[T]
        """Create a new Graph from a list of vertices and a function to get edges.

        :param vertexlist: The list of vertices.
        :param getedges: A function that gets a list of destinations from a vertex."""
        g = Graph.create()
        for v in vertexlist:
            g.vertex(v)
        for v in vertexlist:
            for dest in getedges(v):
                if dest in g:
                    g.edge(v, dest)
        return g

    def __contains__(self, vtx):  # type: (T) -&gt; bool
        """Check if a given vertex exists in this graph.

        :param vtx: The ID of the vertex to check."""
        vid = _get_unique_string(vtx)
        vobj = self.raw.getVertex(vid)
        return self.raw.containsVertex(vobj)

    def has_vertex(self, vtx):  # type: (T) -&gt; bool
        """Check if a given vertex exists in this graph.

        :param vtx: The ID of the vertex to check."""
        return vtx in self

    def vertex(self, vtx, name=None):  # type: (T, str|None) -&gt; T
        """Get or create a vertex in this graph.

        :param vtx: The ID of the new vertex, or any "Vertexable" object
        that can be used to identify the vertex.
        :param name: The name of the vertex. If not provided,
        the ID will be used as the name.
        :returns: vtx parameter is returned"""
        vid = _get_unique_string(vtx)
        name = name or str(vtx)
        self.raw.addVertex(vid, name)
        self.data[vid] = vtx
        return vtx

    def edge(self, src, dst):  # type: (T, T) -&gt; None
        """Create an edge between two vertices in this graph.

        :param src: The source vertex ID.
        :param dst: The destination vertex ID."""
        srcid = _get_unique_string(src)
        dstid = _get_unique_string(dst)
        srcobj = self.raw.getVertex(srcid)
        dstobj = self.raw.getVertex(dstid)
        self.raw.addEdge(srcobj, dstobj)

    @property
    def vertices(self):  # type: () -&gt; list[T]
        """Get all vertices in this graph.

        Warning: this constructs the list every time, so it's not a light operation.
        Use vertex_count for counting."""
        return [self.__resolve(vid.getId()) for vid in self.raw.vertexSet()]

    @property
    def vertex_count(self):  # type: () -&gt; int
        """Return the number of vertices in this graph."""
        return self.raw.vertexSet().size()

    def __len__(self):  # type: () -&gt; int
        """Return the number of vertices in this graph.

        To get the number of edges, use edge_count."""
        return self.vertex_count

    @property
    def edges(self):  # type: () -&gt; list[tuple[T, T]]
        """Get all edges in this graph.

        Warning: this constructs the list every time, so it's not a light operation.
        Use edge_count for counting."""
        result = []
        for e in self.raw.edgeSet():
            frm = self.raw.getEdgeSource(e)
            to = self.raw.getEdgeTarget(e)
            frmobj = self.data.get(frm, frm)
            toobj = self.data.get(to, to)
            result.append((frmobj, toobj))
        return result

    @property
    def edge_count(self):  # type: () -&gt; int
        """Return the number of edges in this graph."""
        return self.raw.edgeSet().size()

    @property
    def name(self):  # type: () -&gt; str
        """Return the name of this graph."""
        return self.raw.getName()

    @property
    def description(self):  # type: () -&gt; str
        """Return the description of this graph."""
        return self.raw.getDescription()

    def to_dot(self):  # type: () -&gt; str
        """Return a DOT representation of this graph."""
        result = []
        result.append("digraph {} {{".format(self.name))
        for v in self.raw.vertexSet():
            result.append('    "{}" [label="{}"];'.format(v.getId(), v.getName()))
        for e in self.raw.edgeSet():
            frm = self.raw.getEdgeSource(e)
            to = self.raw.getEdgeTarget(e)
            result.append('    "{}" -&gt; "{}";'.format(frm.getId(), to.getId()))
        result.append("}")
        return "\n".join(result)

    def show(self):  # type: () -&gt; None
        """Display this graph in the Ghidra GUI."""
        graphtype = self.raw.getGraphType()
        description = graphtype.getDescription()
        options = GraphDisplayOptions(graphtype)

        broker = getState().tool.getService(GraphDisplayBroker)
        display = broker.getDefaultGraphDisplay(False, getMonitor())
        display.setGraph(self.raw, options, description, False, getMonitor())

    def __resolve(self, vid):  # type: (str) -&gt; T
        """Resolve a vertex ID to a vertex object.

        :param vid: The ID of the vertex to resolve."""
        if vid in self.data:
            return self.data[vid]
        else:
            return vid  # type: ignore graph created outside of ghidralib?

    def dfs(
        self, origin, callback=lambda _: None
    ):  # type: (T, Callable[[T], None]) -&gt; dict[T, T|None]
        """Perform a depth-first search on this graph, starting from the given vertex.

        The callback will be called for each vertex visited when first visited, and
        the returned value is a dictionary of parent vertices for each visited vertex.

            &gt;&gt;&gt; g = Graph.create()
            &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
            &gt;&gt;&gt; g.edge(a, b)
            &gt;&gt;&gt; g.edge(b, c)
            &gt;&gt;&gt; g.dfs(a)
            {'a': None, 'b': 'a', 'c': 'b'}

        Warning: This won't reach every node in the graph, if it's not connected.

        :param origin: The ID of the vertex to start the search from.
        :param callback: A callback function to call for each vertex visited.
        :returns: A dictionary of parent vertices for each visited vertex.
        """
        tovisit = [(None, _get_unique_string(origin))]
        visited = set()
        parents = {origin: None}  # type: dict[T, T|None]
        while tovisit:
            parent, vid = tovisit.pop()
            if vid in visited:
                continue
            visited.add(vid)
            vobj = self.__resolve(vid)
            parents[vobj] = parent
            callback(vobj)
            for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
                tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId()))
        return parents

    def toposort(self, origin):  # type: (T) -&gt; list[T]
        """Perform a topological sort on this graph, starting from the given vertex.
        :param origin: The ID of the vertex to start the sort from.

        The order is such that if there is an edge from A to B, then A will come
        before B in the list. This means that if the graph is connected and acyclic
        then "origin" will be the last element in the list.

        On a practical example, for a call graph, this means that if A calls B, then
        B will be before A in the list - so if you want to process from the bottom up,
        you should use the entry point of the program as the origin. In the example
        below, the entry point is "a", "a" calls "b", and "b" calls "c":

            &gt;&gt;&gt; g = Graph.create()
            &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
            &gt;&gt;&gt; g.edge(a, b)
            &gt;&gt;&gt; g.edge(b, c)
            &gt;&gt;&gt; g.toposort(a)
            ['c', 'b', 'a']

        :param origin: The ID of the origin vertex to start the sort from.
        :returns: a list of vertex IDs in topological order."""
        visited = set()
        result = []

        def dfs(vid):
            visited.add(vid)
            for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
                target = self.raw.getEdgeTarget(edge)
                if target.getId() not in visited:
                    dfs(target.getId())
            result.append(self.__resolve(vid))

        dfs(_get_unique_string(origin))
        for vid in self.raw.vertexSet():
            if vid.getId() not in visited:
                dfs(vid.getId())
        return result

    def bfs(
        self, origin, callback=lambda _: None
    ):  # type: (T, Callable[[T], None]) -&gt; dict[T, T|None]
        """Perform a breadth-first search on this graph, starting from the given vertex.

        The callback will be called for each vertex visited when first visited, and
        the returned value is a dictionary of parent vertices for each visited vertex.

            &gt;&gt;&gt; g = Graph.create()
            &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
            &gt;&gt;&gt; g.edge(a, b)
            &gt;&gt;&gt; g.edge(b, c)
            &gt;&gt;&gt; g.bfs(a)
            {'a': None, 'b': 'a', 'c': 'b'}

        Warning: This won't reach every node in the graph, if it's not connected.

        :param origin: The ID of the vertex to start the search from.
        :param callback: A callback function to call for each vertex visited.
        """
        tovisit = [(None, _get_unique_string(origin))]
        visited = set()
        parents = {origin: None}  # type: dict[T, T|None]
        while tovisit:
            parent, vid = tovisit.pop(0)
            if vid in visited:
                continue
            visited.add(vid)
            vobj = self.__resolve(vid)
            parents[vobj] = parent
            callback(vobj)
            for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
                tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId()))
        return parents</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.data" class="doc doc-heading">
            <code class="highlight language-python">data = {}</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.description" class="doc doc-heading">
            <code class="highlight language-python">description</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the description of this graph.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.edge_count" class="doc doc-heading">
            <code class="highlight language-python">edge_count</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the number of edges in this graph.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.edges" class="doc doc-heading">
            <code class="highlight language-python">edges</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all edges in this graph.</p>
<p>Warning: this constructs the list every time, so it's not a light operation.
Use edge_count for counting.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the name of this graph.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.vertex_count" class="doc doc-heading">
            <code class="highlight language-python">vertex_count</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the number of vertices in this graph.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Graph.vertices" class="doc doc-heading">
            <code class="highlight language-python">vertices</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all vertices in this graph.</p>
<p>Warning: this constructs the list every time, so it's not a light operation.
Use vertex_count for counting.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.__contains__" class="doc doc-heading">
            <code class="highlight language-python">__contains__(vtx)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if a given vertex exists in this graph.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>vtx</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to check.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __contains__(self, vtx):  # type: (T) -&gt; bool
    """Check if a given vertex exists in this graph.

    :param vtx: The ID of the vertex to check."""
    vid = _get_unique_string(vtx)
    vobj = self.raw.getVertex(vid)
    return self.raw.containsVertex(vobj)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(raw)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new Graph wrapper.</p>
<p>We have to keep track of additional data, since AttributedGraph is a bit
clunky and can only store string IDs and string values.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>raw</code></b>
              –
              <div class="doc-md-description">
                <p>The AttributedGraph object to wrap.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, raw):  # type: (AttributedGraph) -&gt; None
    """Create a new Graph wrapper.

    We have to keep track of additional data, since AttributedGraph is a bit
    clunky and can only store string IDs and string values.

    :param raw: The AttributedGraph object to wrap."""
    GhidraWrapper.__init__(self, raw)
    self.data = {}</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.__len__" class="doc doc-heading">
            <code class="highlight language-python">__len__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return the number of vertices in this graph.</p>
<p>To get the number of edges, use edge_count.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __len__(self):  # type: () -&gt; int
    """Return the number of vertices in this graph.

    To get the number of edges, use edge_count."""
    return self.vertex_count</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.__resolve" class="doc doc-heading">
            <code class="highlight language-python">__resolve(vid)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Resolve a vertex ID to a vertex object.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>vid</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to resolve.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __resolve(self, vid):  # type: (str) -&gt; T
    """Resolve a vertex ID to a vertex object.

    :param vid: The ID of the vertex to resolve."""
    if vid in self.data:
        return self.data[vid]
    else:
        return vid  # type: ignore graph created outside of ghidralib?</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.bfs" class="doc doc-heading">
            <code class="highlight language-python">bfs(origin, callback=lambda _: None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform a breadth-first search on this graph, starting from the given vertex.</p>
<p>The callback will be called for each vertex visited when first visited, and
the returned value is a dictionary of parent vertices for each visited vertex.</p>
<pre><code>&gt;&gt;&gt; g = Graph.create()
&gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
&gt;&gt;&gt; g.edge(a, b)
&gt;&gt;&gt; g.edge(b, c)
&gt;&gt;&gt; g.bfs(a)
{'a': None, 'b': 'a', 'c': 'b'}
</code></pre>
<p>Warning: This won't reach every node in the graph, if it's not connected.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>origin</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to start the search from.</p>
              </div>
            </li>
            <li>
              <b><code>callback</code></b>
              –
              <div class="doc-md-description">
                <p>A callback function to call for each vertex visited.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def bfs(
    self, origin, callback=lambda _: None
):  # type: (T, Callable[[T], None]) -&gt; dict[T, T|None]
    """Perform a breadth-first search on this graph, starting from the given vertex.

    The callback will be called for each vertex visited when first visited, and
    the returned value is a dictionary of parent vertices for each visited vertex.

        &gt;&gt;&gt; g = Graph.create()
        &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
        &gt;&gt;&gt; g.edge(a, b)
        &gt;&gt;&gt; g.edge(b, c)
        &gt;&gt;&gt; g.bfs(a)
        {'a': None, 'b': 'a', 'c': 'b'}

    Warning: This won't reach every node in the graph, if it's not connected.

    :param origin: The ID of the vertex to start the search from.
    :param callback: A callback function to call for each vertex visited.
    """
    tovisit = [(None, _get_unique_string(origin))]
    visited = set()
    parents = {origin: None}  # type: dict[T, T|None]
    while tovisit:
        parent, vid = tovisit.pop(0)
        if vid in visited:
            continue
        visited.add(vid)
        vobj = self.__resolve(vid)
        parents[vobj] = parent
        callback(vobj)
        for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
            tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId()))
    return parents</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.construct" class="doc doc-heading">
            <code class="highlight language-python">construct(vertexlist, getedges)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new Graph from a list of vertices and a function to get edges.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>vertexlist</code></b>
              –
              <div class="doc-md-description">
                <p>The list of vertices.</p>
              </div>
            </li>
            <li>
              <b><code>getedges</code></b>
              –
              <div class="doc-md-description">
                <p>A function that gets a list of destinations from a vertex.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def construct(
    vertexlist, getedges
):  # type: (list[T], Callable[[T], list[T]]) -&gt; Graph[T]
    """Create a new Graph from a list of vertices and a function to get edges.

    :param vertexlist: The list of vertices.
    :param getedges: A function that gets a list of destinations from a vertex."""
    g = Graph.create()
    for v in vertexlist:
        g.vertex(v)
    for v in vertexlist:
        for dest in getedges(v):
            if dest in g:
                g.edge(v, dest)
    return g</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.create" class="doc doc-heading">
            <code class="highlight language-python">create(name=None, description=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new Graph.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>name</code></b>
              –
              <div class="doc-md-description">
                <p>The name of the graph. If None, a default name will be used.</p>
              </div>
            </li>
            <li>
              <b><code>description</code></b>
              –
              <div class="doc-md-description">
                <p>The description of the graph. If None, a default description will be used.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>a new Graph object.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create(name=None, description=None):  # type: (str|None, str|None) -&gt; Graph[Any]
    """Create a new Graph.

    :param name: The name of the graph. If None, a default name will be used.
    :param description: The description of the graph. If
    None, a default description will be used.
    :returns: a new Graph object.
    """
    name = name or "Graph"
    description = description or "Graph"
    graphtype = GraphType(name, description, ArrayList([]), ArrayList([]))
    return Graph(AttributedGraph(name, graphtype, description))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.dfs" class="doc doc-heading">
            <code class="highlight language-python">dfs(origin, callback=lambda _: None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform a depth-first search on this graph, starting from the given vertex.</p>
<p>The callback will be called for each vertex visited when first visited, and
the returned value is a dictionary of parent vertices for each visited vertex.</p>
<pre><code>&gt;&gt;&gt; g = Graph.create()
&gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
&gt;&gt;&gt; g.edge(a, b)
&gt;&gt;&gt; g.edge(b, c)
&gt;&gt;&gt; g.dfs(a)
{'a': None, 'b': 'a', 'c': 'b'}
</code></pre>
<p>Warning: This won't reach every node in the graph, if it's not connected.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>origin</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to start the search from.</p>
              </div>
            </li>
            <li>
              <b><code>callback</code></b>
              –
              <div class="doc-md-description">
                <p>A callback function to call for each vertex visited.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>A dictionary of parent vertices for each visited vertex.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def dfs(
    self, origin, callback=lambda _: None
):  # type: (T, Callable[[T], None]) -&gt; dict[T, T|None]
    """Perform a depth-first search on this graph, starting from the given vertex.

    The callback will be called for each vertex visited when first visited, and
    the returned value is a dictionary of parent vertices for each visited vertex.

        &gt;&gt;&gt; g = Graph.create()
        &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
        &gt;&gt;&gt; g.edge(a, b)
        &gt;&gt;&gt; g.edge(b, c)
        &gt;&gt;&gt; g.dfs(a)
        {'a': None, 'b': 'a', 'c': 'b'}

    Warning: This won't reach every node in the graph, if it's not connected.

    :param origin: The ID of the vertex to start the search from.
    :param callback: A callback function to call for each vertex visited.
    :returns: A dictionary of parent vertices for each visited vertex.
    """
    tovisit = [(None, _get_unique_string(origin))]
    visited = set()
    parents = {origin: None}  # type: dict[T, T|None]
    while tovisit:
        parent, vid = tovisit.pop()
        if vid in visited:
            continue
        visited.add(vid)
        vobj = self.__resolve(vid)
        parents[vobj] = parent
        callback(vobj)
        for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
            tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId()))
    return parents</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.edge" class="doc doc-heading">
            <code class="highlight language-python">edge(src, dst)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Create an edge between two vertices in this graph.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>src</code></b>
              –
              <div class="doc-md-description">
                <p>The source vertex ID.</p>
              </div>
            </li>
            <li>
              <b><code>dst</code></b>
              –
              <div class="doc-md-description">
                <p>The destination vertex ID.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def edge(self, src, dst):  # type: (T, T) -&gt; None
    """Create an edge between two vertices in this graph.

    :param src: The source vertex ID.
    :param dst: The destination vertex ID."""
    srcid = _get_unique_string(src)
    dstid = _get_unique_string(dst)
    srcobj = self.raw.getVertex(srcid)
    dstobj = self.raw.getVertex(dstid)
    self.raw.addEdge(srcobj, dstobj)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.has_vertex" class="doc doc-heading">
            <code class="highlight language-python">has_vertex(vtx)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if a given vertex exists in this graph.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>vtx</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to check.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def has_vertex(self, vtx):  # type: (T) -&gt; bool
    """Check if a given vertex exists in this graph.

    :param vtx: The ID of the vertex to check."""
    return vtx in self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.show" class="doc doc-heading">
            <code class="highlight language-python">show()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Display this graph in the Ghidra GUI.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def show(self):  # type: () -&gt; None
    """Display this graph in the Ghidra GUI."""
    graphtype = self.raw.getGraphType()
    description = graphtype.getDescription()
    options = GraphDisplayOptions(graphtype)

    broker = getState().tool.getService(GraphDisplayBroker)
    display = broker.getDefaultGraphDisplay(False, getMonitor())
    display.setGraph(self.raw, options, description, False, getMonitor())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.to_dot" class="doc doc-heading">
            <code class="highlight language-python">to_dot()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return a DOT representation of this graph.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def to_dot(self):  # type: () -&gt; str
    """Return a DOT representation of this graph."""
    result = []
    result.append("digraph {} {{".format(self.name))
    for v in self.raw.vertexSet():
        result.append('    "{}" [label="{}"];'.format(v.getId(), v.getName()))
    for e in self.raw.edgeSet():
        frm = self.raw.getEdgeSource(e)
        to = self.raw.getEdgeTarget(e)
        result.append('    "{}" -&gt; "{}";'.format(frm.getId(), to.getId()))
    result.append("}")
    return "\n".join(result)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.toposort" class="doc doc-heading">
            <code class="highlight language-python">toposort(origin)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform a topological sort on this graph, starting from the given vertex.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>origin</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the vertex to start the sort from.  The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then "origin" will be the last element in the list.  On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is "a", "a" calls "b", and "b" calls "c":  &gt;&gt;&gt; g = Graph.create() &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c") &gt;&gt;&gt; g.edge(a, b) &gt;&gt;&gt; g.edge(b, c) &gt;&gt;&gt; g.toposort(a) ['c', 'b', 'a']</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>a list of vertex IDs in topological order.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def toposort(self, origin):  # type: (T) -&gt; list[T]
    """Perform a topological sort on this graph, starting from the given vertex.
    :param origin: The ID of the vertex to start the sort from.

    The order is such that if there is an edge from A to B, then A will come
    before B in the list. This means that if the graph is connected and acyclic
    then "origin" will be the last element in the list.

    On a practical example, for a call graph, this means that if A calls B, then
    B will be before A in the list - so if you want to process from the bottom up,
    you should use the entry point of the program as the origin. In the example
    below, the entry point is "a", "a" calls "b", and "b" calls "c":

        &gt;&gt;&gt; g = Graph.create()
        &gt;&gt;&gt; a, b, c = g.vertex("a"), g.vertex("b"), g.vertex("c")
        &gt;&gt;&gt; g.edge(a, b)
        &gt;&gt;&gt; g.edge(b, c)
        &gt;&gt;&gt; g.toposort(a)
        ['c', 'b', 'a']

    :param origin: The ID of the origin vertex to start the sort from.
    :returns: a list of vertex IDs in topological order."""
    visited = set()
    result = []

    def dfs(vid):
        visited.add(vid)
        for edge in self.raw.edgesOf(self.raw.getVertex(vid)):
            target = self.raw.getEdgeTarget(edge)
            if target.getId() not in visited:
                dfs(target.getId())
        result.append(self.__resolve(vid))

    dfs(_get_unique_string(origin))
    for vid in self.raw.vertexSet():
        if vid.getId() not in visited:
            dfs(vid.getId())
    return result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Graph.vertex" class="doc doc-heading">
            <code class="highlight language-python">vertex(vtx, name=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get or create a vertex in this graph.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>vtx</code></b>
              –
              <div class="doc-md-description">
                <p>The ID of the new vertex, or any "Vertexable" object that can be used to identify the vertex.</p>
              </div>
            </li>
            <li>
              <b><code>name</code></b>
              –
              <div class="doc-md-description">
                <p>The name of the vertex. If not provided, the ID will be used as the name.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>vtx parameter is returned</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def vertex(self, vtx, name=None):  # type: (T, str|None) -&gt; T
    """Get or create a vertex in this graph.

    :param vtx: The ID of the new vertex, or any "Vertexable" object
    that can be used to identify the vertex.
    :param name: The name of the vertex. If not provided,
    the ID will be used as the name.
    :returns: vtx parameter is returned"""
    vid = _get_unique_string(vtx)
    name = name or str(vtx)
    self.raw.addVertex(vid, name)
    self.data[vid] = vtx
    return vtx</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.HighFunction" class="doc doc-heading">
            <code>HighFunction</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class HighFunction(GhidraWrapper):
    @staticmethod
    def get(address):  # type: (JavaObject|str|Addr) -&gt; HighFunction|None
        """Get a HighFunction at a given address, or None if there is none."""
        if isinstance(address, GhHighFunction):
            return HighFunction(address)
        func = Function.get(address)
        if func is None:
            return None
        return func.high_function

    @property
    def function(self):  # type: () -&gt; Function
        """Get the underlying function of this high function."""
        return Function(self.raw.getFunction())

    def get_pcode_at(self, address):  # type: (Addr) -&gt; list[PcodeOp]
        """Get a list of PcodeOps at a given address.

        This list may be empty even if there are instructions at that address."""
        address = resolve(address)
        return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)]

    @property
    def pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get a list of all high PcodeOps in this function.

        Note: high PcodeOps are called PcodeOpAST internally."""
        return [PcodeOp(raw) for raw in self.raw.getPcodeOps()]

    @property
    def data_flow(self):  # type: () -&gt; Graph[PcodeOp]
        """Get a data flow graph of varnodes in this function.

        Note: I don't think this method is currently very useful, but you can
        use it to easily get information about all varnodes that impact a value of
        another varnode

        :returns: A graph where vertexes are varnodes, and edges mean that
        target varnode is a result of operation on source varnodes."""
        g = Graph.create()
        for op in self.pcode:
            if op.output:
                for inp in op.inputs:
                    g.vertex(op.output)
                    g.vertex(inp)
                    g.edge(inp, op.output)
        return g

    @property
    def basicblocks(self):  # type: () -&gt; list[PcodeBlock]
        """Get a list of basic blocks in this high function."""
        return [PcodeBlock(raw) for raw in self.raw.getBasicBlocks()]

    @property
    def pcode_tree(self):  # type: () -&gt; BlockGraph
        """Get an AST-like representation of the function's Pcode.

        Warning: this method needs to decompile the function, and is therefore slow."""
        edge_map = {}
        ingraph = GhBlockGraph()
        for block in self.basicblocks:
            gb = BlockCopy(block.raw, block.raw.getStart())
            ingraph.addBlock(gb)
            edge_map[block.raw] = gb

        for block in self.basicblocks:
            for edge in block.outgoing_edges:
                ingraph.addEdge(edge_map[block.raw], edge_map[edge.raw])

        ingraph.setIndices()
        decompiler = DecompInterface()
        decompiler.openProgram(Program.current())
        outgraph = decompiler.structureGraph(ingraph, 0, getMonitor())
        return BlockGraph(outgraph)

    @property
    def varnodes(self):  # type: () -&gt; list[Varnode]
        """Get all varnodes used in this function."""
        return [Varnode(raw) for raw in self.raw.locRange()]

    @property
    def symbols(self):  # type: () -&gt; list[HighSymbol]
        """Get high symbols used in this function (including parameters)."""
        sm = self.raw.getLocalSymbolMap()
        return [HighSymbol(symbol) for symbol in sm.getSymbols()]

    @property
    def variables(self):  # type: () -&gt; list[HighVariable]
        """Get high variables defined in this function."""
        result = []
        for sym in self.symbols:
            var = sym.variable
            if var is not None:
                result.append(var)
        return result

    def __eq__(self, other):  # type: (object) -&gt; bool
        """Compare two high functions.

        Fun fact - Ghidra doesn't know how to do this."""
        if not isinstance(other, HighFunction):
            return False
        return self.function == other.function</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.basicblocks" class="doc doc-heading">
            <code class="highlight language-python">basicblocks</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of basic blocks in this high function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.data_flow" class="doc doc-heading">
            <code class="highlight language-python">data_flow</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a data flow graph of varnodes in this function.</p>
<p>Note: I don't think this method is currently very useful, but you can
use it to easily get information about all varnodes that impact a value of
another varnode</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>A graph where vertexes are varnodes, and edges mean that target varnode is a result of operation on source varnodes.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.function" class="doc doc-heading">
            <code class="highlight language-python">function</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the underlying function of this high function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.pcode" class="doc doc-heading">
            <code class="highlight language-python">pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of all high PcodeOps in this function.</p>
<p>Note: high PcodeOps are called PcodeOpAST internally.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.pcode_tree" class="doc doc-heading">
            <code class="highlight language-python">pcode_tree</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get an AST-like representation of the function's Pcode.</p>
<p>Warning: this method needs to decompile the function, and is therefore slow.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.symbols" class="doc doc-heading">
            <code class="highlight language-python">symbols</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get high symbols used in this function (including parameters).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.variables" class="doc doc-heading">
            <code class="highlight language-python">variables</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get high variables defined in this function.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighFunction.varnodes" class="doc doc-heading">
            <code class="highlight language-python">varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all varnodes used in this function.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.HighFunction.__eq__" class="doc doc-heading">
            <code class="highlight language-python">__eq__(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Compare two high functions.</p>
<p>Fun fact - Ghidra doesn't know how to do this.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __eq__(self, other):  # type: (object) -&gt; bool
    """Compare two high functions.

    Fun fact - Ghidra doesn't know how to do this."""
    if not isinstance(other, HighFunction):
        return False
    return self.function == other.function</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.HighFunction.get" class="doc doc-heading">
            <code class="highlight language-python">get(address)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a HighFunction at a given address, or None if there is none.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(address):  # type: (JavaObject|str|Addr) -&gt; HighFunction|None
    """Get a HighFunction at a given address, or None if there is none."""
    if isinstance(address, GhHighFunction):
        return HighFunction(address)
    func = Function.get(address)
    if func is None:
        return None
    return func.high_function</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.HighFunction.get_pcode_at" class="doc doc-heading">
            <code class="highlight language-python">get_pcode_at(address)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of PcodeOps at a given address.</p>
<p>This list may be empty even if there are instructions at that address.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_pcode_at(self, address):  # type: (Addr) -&gt; list[PcodeOp]
    """Get a list of PcodeOps at a given address.

    This list may be empty even if there are instructions at that address."""
    address = resolve(address)
    return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)]</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.HighSymbol" class="doc doc-heading">
            <code>HighSymbol</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class HighSymbol(GhidraWrapper):
    def rename(
        self, new_name, source=SourceType.USER_DEFINED
    ):  # type: (str, SourceType) -&gt; None
        """Rename this high symbol.

        :param new_name: The new name of the symbol
        :param source: The source of the symbol"""
        HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source)

    @property
    def size(self):  # type: () -&gt; int
        """Return the size of this symbol in bytes"""
        return self.raw.getSize()

    @property
    def data_type(self):  # type: () -&gt; DataType
        """Return the data type of this symbol"""
        return DataType(self.raw.getDataType())

    @property
    def variable(self):  # type: () -&gt; HighVariable|None
        """Return the high variable associated with this symbol, if any.

        The symbol may have multiple HighVariables associated with it.
        This method returns the biggest one."""
        raw = self.raw.getHighVariable()
        if raw is None:
            return None
        return HighVariable(raw)

    @property
    def name(self):  # type: () -&gt; str
        """Return the name of this symbol"""
        return self.raw.getName()

    @property
    def symbol(self):  # type: () -&gt; Symbol|None
        """Get the corresponding symbol, if it exists."""
        raw = self.raw.getSymbol()
        if raw is None:
            return None
        return Symbol(raw)

    @property
    def is_this_pointer(self):  # type: () -&gt; bool
        """Return True if this symbol is a "this" pointer for a class"""
        return self.raw.isThisPointer()</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.data_type" class="doc doc-heading">
            <code class="highlight language-python">data_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the data type of this symbol</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.is_this_pointer" class="doc doc-heading">
            <code class="highlight language-python">is_this_pointer</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this symbol is a "this" pointer for a class</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the name of this symbol</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.size" class="doc doc-heading">
            <code class="highlight language-python">size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the size of this symbol in bytes</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.symbol" class="doc doc-heading">
            <code class="highlight language-python">symbol</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the corresponding symbol, if it exists.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighSymbol.variable" class="doc doc-heading">
            <code class="highlight language-python">variable</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the high variable associated with this symbol, if any.</p>
<p>The symbol may have multiple HighVariables associated with it.
This method returns the biggest one.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.HighSymbol.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(new_name, source=SourceType.USER_DEFINED)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Rename this high symbol.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>new_name</code></b>
              –
              <div class="doc-md-description">
                <p>The new name of the symbol</p>
              </div>
            </li>
            <li>
              <b><code>source</code></b>
              –
              <div class="doc-md-description">
                <p>The source of the symbol</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(
    self, new_name, source=SourceType.USER_DEFINED
):  # type: (str, SourceType) -&gt; None
    """Rename this high symbol.

    :param new_name: The new name of the symbol
    :param source: The source of the symbol"""
    HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.HighVariable" class="doc doc-heading">
            <code>HighVariable</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class HighVariable(GhidraWrapper):
    @property
    def symbol(self):  # type: () -&gt; HighSymbol
        return HighSymbol(self.raw.getSymbol())

    def rename(self, new_name):  # type: (str) -&gt; None
        """Rename this high variable."""
        self.symbol.rename(new_name)

    @property
    def size(self):  # type: () -&gt; int
        """Return the size of this variable in bytes"""
        return self.raw.getSize()

    @property
    def data_type(self):  # type: () -&gt; DataType
        """Return the data type of this variable"""
        return DataType(self.raw.getDataType())

    @property
    def name(self):  # type: () -&gt; str
        """Return the name of this variable"""
        return self.raw.getName()

    @property
    def varnode(self):  # type: () -&gt; Varnode
        """Return the Varnode that represents this variable"""
        return Varnode(self.raw.getRepresentative())

    @property
    def varnodes(self):  # type: () -&gt; list[Varnode]
        """Return all Varnodes that represent this variable at some point"""
        return [Varnode(vn) for vn in self.raw.getInstances()]

    @property
    def is_unaffected(self):  # type: () -&gt; bool
        """Return True if ALL varnodes of this variable are is unaffected."""
        return any(vn.is_unaffected for vn in self.varnodes)

    @property
    def is_persistent(self):  # type: () -&gt; bool
        """Return True if ALL varnodes of this variable are persistent."""
        return any(vn.is_persistent for vn in self.varnodes)

    @property
    def is_addr_tied(self):  # type: () -&gt; bool
        """Return True if ALL varnodes of this variable are addr tied."""
        return any(vn.is_addr_tied for vn in self.varnodes)

    @property
    def is_input(self):  # type: () -&gt; bool
        """Return True if ALL varnodes of this variable are input."""
        return any(vn.is_input for vn in self.varnodes)

    @property
    def is_free(self):  # type: () -&gt; bool
        """Return True if ALL varnodes of this variable are free."""
        return all(vn.is_free for vn in self.varnodes)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.data_type" class="doc doc-heading">
            <code class="highlight language-python">data_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the data type of this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.is_addr_tied" class="doc doc-heading">
            <code class="highlight language-python">is_addr_tied</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if ALL varnodes of this variable are addr tied.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.is_free" class="doc doc-heading">
            <code class="highlight language-python">is_free</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if ALL varnodes of this variable are free.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.is_input" class="doc doc-heading">
            <code class="highlight language-python">is_input</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if ALL varnodes of this variable are input.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.is_persistent" class="doc doc-heading">
            <code class="highlight language-python">is_persistent</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if ALL varnodes of this variable are persistent.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.is_unaffected" class="doc doc-heading">
            <code class="highlight language-python">is_unaffected</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if ALL varnodes of this variable are is unaffected.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the name of this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.size" class="doc doc-heading">
            <code class="highlight language-python">size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the size of this variable in bytes</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.symbol" class="doc doc-heading">
            <code class="highlight language-python">symbol</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.varnode" class="doc doc-heading">
            <code class="highlight language-python">varnode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the Varnode that represents this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.HighVariable.varnodes" class="doc doc-heading">
            <code class="highlight language-python">varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return all Varnodes that represent this variable at some point</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.HighVariable.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(new_name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Rename this high variable.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(self, new_name):  # type: (str) -&gt; None
    """Rename this high variable."""
    self.symbol.rename(new_name)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Instruction" class="doc doc-heading">
            <code>Instruction</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code>, <code><a class="autorefs autorefs-internal" title="BodyTrait (ghidralib.BodyTrait)" href="#ghidralib.BodyTrait">BodyTrait</a></code></p>


        <p>Wraps a Ghidra Instruction object</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Instruction(GhidraWrapper, BodyTrait):
    """Wraps a Ghidra Instruction object"""

    @staticmethod
    def get(address):  # type: (JavaObject|str|Addr) -&gt; Instruction|None
        """Get an instruction at the address, or None if not found.

        Note: This will return None if the instruction is not defined in Ghidra
        at the given address. If you want to disassemble an address, not necessarily
        defined in Ghidra, try :func:`disassemble_at` instead.

        :param address: The address of the instruction.
        :return: The instruction at the address, or None if not found."""
        if can_resolve(address):
            raw = getInstructionAt(resolve(address))
        else:
            raw = address
        if raw is None:
            return None
        return Instruction(raw)

    @staticmethod
    def all():  # type: () -&gt; list[Instruction]
        """Get all instruction defined in the current program."""
        raw_instructions = Program.current().getListing().getInstructions(True)
        return [Instruction(raw) for raw in raw_instructions]

    @staticmethod
    def create(address):  # type: (Addr) -&gt; Instruction
        """Create an instruction at the given address.

        Note: this will force ghidra to disassemble at the given address,
        and return the created instruction. If you want to actually change the
        instruction at the given address, use `assemble_at` instead.

        If you want to just create an instruction object, use `assemble` method.

        :param address: The address where instruction should be created.
        """
        addr = resolve(address)
        disassemble(addr)
        return Instruction(addr)

    @property
    def mnemonic(self):  # type: () -&gt; str
        """Get the mnemonic of this instruction."""
        return self.raw.getMnemonicString()

    @property
    def next(self):  # type: () -&gt; Instruction
        """Get the next instruction."""
        return Instruction(self.raw.getNext())

    @property
    def previous(self):  # type: () -&gt; Instruction
        """Get the previous instruction."""
        return Instruction(self.raw.getPrevious())

    prev = previous

    @property
    def flows(self):  # type: () -&gt; list[int]
        """Get a set of possible flows (next executed addresses).

        Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO,
        but I'm being faithful to Ghidra API."""
        return [addr.getOffset() for addr in self.raw.getFlows()]

    @property
    def all_flows(self):  # type: () -&gt; list[int]
        """Get a set of possible flows (next executed addresses).

        Note: this INCLUDES fallthrough."""
        fallthrough = self.fallthrough
        return self.flows + ([fallthrough] if fallthrough else [])

    @property
    def pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get a list of Pcode operations that this instruction was parsed to"""
        return [PcodeOp(raw) for raw in self.raw.getPcode()]

    @property
    def output_varnodes(self):  # type: () -&gt; list[Varnode]
        """Get a list of output (LOW) varnodes for this instruction."""
        return [op.output for op in self.pcode if op.output]

    @property
    def input_varnodes(self):  # type: () -&gt; list[Varnode]
        """Get a list of output (LOW) varnodes for this instruction."""
        return [inp for op in self.pcode if op.output for inp in op.inputs]

    @property
    def high_pcode(self):  # type: () -&gt; list[PcodeOp]
        """Get high Pcode for this instruction.

        WARNING: do not use this in a loop. Use Function.high_pcode instead."""
        return PcodeOp.get_high_pcode_at(self.address)

    @property
    def xrefs_from(self):  # type: () -&gt; list[Reference]
        """Get a list of references from this instruction."""
        return [Reference(raw) for raw in self.raw.getReferencesFrom()]

    @property
    def xrefs_to(self):  # type: () -&gt; list[Reference]
        """Get a list of references to this instruction."""
        return [Reference(raw) for raw in self.raw.getReferenceIteratorTo()]

    @property
    def bytes(self):  # type: () -&gt; bytes
        """Get the bytes of this instruction."""
        return _bytes_from_bytelist(self.raw.getBytes())

    @property
    def length(self):  # type: () -&gt; int
        """Get the length of this instruction in bytes."""
        return self.raw.getLength()

    def __len__(self):  # type: () -&gt; int
        """Get the length of this instruction in bytes."""
        return self.length

    def __convert_operand(self, operand):  # type: (JavaObject) -&gt; Operand
        """Convert an operand to a scalar or address."""
        from ghidra.program.model.address import Address  # type: ignore
        from ghidra.program.model.scalar import Scalar  # type: ignore

        if isinstance(operand, GhRegister):
            return Operand(_python_str(operand.getName()))
        elif isinstance(operand, Address):
            return Operand(operand.getOffset())
        elif isinstance(operand, Scalar):
            return Operand(operand.getValue())
        elif _is_array(operand):
            operands = [self.__convert_operand(o).raw for o in operand]  # type: ignore
            if len(operands) == 1:
                # Unwrap the operands if there is only one operand
                return Operand(operands[0])
            return Operand(operands)  # type: ignore (we know there are no nested lists)
        else:
            raise RuntimeError("Don't know how to read operand {}".format(operand))

    def operand(self, ndx):  # type: (int) -&gt; Operand
        """Get the nth operand of this instruction as an object."""
        operand = self.raw.getOpObjects(ndx)
        return self.__convert_operand(operand)

    @property
    def address(self):  # type: () -&gt; int
        """Get the address of this instruction."""
        return self.raw.getAddress().getOffset()

    @property
    def operands(self):  # type: () -&gt; list[Operand]
        """Return operands as primitive values (int or a string representation).

        More specifically, this will convert constants and addresses into integers,
        and for registers the name will be returned.

        If you know operand type, call .scalar(), .register() or .list() instead."""
        return [self.operand(i) for i in range(self.raw.getNumOperands())]

    @property
    def operand_values(self):  # type: () -&gt; list[int|str|list[int|str]]
        """Return operands as primitive values (int or a string representation).

        This is equivalent to calling .operands() and then calling .value()
        on each operand."""
        return [operand.value for operand in self.operands]

    @property
    def flow_type(self):  # type: () -&gt; FlowType
        """Get the flow type of this instruction.

        For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP"""
        return FlowType(self.raw.getFlowType())

    # int opIndex, Address refAddr, RefType type, SourceType sourceType
    def add_operand_reference(
        self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED
    ):  # type: (int, Addr, RefType, SourceType) -&gt; None
        """Add a reference to an operand of this instruction."""
        self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type)

    @property
    def body(self):  # type: () -&gt; AddressSet
        """Get the address range this instruction."""
        return AddressSet.create(self.address, self.length)

    @property
    def has_fallthrough(self):  # type: () -&gt; bool
        """Return true if this instruction has a fallthrough."""
        return self.raw.hasFallthrough()

    @property
    def fallthrough(self):  # type: () -&gt; int|None
        """Get the fallthrough address (next address executed), if any.

        For normal instruction, this is the next instruction address. For jumps,
        this is None. Can be overriden by fallthrough override."""
        fall = self.raw.getFallThrough()
        if not fall:
            return None
        return fall.getOffset()

    def set_fallthrough_override(self, value):  # type: (Addr) -&gt; None
        """Override the fallthrough address for this instruction.

        This sets the next instruction that will be executed after this
        instruction, assuming the current instruction doesn't jump anywhere.
        You can clear this with clear_fallthrough_override

        :param value: new fallthrough address"""
        self.raw.setFallThrough(resolve(value))

    def clear_fallthrough_override(self):  # type: () -&gt; None
        """This clears the fallthrough override for this instruction.

        Alias for del self.fallthrough_override"""
        self.raw.clearFallThroughOverride()

    @property
    def has_fallthrough_override(self):  # type: () -&gt; bool
        """Return true if this instruction fallthrough was overriden."""
        return self.raw.isFallThroughOverridden()

    def write_jumptable(self, targets):  # type: (list[Addr]) -&gt; None
        """Provide a list of addresses where this instruction may jump.

        Warning: For this to work, the instruction must be a part of a function.

        This is useful for fixing unrecognised switches, for example.

        Note: the new switch instruction will use all references of type
        COMPUTED_JUMP already defined for the instruction
        (maybe we should clear them first?)."""

        targets = [resolve(addr) for addr in targets]

        for dest in targets:
            disassemble(dest)
            self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP)

        func = Function.get(self.address)
        if func is None:
            raise RuntimeError("Instruction is not part of a function")

        targetlist = ArrayList([dest for dest in targets])
        jumpTab = JumpTable(toAddr(self.address), targetlist, True)
        jumpTab.writeOverride(func.raw)
        CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor())</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.all_flows" class="doc doc-heading">
            <code class="highlight language-python">all_flows</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a set of possible flows (next executed addresses).</p>
<p>Note: this INCLUDES fallthrough.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address range this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.bytes" class="doc doc-heading">
            <code class="highlight language-python">bytes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the bytes of this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.fallthrough" class="doc doc-heading">
            <code class="highlight language-python">fallthrough</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the fallthrough address (next address executed), if any.</p>
<p>For normal instruction, this is the next instruction address. For jumps,
this is None. Can be overriden by fallthrough override.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.flow_type" class="doc doc-heading">
            <code class="highlight language-python">flow_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the flow type of this instruction.</p>
<p>For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.flows" class="doc doc-heading">
            <code class="highlight language-python">flows</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a set of possible flows (next executed addresses).</p>
<p>Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO,
but I'm being faithful to Ghidra API.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.has_fallthrough" class="doc doc-heading">
            <code class="highlight language-python">has_fallthrough</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return true if this instruction has a fallthrough.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.has_fallthrough_override" class="doc doc-heading">
            <code class="highlight language-python">has_fallthrough_override</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return true if this instruction fallthrough was overriden.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.high_pcode" class="doc doc-heading">
            <code class="highlight language-python">high_pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get high Pcode for this instruction.</p>
<p>WARNING: do not use this in a loop. Use Function.high_pcode instead.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.input_varnodes" class="doc doc-heading">
            <code class="highlight language-python">input_varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of output (LOW) varnodes for this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.length" class="doc doc-heading">
            <code class="highlight language-python">length</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this instruction in bytes.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.mnemonic" class="doc doc-heading">
            <code class="highlight language-python">mnemonic</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the mnemonic of this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.next" class="doc doc-heading">
            <code class="highlight language-python">next</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the next instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.operand_values" class="doc doc-heading">
            <code class="highlight language-python">operand_values</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return operands as primitive values (int or a string representation).</p>
<p>This is equivalent to calling .operands() and then calling .value()
on each operand.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.operands" class="doc doc-heading">
            <code class="highlight language-python">operands</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return operands as primitive values (int or a string representation).</p>
<p>More specifically, this will convert constants and addresses into integers,
and for registers the name will be returned.</p>
<p>If you know operand type, call .scalar(), .register() or .list() instead.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.output_varnodes" class="doc doc-heading">
            <code class="highlight language-python">output_varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of output (LOW) varnodes for this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.pcode" class="doc doc-heading">
            <code class="highlight language-python">pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of Pcode operations that this instruction was parsed to</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.prev" class="doc doc-heading">
            <code class="highlight language-python">prev = previous</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.previous" class="doc doc-heading">
            <code class="highlight language-python">previous</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the previous instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.xrefs_from" class="doc doc-heading">
            <code class="highlight language-python">xrefs_from</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of references from this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Instruction.xrefs_to" class="doc doc-heading">
            <code class="highlight language-python">xrefs_to</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of references to this instruction.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.__convert_operand" class="doc doc-heading">
            <code class="highlight language-python">__convert_operand(operand)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Convert an operand to a scalar or address.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __convert_operand(self, operand):  # type: (JavaObject) -&gt; Operand
    """Convert an operand to a scalar or address."""
    from ghidra.program.model.address import Address  # type: ignore
    from ghidra.program.model.scalar import Scalar  # type: ignore

    if isinstance(operand, GhRegister):
        return Operand(_python_str(operand.getName()))
    elif isinstance(operand, Address):
        return Operand(operand.getOffset())
    elif isinstance(operand, Scalar):
        return Operand(operand.getValue())
    elif _is_array(operand):
        operands = [self.__convert_operand(o).raw for o in operand]  # type: ignore
        if len(operands) == 1:
            # Unwrap the operands if there is only one operand
            return Operand(operands[0])
        return Operand(operands)  # type: ignore (we know there are no nested lists)
    else:
        raise RuntimeError("Don't know how to read operand {}".format(operand))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.__len__" class="doc doc-heading">
            <code class="highlight language-python">__len__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the length of this instruction in bytes.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __len__(self):  # type: () -&gt; int
    """Get the length of this instruction in bytes."""
    return self.length</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.add_operand_reference" class="doc doc-heading">
            <code class="highlight language-python">add_operand_reference(op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Add a reference to an operand of this instruction.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def add_operand_reference(
    self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED
):  # type: (int, Addr, RefType, SourceType) -&gt; None
    """Add a reference to an operand of this instruction."""
    self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.all" class="doc doc-heading">
            <code class="highlight language-python">all()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all instruction defined in the current program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all():  # type: () -&gt; list[Instruction]
    """Get all instruction defined in the current program."""
    raw_instructions = Program.current().getListing().getInstructions(True)
    return [Instruction(raw) for raw in raw_instructions]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.clear_fallthrough_override" class="doc doc-heading">
            <code class="highlight language-python">clear_fallthrough_override()</code>

</h3>


    <div class="doc doc-contents ">

        <p>This clears the fallthrough override for this instruction.</p>
<p>Alias for del self.fallthrough_override</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def clear_fallthrough_override(self):  # type: () -&gt; None
    """This clears the fallthrough override for this instruction.

    Alias for del self.fallthrough_override"""
    self.raw.clearFallThroughOverride()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.create" class="doc doc-heading">
            <code class="highlight language-python">create(address)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create an instruction at the given address.</p>
<p>Note: this will force ghidra to disassemble at the given address,
and return the created instruction. If you want to actually change the
instruction at the given address, use <code>assemble_at</code> instead.</p>
<p>If you want to just create an instruction object, use <code>assemble</code> method.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>The address where instruction should be created.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create(address):  # type: (Addr) -&gt; Instruction
    """Create an instruction at the given address.

    Note: this will force ghidra to disassemble at the given address,
    and return the created instruction. If you want to actually change the
    instruction at the given address, use `assemble_at` instead.

    If you want to just create an instruction object, use `assemble` method.

    :param address: The address where instruction should be created.
    """
    addr = resolve(address)
    disassemble(addr)
    return Instruction(addr)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.get" class="doc doc-heading">
            <code class="highlight language-python">get(address)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get an instruction at the address, or None if not found.</p>
<p>Note: This will return None if the instruction is not defined in Ghidra
at the given address. If you want to disassemble an address, not necessarily
defined in Ghidra, try :func:<code>disassemble_at</code> instead.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>The address of the instruction.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>The instruction at the address, or None if not found.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(address):  # type: (JavaObject|str|Addr) -&gt; Instruction|None
    """Get an instruction at the address, or None if not found.

    Note: This will return None if the instruction is not defined in Ghidra
    at the given address. If you want to disassemble an address, not necessarily
    defined in Ghidra, try :func:`disassemble_at` instead.

    :param address: The address of the instruction.
    :return: The instruction at the address, or None if not found."""
    if can_resolve(address):
        raw = getInstructionAt(resolve(address))
    else:
        raw = address
    if raw is None:
        return None
    return Instruction(raw)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.operand" class="doc doc-heading">
            <code class="highlight language-python">operand(ndx)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the nth operand of this instruction as an object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def operand(self, ndx):  # type: (int) -&gt; Operand
    """Get the nth operand of this instruction as an object."""
    operand = self.raw.getOpObjects(ndx)
    return self.__convert_operand(operand)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.set_fallthrough_override" class="doc doc-heading">
            <code class="highlight language-python">set_fallthrough_override(value)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Override the fallthrough address for this instruction.</p>
<p>This sets the next instruction that will be executed after this
instruction, assuming the current instruction doesn't jump anywhere.
You can clear this with clear_fallthrough_override</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>new fallthrough address</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_fallthrough_override(self, value):  # type: (Addr) -&gt; None
    """Override the fallthrough address for this instruction.

    This sets the next instruction that will be executed after this
    instruction, assuming the current instruction doesn't jump anywhere.
    You can clear this with clear_fallthrough_override

    :param value: new fallthrough address"""
    self.raw.setFallThrough(resolve(value))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Instruction.write_jumptable" class="doc doc-heading">
            <code class="highlight language-python">write_jumptable(targets)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Provide a list of addresses where this instruction may jump.</p>
<p>Warning: For this to work, the instruction must be a part of a function.</p>
<p>This is useful for fixing unrecognised switches, for example.</p>
<p>Note: the new switch instruction will use all references of type
COMPUTED_JUMP already defined for the instruction
(maybe we should clear them first?).</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_jumptable(self, targets):  # type: (list[Addr]) -&gt; None
    """Provide a list of addresses where this instruction may jump.

    Warning: For this to work, the instruction must be a part of a function.

    This is useful for fixing unrecognised switches, for example.

    Note: the new switch instruction will use all references of type
    COMPUTED_JUMP already defined for the instruction
    (maybe we should clear them first?)."""

    targets = [resolve(addr) for addr in targets]

    for dest in targets:
        disassemble(dest)
        self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP)

    func = Function.get(self.address)
    if func is None:
        raise RuntimeError("Instruction is not part of a function")

    targetlist = ArrayList([dest for dest in targets])
    jumpTab = JumpTable(toAddr(self.address), targetlist, True)
    jumpTab.writeOverride(func.raw)
    CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor())</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.JavaObject" class="doc doc-heading">
            <code>JavaObject</code>


</h2>


    <div class="doc doc-contents ">


        <p>A fake class, used for static type hints.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class JavaObject:
    """A fake class, used for static type hints."""

    def __getattribute__(self, name):  # type: (str) -&gt; Any
        """This attribute exists to make mypy happy."""
        pass</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ghidralib.JavaObject.__getattribute__" class="doc doc-heading">
            <code class="highlight language-python">__getattribute__(name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>This attribute exists to make mypy happy.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __getattribute__(self, name):  # type: (str) -&gt; Any
    """This attribute exists to make mypy happy."""
    pass</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.MemoryBlock" class="doc doc-heading">
            <code>MemoryBlock</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code>, <code><a class="autorefs autorefs-internal" title="BodyTrait (ghidralib.BodyTrait)" href="#ghidralib.BodyTrait">BodyTrait</a></code></p>


        <p>A Ghidra wrapper for a Ghidra MemoryBlock</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class MemoryBlock(GhidraWrapper, BodyTrait):
    """A Ghidra wrapper for a Ghidra MemoryBlock"""

    @staticmethod
    def get(raw_or_name):  # type: (JavaObject|str|Addr) -&gt; MemoryBlock|None
        """Gets a MemoryBlock by name or containing the given address.

        Note: for a string argument, this will try to get memoryblock by name, and
        if it fails, it will fall back to the regular behaviour of "resolve the symbol
        to the address, and get element by address

        :param raw_or_name: name or address of MemoryBlock to get
        :return: the MemoryBlock, or None if not found
        """
        memory = Program.current().getMemory()
        if isinstance(raw_or_name, str):
            raw = memory.getBlock(raw_or_name)
            if raw is not None:
                return MemoryBlock(raw)
        addr = try_resolve(raw_or_name)
        if addr is None:
            return None
        return MemoryBlock(memory.getBlock(addr))

    @staticmethod
    def all():  # type: () -&gt; list[MemoryBlock]
        """Get all MemoryBlocks in the current program"""
        raw_blocks = Program.current().getMemory().getBlocks()
        return [MemoryBlock(raw) for raw in raw_blocks]

    @property
    def comment(self):  # type: () -&gt; str
        """Get the comment associated with this MemoryBlock"""
        return self.raw.getComment()

    @property
    def start(self):  # type: () -&gt; int
        """Get the first address of this MemoryBlock"""
        return self.raw.getStart().getOffset()

    @property
    def name(self):  # type: () -&gt; str
        """Get the name of this MemoryBlock"""
        return self.raw.getName()

    address = start

    @property
    def end(self):  # type: () -&gt; int
        return self.raw.getEnd().getOffset()

    @property
    def size(self):  # type: () -&gt; int
        """Get the size of this MemoryBlock"""
        return int(self.raw.getSize())

    length = size

    @property
    def body(self):  # type: () -&gt; AddressSet
        """Get the address range this instruction."""
        return AddressSet.create(self.address, self.length)

    @property
    def bytes(self):  # type: () -&gt; bytes
        """Get the bytes of this instruction."""
        return read_bytes(self.address, self.length)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.address" class="doc doc-heading">
            <code class="highlight language-python">address = start</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.body" class="doc doc-heading">
            <code class="highlight language-python">body</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address range this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.bytes" class="doc doc-heading">
            <code class="highlight language-python">bytes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the bytes of this instruction.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.comment" class="doc doc-heading">
            <code class="highlight language-python">comment</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the comment associated with this MemoryBlock</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.end" class="doc doc-heading">
            <code class="highlight language-python">end</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.length" class="doc doc-heading">
            <code class="highlight language-python">length = size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the name of this MemoryBlock</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.size" class="doc doc-heading">
            <code class="highlight language-python">size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the size of this MemoryBlock</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.MemoryBlock.start" class="doc doc-heading">
            <code class="highlight language-python">start</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the first address of this MemoryBlock</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.MemoryBlock.all" class="doc doc-heading">
            <code class="highlight language-python">all()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all MemoryBlocks in the current program</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all():  # type: () -&gt; list[MemoryBlock]
    """Get all MemoryBlocks in the current program"""
    raw_blocks = Program.current().getMemory().getBlocks()
    return [MemoryBlock(raw) for raw in raw_blocks]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.MemoryBlock.get" class="doc doc-heading">
            <code class="highlight language-python">get(raw_or_name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Gets a MemoryBlock by name or containing the given address.</p>
<p>Note: for a string argument, this will try to get memoryblock by name, and
if it fails, it will fall back to the regular behaviour of "resolve the symbol
to the address, and get element by address</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>raw_or_name</code></b>
              –
              <div class="doc-md-description">
                <p>name or address of MemoryBlock to get</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>the MemoryBlock, or None if not found</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(raw_or_name):  # type: (JavaObject|str|Addr) -&gt; MemoryBlock|None
    """Gets a MemoryBlock by name or containing the given address.

    Note: for a string argument, this will try to get memoryblock by name, and
    if it fails, it will fall back to the regular behaviour of "resolve the symbol
    to the address, and get element by address

    :param raw_or_name: name or address of MemoryBlock to get
    :return: the MemoryBlock, or None if not found
    """
    memory = Program.current().getMemory()
    if isinstance(raw_or_name, str):
        raw = memory.getBlock(raw_or_name)
        if raw is not None:
            return MemoryBlock(raw)
    addr = try_resolve(raw_or_name)
    if addr is None:
        return None
    return MemoryBlock(memory.getBlock(addr))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Operand" class="doc doc-heading">
            <code>Operand</code>


</h2>


    <div class="doc doc-contents ">


        <p>Operand helper for instruction, may be a register, const or a list</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Operand:
    """Operand helper for instruction, may be a register, const or a list"""

    def __init__(self, operand):  # type: (str|int|list[int|str]) -&gt; None
        self.raw = operand

    @property
    def is_register(self):  # type: () -&gt; bool
        """Return True if this operand is a register."""
        return isinstance(self.raw, Str)

    @property
    def is_scalar(self):  # type: () -&gt; bool
        """Return True if this operand is a scalar."""
        return isinstance(self.raw, (int, long))

    @property
    def is_list(self):  # type: () -&gt; bool
        """Return True if this operand is a list."""
        return isinstance(self.raw, list)

    @property
    def register(self):  # type: () -&gt; str
        """Gets this operand value as a register name"""
        if not isinstance(self.raw, (str)):
            raise RuntimeError("Operand {} is not a register".format(self.raw))
        return self.raw

    @property
    def scalar(self):  # type: () -&gt; int
        """Gets this operand value as a scalar"""
        if not isinstance(self.raw, (int, long)):
            raise RuntimeError("Operand {} is not a scalar".format(self.raw))
        return self.raw

    @property
    def list(self):  # type: () -&gt; list
        """Gets this operand value as a list"""
        if not isinstance(self.raw, list):
            raise RuntimeError("Operand {} is not a list".format(self.raw))
        return self.raw

    @property
    def value(self):  # type: () -&gt; str|int|list[int|str]
        """Return internal representation of this operand - string, int or a list"""
        return self.raw</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.is_list" class="doc doc-heading">
            <code class="highlight language-python">is_list</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this operand is a list.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.is_register" class="doc doc-heading">
            <code class="highlight language-python">is_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this operand is a register.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.is_scalar" class="doc doc-heading">
            <code class="highlight language-python">is_scalar</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this operand is a scalar.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.list" class="doc doc-heading">
            <code class="highlight language-python">list</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Gets this operand value as a list</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.raw" class="doc doc-heading">
            <code class="highlight language-python">raw = operand</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.register" class="doc doc-heading">
            <code class="highlight language-python">register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Gets this operand value as a register name</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.scalar" class="doc doc-heading">
            <code class="highlight language-python">scalar</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Gets this operand value as a scalar</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Operand.value" class="doc doc-heading">
            <code class="highlight language-python">value</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return internal representation of this operand - string, int or a list</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Operand.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(operand)</code>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, operand):  # type: (str|int|list[int|str]) -&gt; None
    self.raw = operand</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Parameter" class="doc doc-heading">
            <code>Parameter</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Variable (ghidralib.Variable)" href="#ghidralib.Variable">Variable</a></code></p>


        <p>Wraps a Ghidra Parameter object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Parameter(Variable):
    """Wraps a Ghidra Parameter object."""

    @property
    def ordinal(self):  # type: () -&gt; int
        """Returns the ordinal of this parameter."""
        return self.raw.getOrdinal()

    @property
    def formal_data_type(self):  # type: () -&gt; DataType
        """Returns the formal data type of this parameter."""
        return DataType(self.raw.getFormalDataType())</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Parameter.formal_data_type" class="doc doc-heading">
            <code class="highlight language-python">formal_data_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the formal data type of this parameter.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Parameter.ordinal" class="doc doc-heading">
            <code class="highlight language-python">ordinal</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns the ordinal of this parameter.</p>

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.PcodeBlock" class="doc doc-heading">
            <code>PcodeBlock</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class PcodeBlock(GhidraWrapper):
    @property
    def outgoing_edges(self):  # type: () -&gt; list[PcodeBlock]
        return [_pcode_node(self.raw.getOut(i)) for i in range(self.raw.getOutSize())]

    @property
    def incoming_edges(self):  # type: () -&gt; list[PcodeBlock]
        return [_pcode_node(self.raw.getIn(i)) for i in range(self.raw.getInSize())]

    @property
    def has_children(self):  # type: () -&gt; bool
        """Returns True if this block has any children and can be iterated over.

        This function is necessary because Ghidra's code uses isinstance()
        checks to dispatch types. We return true for instances of Java BlockGraph."""
        return isinstance(self.raw, GhBlockGraph)

    @property
    def pcode(self):  # type: () -&gt; list[PcodeOp]
        raw_pcode = collect_iterator(self.raw.getRef().getIterator())
        return [PcodeOp(raw) for raw in raw_pcode]</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeBlock.has_children" class="doc doc-heading">
            <code class="highlight language-python">has_children</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns True if this block has any children and can be iterated over.</p>
<p>This function is necessary because Ghidra's code uses isinstance()
checks to dispatch types. We return true for instances of Java BlockGraph.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeBlock.incoming_edges" class="doc doc-heading">
            <code class="highlight language-python">incoming_edges</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeBlock.outgoing_edges" class="doc doc-heading">
            <code class="highlight language-python">outgoing_edges</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeBlock.pcode" class="doc doc-heading">
            <code class="highlight language-python">pcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.PcodeOp" class="doc doc-heading">
            <code>PcodeOp</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Pcode is a Ghidra's low-level intermediate language.
Instructions from any processor are transformed into PCode
before any analysis takes place. There is a finite number of
possible operations.</p>
<p>While Ghidra doesn't define "High Pcode", this library refers
to analysed Pcode as "High Pcode". While theoretically still
the same object, Pcode is transformed significantly, for example
before function parameter analysis "CALL" opcodes have no inputs.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class PcodeOp(GhidraWrapper):
    """Pcode is a Ghidra's low-level intermediate language.
    Instructions from any processor are transformed into PCode
    before any analysis takes place. There is a finite number of
    possible operations.

    While Ghidra doesn't define "High Pcode", this library refers
    to analysed Pcode as "High Pcode". While theoretically still
    the same object, Pcode is transformed significantly, for example
    before function parameter analysis "CALL" opcodes have no inputs.
    """

    UNIMPLEMENTED = 0
    COPY = 1
    LOAD = 2
    STORE = 3
    BRANCH = 4
    CBRANCH = 5
    BRANCHIND = 6
    CALL = 7
    CALLIND = 8
    CALLOTHER = 9
    RETURN = 10
    INT_EQUAL = 11
    INT_NOTEQUAL = 12
    INT_SLESS = 13
    INT_SLESSEQUAL = 14
    INT_LESS = 15
    INT_LESSEQUAL = 16
    INT_ZEXT = 17
    INT_SEXT = 18
    INT_ADD = 19
    INT_SUB = 20
    INT_CARRY = 21
    INT_SCARRY = 22
    INT_SBORROW = 23
    INT_2COMP = 24
    INT_NEGATE = 25
    INT_XOR = 26
    INT_AND = 27
    INT_OR = 28
    INT_LEFT = 29
    INT_RIGHT = 30
    INT_SRIGHT = 31
    INT_MULT = 32
    INT_DIV = 33
    INT_SDIV = 34
    INT_REM = 35
    INT_SREM = 36
    BOOL_NEGATE = 37
    BOOL_XOR = 38
    BOOL_AND = 39
    BOOL_OR = 40
    FLOAT_EQUAL = 41
    FLOAT_NOTEQUAL = 42
    FLOAT_LESS = 43
    FLOAT_LESSEQUAL = 44
    # Slot 45 is unused
    FLOAT_NAN = 46
    FLOAT_ADD = 47
    FLOAT_DIV = 48
    FLOAT_MULT = 49
    FLOAT_SUB = 50
    FLOAT_NEG = 51
    FLOAT_ABS = 52
    FLOAT_SQRT = 53
    FLOAT_INT2FLOAT = 54
    FLOAT_FLOAT2FLOAT = 55
    FLOAT_TRUNC = 56
    FLOAT_CEIL = 57
    FLOAT_FLOOR = 58
    FLOAT_ROUND = 59
    MULTIEQUAL = 60
    INDIRECT = 61
    PIECE = 62
    SUBPIECE = 63
    CAST = 64
    PTRADD = 65
    PTRSUB = 66
    SEGMENTOP = 67
    CPOOLREF = 68
    NEW = 69
    INSERT = 70
    EXTRACT = 71
    POPCOUNT = 72
    LZCOUNT = 73
    PCODE_MAX = 74

    @staticmethod
    def get_high_pcode_at(address):  # type: (Addr) -&gt; list[PcodeOp]
        """Get a high pcode for the instruction at a specified address

        Convenience wrapper for Function(address).get_high_pcode_at(address)."""
        return Function(address).get_high_pcode_at(address)

    @property
    def address(self):  # type: () -&gt; int
        """Get an address in the program where this instruction is located"""
        return self.raw.getSeqnum().getTarget().getOffset()

    @property
    def opcode(self):  # type: () -&gt; int
        return self.raw.getOpcode()

    @property
    def mnemonic(self):  # type: () -&gt; str
        """Get a string representation of the operation, for example "COPY" """
        return self.raw.getMnemonic()

    @property
    def inputs(self):  # type: () -&gt; list[Varnode]
        return [Varnode(raw) for raw in self.raw.getInputs()]

    @property
    def inputs_simple(self):  # type: () -&gt; list[int|str]
        """Return inputs as primitive values (int or a string representation).

        More specifically, this will convert constants and addresses into integers,
        for registers names are returned, and for unique and hash varnodes ad-hoc
        string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).
        """
        return [varnode.simple for varnode in self.inputs]

    @property
    def output(self):  # type: () -&gt; Varnode|None
        if self.raw.getOutput() is None:
            return None
        return Varnode(self.raw.getOutput())

    @property
    def result(self):  # type: () -&gt; int|None
        """Try to evaluate the pcode operation to a constant value.

        Right now this is very poor and doesn't try to implement most of the opcodes.
        Mostly because I suspect I'm reinventing the wheel, and there is code to do
        this already in Ghidra.

        :return: Result of this operation, or None if can't be evaluated as const."""
        if self.opcode == PcodeOp.COPY:
            return self.inputs[0].value
        return None</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BOOL_AND" class="doc doc-heading">
            <code class="highlight language-python">BOOL_AND = 39</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BOOL_NEGATE" class="doc doc-heading">
            <code class="highlight language-python">BOOL_NEGATE = 37</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BOOL_OR" class="doc doc-heading">
            <code class="highlight language-python">BOOL_OR = 40</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BOOL_XOR" class="doc doc-heading">
            <code class="highlight language-python">BOOL_XOR = 38</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BRANCH" class="doc doc-heading">
            <code class="highlight language-python">BRANCH = 4</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.BRANCHIND" class="doc doc-heading">
            <code class="highlight language-python">BRANCHIND = 6</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CALL" class="doc doc-heading">
            <code class="highlight language-python">CALL = 7</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CALLIND" class="doc doc-heading">
            <code class="highlight language-python">CALLIND = 8</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CALLOTHER" class="doc doc-heading">
            <code class="highlight language-python">CALLOTHER = 9</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CAST" class="doc doc-heading">
            <code class="highlight language-python">CAST = 64</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CBRANCH" class="doc doc-heading">
            <code class="highlight language-python">CBRANCH = 5</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.COPY" class="doc doc-heading">
            <code class="highlight language-python">COPY = 1</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.CPOOLREF" class="doc doc-heading">
            <code class="highlight language-python">CPOOLREF = 68</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.EXTRACT" class="doc doc-heading">
            <code class="highlight language-python">EXTRACT = 71</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_ABS" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_ABS = 52</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_ADD" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_ADD = 47</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_CEIL" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_CEIL = 57</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_DIV" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_DIV = 48</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_EQUAL" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_EQUAL = 41</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_FLOAT2FLOAT = 55</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_FLOOR" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_FLOOR = 58</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_INT2FLOAT" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_INT2FLOAT = 54</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_LESS" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_LESS = 43</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_LESSEQUAL" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_LESSEQUAL = 44</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_MULT" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_MULT = 49</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_NAN" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_NAN = 46</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_NEG" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_NEG = 51</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_NOTEQUAL" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_NOTEQUAL = 42</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_ROUND" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_ROUND = 59</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_SQRT" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_SQRT = 53</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_SUB" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_SUB = 50</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.FLOAT_TRUNC" class="doc doc-heading">
            <code class="highlight language-python">FLOAT_TRUNC = 56</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INDIRECT" class="doc doc-heading">
            <code class="highlight language-python">INDIRECT = 61</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INSERT" class="doc doc-heading">
            <code class="highlight language-python">INSERT = 70</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_2COMP" class="doc doc-heading">
            <code class="highlight language-python">INT_2COMP = 24</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_ADD" class="doc doc-heading">
            <code class="highlight language-python">INT_ADD = 19</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_AND" class="doc doc-heading">
            <code class="highlight language-python">INT_AND = 27</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_CARRY" class="doc doc-heading">
            <code class="highlight language-python">INT_CARRY = 21</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_DIV" class="doc doc-heading">
            <code class="highlight language-python">INT_DIV = 33</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_EQUAL" class="doc doc-heading">
            <code class="highlight language-python">INT_EQUAL = 11</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_LEFT" class="doc doc-heading">
            <code class="highlight language-python">INT_LEFT = 29</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_LESS" class="doc doc-heading">
            <code class="highlight language-python">INT_LESS = 15</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_LESSEQUAL" class="doc doc-heading">
            <code class="highlight language-python">INT_LESSEQUAL = 16</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_MULT" class="doc doc-heading">
            <code class="highlight language-python">INT_MULT = 32</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_NEGATE" class="doc doc-heading">
            <code class="highlight language-python">INT_NEGATE = 25</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_NOTEQUAL" class="doc doc-heading">
            <code class="highlight language-python">INT_NOTEQUAL = 12</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_OR" class="doc doc-heading">
            <code class="highlight language-python">INT_OR = 28</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_REM" class="doc doc-heading">
            <code class="highlight language-python">INT_REM = 35</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_RIGHT" class="doc doc-heading">
            <code class="highlight language-python">INT_RIGHT = 30</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SBORROW" class="doc doc-heading">
            <code class="highlight language-python">INT_SBORROW = 23</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SCARRY" class="doc doc-heading">
            <code class="highlight language-python">INT_SCARRY = 22</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SDIV" class="doc doc-heading">
            <code class="highlight language-python">INT_SDIV = 34</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SEXT" class="doc doc-heading">
            <code class="highlight language-python">INT_SEXT = 18</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SLESS" class="doc doc-heading">
            <code class="highlight language-python">INT_SLESS = 13</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SLESSEQUAL" class="doc doc-heading">
            <code class="highlight language-python">INT_SLESSEQUAL = 14</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SREM" class="doc doc-heading">
            <code class="highlight language-python">INT_SREM = 36</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SRIGHT" class="doc doc-heading">
            <code class="highlight language-python">INT_SRIGHT = 31</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_SUB" class="doc doc-heading">
            <code class="highlight language-python">INT_SUB = 20</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_XOR" class="doc doc-heading">
            <code class="highlight language-python">INT_XOR = 26</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.INT_ZEXT" class="doc doc-heading">
            <code class="highlight language-python">INT_ZEXT = 17</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.LOAD" class="doc doc-heading">
            <code class="highlight language-python">LOAD = 2</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.LZCOUNT" class="doc doc-heading">
            <code class="highlight language-python">LZCOUNT = 73</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.MULTIEQUAL" class="doc doc-heading">
            <code class="highlight language-python">MULTIEQUAL = 60</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.NEW" class="doc doc-heading">
            <code class="highlight language-python">NEW = 69</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.PCODE_MAX" class="doc doc-heading">
            <code class="highlight language-python">PCODE_MAX = 74</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.PIECE" class="doc doc-heading">
            <code class="highlight language-python">PIECE = 62</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.POPCOUNT" class="doc doc-heading">
            <code class="highlight language-python">POPCOUNT = 72</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.PTRADD" class="doc doc-heading">
            <code class="highlight language-python">PTRADD = 65</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.PTRSUB" class="doc doc-heading">
            <code class="highlight language-python">PTRSUB = 66</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.RETURN" class="doc doc-heading">
            <code class="highlight language-python">RETURN = 10</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.SEGMENTOP" class="doc doc-heading">
            <code class="highlight language-python">SEGMENTOP = 67</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.STORE" class="doc doc-heading">
            <code class="highlight language-python">STORE = 3</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.SUBPIECE" class="doc doc-heading">
            <code class="highlight language-python">SUBPIECE = 63</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.UNIMPLEMENTED" class="doc doc-heading">
            <code class="highlight language-python">UNIMPLEMENTED = 0</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get an address in the program where this instruction is located</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.inputs" class="doc doc-heading">
            <code class="highlight language-python">inputs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.inputs_simple" class="doc doc-heading">
            <code class="highlight language-python">inputs_simple</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return inputs as primitive values (int or a string representation).</p>
<p>More specifically, this will convert constants and addresses into integers,
for registers names are returned, and for unique and hash varnodes ad-hoc
string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.mnemonic" class="doc doc-heading">
            <code class="highlight language-python">mnemonic</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a string representation of the operation, for example "COPY"</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.opcode" class="doc doc-heading">
            <code class="highlight language-python">opcode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.output" class="doc doc-heading">
            <code class="highlight language-python">output</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.PcodeOp.result" class="doc doc-heading">
            <code class="highlight language-python">result</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Try to evaluate the pcode operation to a constant value.</p>
<p>Right now this is very poor and doesn't try to implement most of the opcodes.
Mostly because I suspect I'm reinventing the wheel, and there is code to do
this already in Ghidra.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>Result of this operation, or None if can't be evaluated as const.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.PcodeOp.get_high_pcode_at" class="doc doc-heading">
            <code class="highlight language-python">get_high_pcode_at(address)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a high pcode for the instruction at a specified address</p>
<p>Convenience wrapper for Function(address).get_high_pcode_at(address).</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get_high_pcode_at(address):  # type: (Addr) -&gt; list[PcodeOp]
    """Get a high pcode for the instruction at a specified address

    Convenience wrapper for Function(address).get_high_pcode_at(address)."""
    return Function(address).get_high_pcode_at(address)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Program" class="doc doc-heading">
            <code>Program</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>A static class that represents the current program</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Program(GhidraWrapper):
    """A static class that represents the current program"""

    @staticmethod
    def create_data(address, datatype):  # type: (Addr, DataT) -&gt; None
        """Force the type of the data defined at the given address to `datatype`.

        This function will clear the old type if it already has one

        :param address: address of the data.
        :param datatype: datatype to use for the data at `address`."""
        typeobj = DataType(datatype)
        addr = resolve(address)
        try:
            createData(addr, unwrap(typeobj))
        except:
            clearListing(addr, addr.add(len(typeobj) - 1))
            createData(addr, unwrap(typeobj))

    @staticmethod
    def location():  # type: () -&gt; int
        """Get the current location in the program.

            &gt;&gt;&gt; current_location()
            0x1000

        :return: the current location in the program
        """
        return getState().getCurrentLocation().getAddress().getOffset()

    @staticmethod
    def call_graph():  # type: () -&gt; Graph[Function]
        """Get the call graph for this program."""
        return Graph.construct(Function.all(), lambda f: f.called)

    @staticmethod
    def control_flow():  # type: () -&gt; Graph[BasicBlock]
        """Get a graph representing the whole program control flow.

        Warning: This graph may be big, so don't try to display it."""
        return Graph.construct(BasicBlock.all(), lambda b: b.destinations)

    @staticmethod
    def basicblocks():  # type: () -&gt; list[BasicBlock]
        """Get all the basic blocks defined in the program."""
        return BasicBlock.all()

    @staticmethod
    def memory_blocks():  # type: () -&gt; list[MemoryBlock]
        """Get memory blocks defined for the current program."""
        return MemoryBlock.all()

    @staticmethod
    def functions():  # type: () -&gt; list[Function]
        """Get all the functions defined in the program."""
        return Function.all()

    @staticmethod
    def instructions():  # type: () -&gt; list[Instruction]
        """Get all the instructions defined in the program."""
        return Instruction.all()

    @staticmethod
    def body():  # type: () -&gt; AddressSet
        """Get the set of all addresses of the program."""
        body = Program.current().getNamespaceManager().getGlobalNamespace().getBody()
        return AddressSet(body)

    @staticmethod
    def current():  # type: () -&gt; JavaObject
        """Get the current program. Equivalent to getCurrentProgram()

        This method must be used instead of currentProgram, because the latter
        won't work well if user is using multiple programs at the same time
        (for example, many tabs in the same tool)."""
        return getCurrentProgram()

    @staticmethod
    def analyze():  # type: () -&gt; None
        """Analyze changes. This will block when autoanalysis changes place.

        Run this when you did changes that you will need to proceed with the rest
        of the script."""
        analyzeChanges(Program.current())</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.analyze" class="doc doc-heading">
            <code class="highlight language-python">analyze()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Analyze changes. This will block when autoanalysis changes place.</p>
<p>Run this when you did changes that you will need to proceed with the rest
of the script.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def analyze():  # type: () -&gt; None
    """Analyze changes. This will block when autoanalysis changes place.

    Run this when you did changes that you will need to proceed with the rest
    of the script."""
    analyzeChanges(Program.current())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.basicblocks" class="doc doc-heading">
            <code class="highlight language-python">basicblocks()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all the basic blocks defined in the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def basicblocks():  # type: () -&gt; list[BasicBlock]
    """Get all the basic blocks defined in the program."""
    return BasicBlock.all()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.body" class="doc doc-heading">
            <code class="highlight language-python">body()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the set of all addresses of the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def body():  # type: () -&gt; AddressSet
    """Get the set of all addresses of the program."""
    body = Program.current().getNamespaceManager().getGlobalNamespace().getBody()
    return AddressSet(body)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.call_graph" class="doc doc-heading">
            <code class="highlight language-python">call_graph()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the call graph for this program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def call_graph():  # type: () -&gt; Graph[Function]
    """Get the call graph for this program."""
    return Graph.construct(Function.all(), lambda f: f.called)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.control_flow" class="doc doc-heading">
            <code class="highlight language-python">control_flow()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a graph representing the whole program control flow.</p>
<p>Warning: This graph may be big, so don't try to display it.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def control_flow():  # type: () -&gt; Graph[BasicBlock]
    """Get a graph representing the whole program control flow.

    Warning: This graph may be big, so don't try to display it."""
    return Graph.construct(BasicBlock.all(), lambda b: b.destinations)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.create_data" class="doc doc-heading">
            <code class="highlight language-python">create_data(address, datatype)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Force the type of the data defined at the given address to <code>datatype</code>.</p>
<p>This function will clear the old type if it already has one</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address of the data.</p>
              </div>
            </li>
            <li>
              <b><code>datatype</code></b>
              –
              <div class="doc-md-description">
                <p>datatype to use for the data at <code>address</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create_data(address, datatype):  # type: (Addr, DataT) -&gt; None
    """Force the type of the data defined at the given address to `datatype`.

    This function will clear the old type if it already has one

    :param address: address of the data.
    :param datatype: datatype to use for the data at `address`."""
    typeobj = DataType(datatype)
    addr = resolve(address)
    try:
        createData(addr, unwrap(typeobj))
    except:
        clearListing(addr, addr.add(len(typeobj) - 1))
        createData(addr, unwrap(typeobj))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.current" class="doc doc-heading">
            <code class="highlight language-python">current()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the current program. Equivalent to getCurrentProgram()</p>
<p>This method must be used instead of currentProgram, because the latter
won't work well if user is using multiple programs at the same time
(for example, many tabs in the same tool).</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def current():  # type: () -&gt; JavaObject
    """Get the current program. Equivalent to getCurrentProgram()

    This method must be used instead of currentProgram, because the latter
    won't work well if user is using multiple programs at the same time
    (for example, many tabs in the same tool)."""
    return getCurrentProgram()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.functions" class="doc doc-heading">
            <code class="highlight language-python">functions()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all the functions defined in the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def functions():  # type: () -&gt; list[Function]
    """Get all the functions defined in the program."""
    return Function.all()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.instructions" class="doc doc-heading">
            <code class="highlight language-python">instructions()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all the instructions defined in the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def instructions():  # type: () -&gt; list[Instruction]
    """Get all the instructions defined in the program."""
    return Instruction.all()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.location" class="doc doc-heading">
            <code class="highlight language-python">location()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the current location in the program.</p>
<pre><code>&gt;&gt;&gt; current_location()
0x1000
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>the current location in the program</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def location():  # type: () -&gt; int
    """Get the current location in the program.

        &gt;&gt;&gt; current_location()
        0x1000

    :return: the current location in the program
    """
    return getState().getCurrentLocation().getAddress().getOffset()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Program.memory_blocks" class="doc doc-heading">
            <code class="highlight language-python">memory_blocks()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get memory blocks defined for the current program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def memory_blocks():  # type: () -&gt; list[MemoryBlock]
    """Get memory blocks defined for the current program."""
    return MemoryBlock.all()</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.RefType" class="doc doc-heading">
            <code>RefType</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class RefType(GhidraWrapper):
    @property
    def has_fallthrough(self):  # type: () -&gt; bool
        return self.raw.hasFallthrough()

    @has_fallthrough.setter
    def has_fallthrough(self, value):  # type: (bool) -&gt; None
        self.raw.setHasFall(value)

    @property
    def is_call(self):  # type: () -&gt; bool
        return self.raw.isCall()

    @is_call.setter
    def is_call(self, value):  # type: (bool) -&gt; None
        self.raw.setIsCall(value)

    @property
    def is_jump(self):  # type: () -&gt; bool
        return self.raw.isJump()

    @is_jump.setter
    def is_jump(self, value):  # type: (bool) -&gt; None
        self.raw.setIsJump(value)

    @property
    def is_computed(self):  # type: () -&gt; bool
        return self.raw.isComputed()

    @is_computed.setter
    def is_computed(self, value):  # type: (bool) -&gt; None
        self.raw.setIsComputed(value)

    @property
    def is_conditional(self):  # type: () -&gt; bool
        return self.raw.isConditional()

    @is_conditional.setter
    def is_conditional(self, value):  # type: (bool) -&gt; None
        self.raw.setIsConditional(value)

    @property
    def is_unconditional(self):  # type: () -&gt; bool
        return not self.is_conditional

    @property
    def is_terminal(self):  # type: () -&gt; bool
        return self.raw.isTerminal()

    @property
    def is_data(self):  # type: () -&gt; bool
        return self.raw.isData()

    @property
    def is_read(self):  # type: () -&gt; bool
        return self.raw.isRead()

    @property
    def is_write(self):  # type: () -&gt; bool
        return self.raw.isWrite()

    @property
    def is_flow(self):  # type: () -&gt; bool
        return self.raw.isFlow()

    @property
    def is_override(self):  # type: () -&gt; bool
        return self.raw.isOverride()

    INVALID = _reftype_placeholder()
    FLOW = _reftype_placeholder()
    FALL_THROUGH = _reftype_placeholder()
    UNCONDITIONAL_JUMP = _reftype_placeholder()
    CONDITIONAL_JUMP = _reftype_placeholder()
    UNCONDITIONAL_CALL = _reftype_placeholder()
    CONDITIONAL_CALL = _reftype_placeholder()
    TERMINATOR = _reftype_placeholder()
    COMPUTED_JUMP = _reftype_placeholder()
    CONDITIONAL_TERMINATOR = _reftype_placeholder()
    COMPUTED_CALL = _reftype_placeholder()
    CALL_TERMINATOR = _reftype_placeholder()
    COMPUTED_CALL_TERMINATOR = _reftype_placeholder()
    CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder()
    CONDITIONAL_COMPUTED_CALL = _reftype_placeholder()
    CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder()
    JUMP_TERMINATOR = _reftype_placeholder()
    INDIRECTION = _reftype_placeholder()
    CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder()
    JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder()
    CALLOTHER_OVERRIDE_CALL = _reftype_placeholder()
    CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder()</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CALLOTHER_OVERRIDE_CALL" class="doc doc-heading">
            <code class="highlight language-python">CALLOTHER_OVERRIDE_CALL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP" class="doc doc-heading">
            <code class="highlight language-python">CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL" class="doc doc-heading">
            <code class="highlight language-python">CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CALL_TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">CALL_TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.COMPUTED_CALL" class="doc doc-heading">
            <code class="highlight language-python">COMPUTED_CALL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.COMPUTED_CALL_TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">COMPUTED_CALL_TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.COMPUTED_JUMP" class="doc doc-heading">
            <code class="highlight language-python">COMPUTED_JUMP = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_CALL" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_CALL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_COMPUTED_CALL" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_COMPUTED_CALL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_JUMP" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_JUMP = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.CONDITIONAL_TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">CONDITIONAL_TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.FALL_THROUGH" class="doc doc-heading">
            <code class="highlight language-python">FALL_THROUGH = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.FLOW" class="doc doc-heading">
            <code class="highlight language-python">FLOW = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.INDIRECTION" class="doc doc-heading">
            <code class="highlight language-python">INDIRECTION = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.INVALID" class="doc doc-heading">
            <code class="highlight language-python">INVALID = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL" class="doc doc-heading">
            <code class="highlight language-python">JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.JUMP_TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">JUMP_TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.TERMINATOR" class="doc doc-heading">
            <code class="highlight language-python">TERMINATOR = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.UNCONDITIONAL_CALL" class="doc doc-heading">
            <code class="highlight language-python">UNCONDITIONAL_CALL = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.UNCONDITIONAL_JUMP" class="doc doc-heading">
            <code class="highlight language-python">UNCONDITIONAL_JUMP = _reftype_placeholder()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.has_fallthrough" class="doc doc-heading">
            <code class="highlight language-python">has_fallthrough</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_call" class="doc doc-heading">
            <code class="highlight language-python">is_call</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_computed" class="doc doc-heading">
            <code class="highlight language-python">is_computed</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_conditional" class="doc doc-heading">
            <code class="highlight language-python">is_conditional</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_data" class="doc doc-heading">
            <code class="highlight language-python">is_data</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_flow" class="doc doc-heading">
            <code class="highlight language-python">is_flow</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_jump" class="doc doc-heading">
            <code class="highlight language-python">is_jump</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_override" class="doc doc-heading">
            <code class="highlight language-python">is_override</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_read" class="doc doc-heading">
            <code class="highlight language-python">is_read</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_terminal" class="doc doc-heading">
            <code class="highlight language-python">is_terminal</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_unconditional" class="doc doc-heading">
            <code class="highlight language-python">is_unconditional</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.RefType.is_write" class="doc doc-heading">
            <code class="highlight language-python">is_write</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Reference" class="doc doc-heading">
            <code>Reference</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Reference(GhidraWrapper):
    @property
    def is_call(self):  # type: () -&gt; bool
        """Return True if the reference is a call."""
        return self.reftype.is_call

    @property
    def is_jump(self):  # type: () -&gt; bool
        """Return True if the reference is a jump."""
        return self.reftype.is_jump

    @property
    def reftype(self):  # type: () -&gt; RefType
        """Return the type of reference."""
        return RefType(self.raw.getReferenceType())

    @property
    def from_address(self):  # type: () -&gt; int
        """Return the address of the source of the reference."""
        return self.raw.getFromAddress().getOffset()

    @property
    def to_address(self):  # type: () -&gt; int
        """Return the address of the target of the reference."""
        return self.raw.getToAddress().getOffset()

    @property
    def source(self):  # type: () -&gt; SourceType
        return SourceType(self.raw.getSource())</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.from_address" class="doc doc-heading">
            <code class="highlight language-python">from_address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the address of the source of the reference.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.is_call" class="doc doc-heading">
            <code class="highlight language-python">is_call</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the reference is a call.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.is_jump" class="doc doc-heading">
            <code class="highlight language-python">is_jump</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if the reference is a jump.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.reftype" class="doc doc-heading">
            <code class="highlight language-python">reftype</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the type of reference.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.source" class="doc doc-heading">
            <code class="highlight language-python">source</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Reference.to_address" class="doc doc-heading">
            <code class="highlight language-python">to_address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the address of the target of the reference.</p>

    </div>

</div>





  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Register" class="doc doc-heading">
            <code>Register</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Register(GhidraWrapper):
    @staticmethod
    def get(raw_or_name):  # type: (str|JavaObject) -&gt; Register|None
        """Get a register by name"""
        if isinstance(raw_or_name, Str):
            raw_or_name = Program.current().getLanguage().getRegister(raw_or_name)
            if raw_or_name is None:
                return None
        return Register(raw_or_name)

    @property
    def name(self):  # type: () -&gt; str
        """Return the name of this register"""
        return self.raw.getName()

    @property
    def size(self):  # type: () -&gt; int
        """Return the size of this register in bytes

        This will tell the total number of bytes this register contains -
        because register values don't have to be byte-aligned"""
        return self.raw.getNumBytes()

    @property
    def varnode(self):  # type: () -&gt; Varnode
        """Return the varnode associated with this register

        Warning: this doesn't support registers that are not byte-aligned
        (for example, flag registers). It will round the address down to byte.
        """
        raw = GhVarnode(self.raw.getAddress(), self.raw.getNumBytes())
        return Varnode(raw)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Register.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the name of this register</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Register.size" class="doc doc-heading">
            <code class="highlight language-python">size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the size of this register in bytes</p>
<p>This will tell the total number of bytes this register contains -
because register values don't have to be byte-aligned</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Register.varnode" class="doc doc-heading">
            <code class="highlight language-python">varnode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the varnode associated with this register</p>
<p>Warning: this doesn't support registers that are not byte-aligned
(for example, flag registers). It will round the address down to byte.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Register.get" class="doc doc-heading">
            <code class="highlight language-python">get(raw_or_name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a register by name</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(raw_or_name):  # type: (str|JavaObject) -&gt; Register|None
    """Get a register by name"""
    if isinstance(raw_or_name, Str):
        raw_or_name = Program.current().getLanguage().getRegister(raw_or_name)
        if raw_or_name is None:
            return None
    return Register(raw_or_name)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Symbol" class="doc doc-heading">
            <code>Symbol</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra Symbol object.</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Symbol(GhidraWrapper):
    """Wraps a Ghidra Symbol object."""

    @staticmethod
    def resolve_thunk_if_exists(external_symbol):  # type: (JavaObject) -&gt; JavaObject
        """Returns a function thunk leading to a passed external symbol, if it exists.

        If there is no function thunk, original symbol is returned.

        Why is this ugly thing here? Well, we want to support external symbols,
        especially external functions. Thunks are much more useful for us when
        thinking in context of the analysed program - when Linux program calls
        `printf` it jumps to the appropriate `printf` thunk, not to libc
        directly. So this is the location that we want to patch/hook/trace/etc when
        thinking about printf. But the thing is that Ghidra SymbolTable API will
        not even return thunks! So we trace the external function references, and
        return the first (almost certainly only) Thunk reference.

        :param external_symbol: Symbol to find thunk for (if it exists).
        """
        xrefs = list(external_symbol.getReferences())
        for xref in xrefs:
            if xref.getReferenceType() == GhRefType.THUNK:
                addr = xref.getFromAddress()
                thunk = Program.current().getSymbolTable().getPrimarySymbol(addr)
                if thunk is not None:
                    return thunk
        return external_symbol

    @staticmethod
    def resolve_external(external_symbol):  # type: (JavaObject) -&gt; int
        """Resolves an external address to a RAM location, if possible.

        If the symbol has no RAM location, just return its offset.

        Why is this ugly thing here? Again, we want to support external symbols, and
        we are interested in their RAM address in the program address space. In some
        cases, Ghidra will give an external address a "location" in the RAM space.
        So, for example, if current program jumps to that external function (or read
        that external variable etc), it will read that location as far as Ghidra is
        concerned (for example, Emulator will use it for calls). This is important
        for emulating Windows binaries, that use address tables for imports.

        :param external_symbol: External symbol to resolve."""
        external_manager = Program.current().getExternalManager()
        ram_addr = external_manager.getExternalLocation(external_symbol).getAddress()
        if ram_addr:
            return ram_addr.getOffset()
        return external_symbol.getAddress().getOffset()

    @staticmethod
    def get(raw_or_name):  # type: (JavaObject|str|Addr) -&gt; Symbol|None
        """Get a symbol with the provided name or at the provided address.

        Return None if the symbol was not found.

        Note: when resolving by name, local symbols take precedence over external ones
        (in particular for function thunks - in contrast to Ghidra default behaviour).

        :param raw_or_name: a Ghidra Java object, a string, or an address."""
        if isinstance(raw_or_name, str):
            symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name)
            symbols = collect_iterator(symbol_iterator)
            if not symbols:
                return None
            raw = symbols[0]
            if raw.isExternal():
                raw = Symbol.resolve_thunk_if_exists(raw)
        elif can_resolve(raw_or_name):
            raw = (
                Program.current()
                .getSymbolTable()
                .getPrimarySymbol(resolve(raw_or_name))
            )
            if not raw:
                return None
        else:
            raw = raw_or_name
        return Symbol(raw)

    @staticmethod
    def all():  # type: () -&gt; list[Symbol]
        """Get all symbols defined in the program."""
        symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True)
        symbols = collect_iterator(symbol_iterator)
        return [Symbol(s) for s in symbols]

    @staticmethod
    def create(
        address, name, source=SourceType.USER_DEFINED
    ):  # type: (Addr, str, SourceType) -&gt; Symbol
        """Create a new symbol (also called label) at the given address.

        :param address: the address where to create the symbol.
        :param name: the name of the symbol.
        :param source: the source type for the new symbol."""
        raw = createLabel(resolve(address), name, False, source)
        return Symbol(raw)

    @staticmethod
    def remove(address, name):  # type: (Addr, str) -&gt; None
        """Remove the symbol with the given name at the given address.

        :param address: the address of the symbol to remove.
        :param name: the name of the symbol to remove."""
        removeSymbol(resolve(address), name)

    @property
    def address(self):  # type: () -&gt; int
        """Get the address of this symbol."""
        if self.is_external:
            return Symbol.resolve_external(self.raw)
        return self.raw.getAddress().getOffset()

    @property
    def name(self):  # type: () -&gt; str
        """Get the name of this symbol."""
        return self.raw.getName()

    @property
    def name_with_namespace(self):  # type: () -&gt; str
        """Get the fully qualified name of this symbol."""
        return self.raw.getName(True)

    @property
    def xrefs(self):  # type: () -&gt; list[Reference]
        """Get a list of references to this symbol."""
        return [Reference(raw) for raw in self.raw.getReferences()]

    xrefs_to = xrefs

    @property
    def xref_addrs(self):  # type: () -&gt; list[int]
        """Get the addresses of all references to this symbol."""
        return [xref.from_address for xref in self.xrefs]

    def set_type(self, datatype):  # type: (DataT) -&gt; None
        """Set the data type of this symbol."""
        Program.create_data(self.address, datatype)

    def delete(self):  # type: () -&gt; None
        """Delete this symbol."""
        self.raw.delete()

    def rename(
        self, new_name, source=SourceType.USER_DEFINED
    ):  # type: (str, SourceType) -&gt; None
        """Rename this symbol.

            &gt;&gt;&gt; main = Symbol.get("main")
            &gt;&gt;&gt; main.rename("main_renamed")
            &gt;&gt;&gt; main.name
            'main_renamed'

        :param new_name: the new name of the symbol."""
        self.raw.setName(new_name, source)

    @property
    def is_external(self):  # type: () -&gt; bool
        """Return true if this symbol is external, otherwise false.

        Note: when resolving by name, local symbols take precedence over external ones
        (in particular for function thunks - in contrast to Ghidra default behaviour).

        :return: true if the symbol is external"""
        return self.raw.isExternal()</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.address" class="doc doc-heading">
            <code class="highlight language-python">address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the address of this symbol.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.is_external" class="doc doc-heading">
            <code class="highlight language-python">is_external</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return true if this symbol is external, otherwise false.</p>
<p>Note: when resolving by name, local symbols take precedence over external ones
(in particular for function thunks - in contrast to Ghidra default behaviour).</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>true if the symbol is external</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the name of this symbol.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.name_with_namespace" class="doc doc-heading">
            <code class="highlight language-python">name_with_namespace</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the fully qualified name of this symbol.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.xref_addrs" class="doc doc-heading">
            <code class="highlight language-python">xref_addrs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the addresses of all references to this symbol.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.xrefs" class="doc doc-heading">
            <code class="highlight language-python">xrefs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a list of references to this symbol.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Symbol.xrefs_to" class="doc doc-heading">
            <code class="highlight language-python">xrefs_to = xrefs</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.all" class="doc doc-heading">
            <code class="highlight language-python">all()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all symbols defined in the program.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def all():  # type: () -&gt; list[Symbol]
    """Get all symbols defined in the program."""
    symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True)
    symbols = collect_iterator(symbol_iterator)
    return [Symbol(s) for s in symbols]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.create" class="doc doc-heading">
            <code class="highlight language-python">create(address, name, source=SourceType.USER_DEFINED)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Create a new symbol (also called label) at the given address.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address where to create the symbol.</p>
              </div>
            </li>
            <li>
              <b><code>name</code></b>
              –
              <div class="doc-md-description">
                <p>the name of the symbol.</p>
              </div>
            </li>
            <li>
              <b><code>source</code></b>
              –
              <div class="doc-md-description">
                <p>the source type for the new symbol.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create(
    address, name, source=SourceType.USER_DEFINED
):  # type: (Addr, str, SourceType) -&gt; Symbol
    """Create a new symbol (also called label) at the given address.

    :param address: the address where to create the symbol.
    :param name: the name of the symbol.
    :param source: the source type for the new symbol."""
    raw = createLabel(resolve(address), name, False, source)
    return Symbol(raw)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.delete" class="doc doc-heading">
            <code class="highlight language-python">delete()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Delete this symbol.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def delete(self):  # type: () -&gt; None
    """Delete this symbol."""
    self.raw.delete()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.get" class="doc doc-heading">
            <code class="highlight language-python">get(raw_or_name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get a symbol with the provided name or at the provided address.</p>
<p>Return None if the symbol was not found.</p>
<p>Note: when resolving by name, local symbols take precedence over external ones
(in particular for function thunks - in contrast to Ghidra default behaviour).</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>raw_or_name</code></b>
              –
              <div class="doc-md-description">
                <p>a Ghidra Java object, a string, or an address.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def get(raw_or_name):  # type: (JavaObject|str|Addr) -&gt; Symbol|None
    """Get a symbol with the provided name or at the provided address.

    Return None if the symbol was not found.

    Note: when resolving by name, local symbols take precedence over external ones
    (in particular for function thunks - in contrast to Ghidra default behaviour).

    :param raw_or_name: a Ghidra Java object, a string, or an address."""
    if isinstance(raw_or_name, str):
        symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name)
        symbols = collect_iterator(symbol_iterator)
        if not symbols:
            return None
        raw = symbols[0]
        if raw.isExternal():
            raw = Symbol.resolve_thunk_if_exists(raw)
    elif can_resolve(raw_or_name):
        raw = (
            Program.current()
            .getSymbolTable()
            .getPrimarySymbol(resolve(raw_or_name))
        )
        if not raw:
            return None
    else:
        raw = raw_or_name
    return Symbol(raw)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.remove" class="doc doc-heading">
            <code class="highlight language-python">remove(address, name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Remove the symbol with the given name at the given address.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address of the symbol to remove.</p>
              </div>
            </li>
            <li>
              <b><code>name</code></b>
              –
              <div class="doc-md-description">
                <p>the name of the symbol to remove.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def remove(address, name):  # type: (Addr, str) -&gt; None
    """Remove the symbol with the given name at the given address.

    :param address: the address of the symbol to remove.
    :param name: the name of the symbol to remove."""
    removeSymbol(resolve(address), name)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(new_name, source=SourceType.USER_DEFINED)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Rename this symbol.</p>
<pre><code>&gt;&gt;&gt; main = Symbol.get("main")
&gt;&gt;&gt; main.rename("main_renamed")
&gt;&gt;&gt; main.name
'main_renamed'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>new_name</code></b>
              –
              <div class="doc-md-description">
                <p>the new name of the symbol.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(
    self, new_name, source=SourceType.USER_DEFINED
):  # type: (str, SourceType) -&gt; None
    """Rename this symbol.

        &gt;&gt;&gt; main = Symbol.get("main")
        &gt;&gt;&gt; main.rename("main_renamed")
        &gt;&gt;&gt; main.name
        'main_renamed'

    :param new_name: the new name of the symbol."""
    self.raw.setName(new_name, source)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.resolve_external" class="doc doc-heading">
            <code class="highlight language-python">resolve_external(external_symbol)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Resolves an external address to a RAM location, if possible.</p>
<p>If the symbol has no RAM location, just return its offset.</p>
<p>Why is this ugly thing here? Again, we want to support external symbols, and
we are interested in their RAM address in the program address space. In some
cases, Ghidra will give an external address a "location" in the RAM space.
So, for example, if current program jumps to that external function (or read
that external variable etc), it will read that location as far as Ghidra is
concerned (for example, Emulator will use it for calls). This is important
for emulating Windows binaries, that use address tables for imports.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>external_symbol</code></b>
              –
              <div class="doc-md-description">
                <p>External symbol to resolve.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def resolve_external(external_symbol):  # type: (JavaObject) -&gt; int
    """Resolves an external address to a RAM location, if possible.

    If the symbol has no RAM location, just return its offset.

    Why is this ugly thing here? Again, we want to support external symbols, and
    we are interested in their RAM address in the program address space. In some
    cases, Ghidra will give an external address a "location" in the RAM space.
    So, for example, if current program jumps to that external function (or read
    that external variable etc), it will read that location as far as Ghidra is
    concerned (for example, Emulator will use it for calls). This is important
    for emulating Windows binaries, that use address tables for imports.

    :param external_symbol: External symbol to resolve."""
    external_manager = Program.current().getExternalManager()
    ram_addr = external_manager.getExternalLocation(external_symbol).getAddress()
    if ram_addr:
        return ram_addr.getOffset()
    return external_symbol.getAddress().getOffset()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.resolve_thunk_if_exists" class="doc doc-heading">
            <code class="highlight language-python">resolve_thunk_if_exists(external_symbol)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Returns a function thunk leading to a passed external symbol, if it exists.</p>
<p>If there is no function thunk, original symbol is returned.</p>
<p>Why is this ugly thing here? Well, we want to support external symbols,
especially external functions. Thunks are much more useful for us when
thinking in context of the analysed program - when Linux program calls
<code>printf</code> it jumps to the appropriate <code>printf</code> thunk, not to libc
directly. So this is the location that we want to patch/hook/trace/etc when
thinking about printf. But the thing is that Ghidra SymbolTable API will
not even return thunks! So we trace the external function references, and
return the first (almost certainly only) Thunk reference.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>external_symbol</code></b>
              –
              <div class="doc-md-description">
                <p>Symbol to find thunk for (if it exists).</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def resolve_thunk_if_exists(external_symbol):  # type: (JavaObject) -&gt; JavaObject
    """Returns a function thunk leading to a passed external symbol, if it exists.

    If there is no function thunk, original symbol is returned.

    Why is this ugly thing here? Well, we want to support external symbols,
    especially external functions. Thunks are much more useful for us when
    thinking in context of the analysed program - when Linux program calls
    `printf` it jumps to the appropriate `printf` thunk, not to libc
    directly. So this is the location that we want to patch/hook/trace/etc when
    thinking about printf. But the thing is that Ghidra SymbolTable API will
    not even return thunks! So we trace the external function references, and
    return the first (almost certainly only) Thunk reference.

    :param external_symbol: Symbol to find thunk for (if it exists).
    """
    xrefs = list(external_symbol.getReferences())
    for xref in xrefs:
        if xref.getReferenceType() == GhRefType.THUNK:
            addr = xref.getFromAddress()
            thunk = Program.current().getSymbolTable().getPrimarySymbol(addr)
            if thunk is not None:
                return thunk
    return external_symbol</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Symbol.set_type" class="doc doc-heading">
            <code class="highlight language-python">set_type(datatype)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the data type of this symbol.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_type(self, datatype):  # type: (DataT) -&gt; None
    """Set the data type of this symbol."""
    Program.create_data(self.address, datatype)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.SymbolicPropogator" class="doc doc-heading">
            <code>SymbolicPropogator</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps SymbolicPropogator. Can be used to get known values at various
locations in a given function (or outside of a function)</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class SymbolicPropogator(GhidraWrapper):
    """Wraps SymbolicPropogator. Can be used to get known values at various
    locations in a given function (or outside of a function)"""

    @staticmethod
    def create():
        return SymbolicPropogator(GhSymbolicPropogator(Program.current()))

    def flow_constants(
        self, addr, body, evaluator
    ):  # type: (Addr, AddressSet, JavaObject) -&gt; None
        """Flow constants from the given address in the given body

        :param addr: The address to start from
        :param body: The body where constants should be propagated
        :param evaluator: The evaluator to use for the propagation"""
        addr = resolve(addr)
        self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor())

    def register_at(self, addr, register):  # type: (Addr, Reg) -&gt; int|None
        """Get a known register value at the given address (or None)

        Warning: this value is signed.

        :param addr: The address to get a register value at
        :param register: The register to get a value for
        :return: The value of the register at the given address, or None if the
        register is not known at that address"""
        addr = resolve(addr)
        reg = Register(register)
        value = self.raw.getRegisterValue(addr, reg.raw)
        if not value or value.isRegisterRelativeValue():
            # This never happens in my tests, so I just won't handle register-relative
            # values. I don't know when this can ever happen.
            return None
        return value.value</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ghidralib.SymbolicPropogator.create" class="doc doc-heading">
            <code class="highlight language-python">create()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">@staticmethod
def create():
    return SymbolicPropogator(GhSymbolicPropogator(Program.current()))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.SymbolicPropogator.flow_constants" class="doc doc-heading">
            <code class="highlight language-python">flow_constants(addr, body, evaluator)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Flow constants from the given address in the given body</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>The address to start from</p>
              </div>
            </li>
            <li>
              <b><code>body</code></b>
              –
              <div class="doc-md-description">
                <p>The body where constants should be propagated</p>
              </div>
            </li>
            <li>
              <b><code>evaluator</code></b>
              –
              <div class="doc-md-description">
                <p>The evaluator to use for the propagation</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def flow_constants(
    self, addr, body, evaluator
):  # type: (Addr, AddressSet, JavaObject) -&gt; None
    """Flow constants from the given address in the given body

    :param addr: The address to start from
    :param body: The body where constants should be propagated
    :param evaluator: The evaluator to use for the propagation"""
    addr = resolve(addr)
    self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor())</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.SymbolicPropogator.register_at" class="doc doc-heading">
            <code class="highlight language-python">register_at(addr, register)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get a known register value at the given address (or None)</p>
<p>Warning: this value is signed.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>The address to get a register value at</p>
              </div>
            </li>
            <li>
              <b><code>register</code></b>
              –
              <div class="doc-md-description">
                <p>The register to get a value for</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>The value of the register at the given address, or None if the register is not known at that address</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def register_at(self, addr, register):  # type: (Addr, Reg) -&gt; int|None
    """Get a known register value at the given address (or None)

    Warning: this value is signed.

    :param addr: The address to get a register value at
    :param register: The register to get a value for
    :return: The value of the register at the given address, or None if the
    register is not known at that address"""
    addr = resolve(addr)
    reg = Register(register)
    value = self.raw.getRegisterValue(addr, reg.raw)
    if not value or value.isRegisterRelativeValue():
        # This never happens in my tests, so I just won't handle register-relative
        # values. I don't know when this can ever happen.
        return None
    return value.value</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Variable" class="doc doc-heading">
            <code>Variable</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>


        <p>Wraps a Ghidra Variable object</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Variable(GhidraWrapper):
    """Wraps a Ghidra Variable object"""

    @property
    def name(self):  # type: () -&gt; str
        """Get the name of this variable"""
        return self.raw.getName()

    @name.setter
    def name(self, name):  # type: (str) -&gt; None
        """Rename this variable"""
        self.rename(name, SourceType.USER_DEFINED)

    def rename(
        self, name, source=SourceType.USER_DEFINED
    ):  # type: (str, SourceType) -&gt; None
        """Rename this variable"""
        self.raw.setName(name, source)

    @property
    def data_type(self):  # type: () -&gt; DataType
        """Get the data type of this variable"""
        return DataType(self.raw.getDataType())

    @data_type.setter
    def data_type(
        self, data_type, source=SourceType.USER_DEFINED
    ):  # type: (DataType, SourceType) -&gt; None
        """Set the data type of this variable"""
        self.raw.setDataType(data_type.raw, source)

    @property
    def is_valid(self):  # type: () -&gt; bool
        """Check if this variable is valid"""
        return self.raw.isValid()

    @property
    def comment(self):  # type: () -&gt; str|None
        """ "Get the comment for this variable"""
        return self.raw.getComment()

    @comment.setter
    def comment(self, name):  # type: (str|None) -&gt; None
        """Set the comment for this variable"""
        self.set_comment(name)

    def set_comment(self, comment):  # type: (str|None) -&gt; None
        """Set the comment for this variable"""
        self.raw.setComment(comment)

    @property
    def is_auto(self):  # type: () -&gt; bool
        """Check if this variable is an automatic parameter.

        Some parameters are "hidden parameters" dictated by the calling
        convention. This method returns true for such paramteters."""
        return self.raw.getVariableStorage().isAutoStorage()

    @property
    def is_forced_indirect(self):  # type: () -&gt; bool
        """Check if this variable was forced to be a pointer by calling convention"""
        return self.raw.getVariableStorage().isForcedIndirect()

    @property
    def has_bad_storage(self):  # type: () -&gt; bool
        """Check if this variable has bad storage (could not be resolved)"""
        return self.raw.getVariableStorage().isBadStorage()

    @property
    def is_unassigned_storage(self):  # type: () -&gt; bool
        """Check if this variable has no assigned storage (varnodes)"""
        return self.raw.getVariableStorage().isUnassignedStorage()

    @property
    def is_void(self):  # type: () -&gt; bool
        """Check if this variable is of type void"""
        return self.raw.getVariableStorage().isVoidStorage()

    @property
    def stack_offfset(self):  # type: () -&gt; int
        """Get the stack offset of this variable."""
        return self.raw.getVariableStorage().getStackOffset()

    @property
    def is_constant(self):  # type: () -&gt; bool
        """Check if this variable consists of a single constant-space varnode"""
        return self.raw.getVariableStorage().isConstantStorage()

    @property
    def is_hash(self):  # type: () -&gt; bool
        """Check if this variable consists of a single hash-space varnode."""
        return self.raw.getVariableStorage().isHashStorage()

    @property
    def is_stack(self):  # type: () -&gt; bool
        """Check if this variable is a stack variable"""
        return self.raw.isStackVariable()

    @property
    def is_memory(self):  # type: () -&gt; bool
        """Check if this variable is stored in memory"""
        return self.raw.isMemoryVariable()

    @property
    def is_unique(self):  # type: () -&gt; bool
        """Check if this variable is of type unique"""
        return self.raw.isUniqueVariable()

    @property
    def is_compound(self):  # type: () -&gt; bool
        """Check if this variable is a compound variable"""
        return self.raw.isCompoundVariable()

    @property
    def symbol(self):  # type: () -&gt; Symbol
        """Get the symbol for this variable"""
        return Symbol(self.raw.getSymbol())

    @property
    def source(self):  # type: () -&gt; SourceType
        """Get the source type of this variable"""
        return SourceType(self.raw.getSource())

    @property
    def varnode(self):  # type: () -&gt; Varnode
        """Get the first varnode associated with this variable.

        Warning: there may be more than one varnode associated with a variable."""
        return Varnode(self.raw.getFirstStorageVarnode())

    @property
    def varnodes(self):  # type: () -&gt; list[Varnode]
        """Get all varnodes associated with this variable."""
        storage = self.raw.getVariableStorage()
        return [Varnode(x) for x in storage.getVarnodes()]

    @property
    def is_register(self):  # type: () -&gt; bool
        """Check if this variable consists of a single register."""
        return self.raw.isRegisterVariable()

    @property
    def register(self):  # type: () -&gt; str
        """Get the register associated with this variable.

        Raises an exception if this variable is not a register variable."""
        reg = self.raw.getRegister()
        if not reg:
            raise ValueError("Variable is not a register variable")
        return reg.getName()

    @property
    def function(self):  # type: () -&gt; Function
        """Get the function associated with this variable."""
        return Function(self.raw.getFunction())</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.comment" class="doc doc-heading">
            <code class="highlight language-python">comment</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>"Get the comment for this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.data_type" class="doc doc-heading">
            <code class="highlight language-python">data_type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the data type of this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.function" class="doc doc-heading">
            <code class="highlight language-python">function</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the function associated with this variable.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.has_bad_storage" class="doc doc-heading">
            <code class="highlight language-python">has_bad_storage</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable has bad storage (could not be resolved)</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_auto" class="doc doc-heading">
            <code class="highlight language-python">is_auto</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is an automatic parameter.</p>
<p>Some parameters are "hidden parameters" dictated by the calling
convention. This method returns true for such paramteters.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_compound" class="doc doc-heading">
            <code class="highlight language-python">is_compound</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is a compound variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_constant" class="doc doc-heading">
            <code class="highlight language-python">is_constant</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable consists of a single constant-space varnode</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_forced_indirect" class="doc doc-heading">
            <code class="highlight language-python">is_forced_indirect</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable was forced to be a pointer by calling convention</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_hash" class="doc doc-heading">
            <code class="highlight language-python">is_hash</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable consists of a single hash-space varnode.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_memory" class="doc doc-heading">
            <code class="highlight language-python">is_memory</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is stored in memory</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_register" class="doc doc-heading">
            <code class="highlight language-python">is_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable consists of a single register.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_stack" class="doc doc-heading">
            <code class="highlight language-python">is_stack</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is a stack variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_unassigned_storage" class="doc doc-heading">
            <code class="highlight language-python">is_unassigned_storage</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable has no assigned storage (varnodes)</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_unique" class="doc doc-heading">
            <code class="highlight language-python">is_unique</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is of type unique</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_valid" class="doc doc-heading">
            <code class="highlight language-python">is_valid</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is valid</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.is_void" class="doc doc-heading">
            <code class="highlight language-python">is_void</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Check if this variable is of type void</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.name" class="doc doc-heading">
            <code class="highlight language-python">name</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the name of this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.register" class="doc doc-heading">
            <code class="highlight language-python">register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the register associated with this variable.</p>
<p>Raises an exception if this variable is not a register variable.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.source" class="doc doc-heading">
            <code class="highlight language-python">source</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the source type of this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.stack_offfset" class="doc doc-heading">
            <code class="highlight language-python">stack_offfset</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the stack offset of this variable.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.symbol" class="doc doc-heading">
            <code class="highlight language-python">symbol</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the symbol for this variable</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.varnode" class="doc doc-heading">
            <code class="highlight language-python">varnode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the first varnode associated with this variable.</p>
<p>Warning: there may be more than one varnode associated with a variable.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Variable.varnodes" class="doc doc-heading">
            <code class="highlight language-python">varnodes</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get all varnodes associated with this variable.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Variable.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(name, source=SourceType.USER_DEFINED)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Rename this variable</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(
    self, name, source=SourceType.USER_DEFINED
):  # type: (str, SourceType) -&gt; None
    """Rename this variable"""
    self.raw.setName(name, source)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Variable.set_comment" class="doc doc-heading">
            <code class="highlight language-python">set_comment(comment)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Set the comment for this variable</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_comment(self, comment):  # type: (str|None) -&gt; None
    """Set the comment for this variable"""
    self.raw.setComment(comment)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.Varnode" class="doc doc-heading">
            <code>Varnode</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="GhidraWrapper (ghidralib.GhidraWrapper)" href="#ghidralib.GhidraWrapper">GhidraWrapper</a></code></p>








              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class Varnode(GhidraWrapper):
    @property
    def has_value(self):  # type: () -&gt; bool
        """Return true if this varnode can be converted to a integer value.

        In particular, this will return true for Address and Constant varnodes"""
        return self.value is not None

    @property
    def value(self):  # type: () -&gt; int|None
        """Get the value of this varnode. Traverse defining pcodeops if necessary."""
        if self.is_address or self.is_constant:
            return self.offset
        if self.defining_pcodeop is None:
            return None
        return self.defining_pcodeop.result

    @property
    def offset(self):  # type: () -&gt; int
        return int(self.raw.getOffset())

    @property
    def size(self):  # type: () -&gt; int
        return self.raw.getSize()

    @property
    def high(self):  # type: () -&gt; HighVariable
        return HighVariable(self.raw.getHigh())

    @property
    def symbol(self):  # type: () -&gt; HighSymbol
        return self.high.symbol

    @property
    def is_constant(self):  # type: () -&gt; bool
        """Note: addresses are not constants in Ghidra-speak.
        Use has_value to check if the varnode has a predictable value."""
        return self.raw.isConstant()

    @property
    def is_register(self):  # type: () -&gt; bool
        """Return True if this varnode is stored entirely in a register.

        Warning: this does not mean that it can be cast to a register! This may
        be, for example, upper 32 bits of RAX. Use is_named_register instead."""
        return self.raw.isRegister()

    @property
    def is_named_register(self):  # type: () -&gt; bool
        """ "Return True if this varnode is stored entirely in a named register.

        "Named" in this context means that it has a conventional name, like RAX.
        Not all register varnodes are named, for example, the upper 32 bits of RAX
        have no commonly used name."""
        language = Program.current().getLanguage()
        raw = language.getRegister(self.raw.getAddress(), self.size)
        return raw is not None

    @property
    def as_register(self):  # type: () -&gt; str
        """Return the name of the register this varnode is stored in.

        Warning: even if is_register returns true, this does not mean you can use
        this method safely. Use is_named_register to make sure."""
        language = Program.current().getLanguage()
        raw = language.getRegister(self.raw.getAddress(), self.size)
        return raw.getName()

    @property
    def is_address(self):  # type: () -&gt; bool
        return self.raw.isAddress()

    @property
    def is_unique(self):  # type: () -&gt; bool
        return self.raw.isUnique()

    @property
    def is_hash(self):  # type: () -&gt; bool
        return self.raw.isHash()

    @property
    def is_stack(self):  # type: () -&gt; bool
        spaceid = self.raw.getSpace()
        spacetype = AddressSpace.ID_TYPE_MASK &amp; spaceid
        return spacetype == AddressSpace.TYPE_STACK

    def rename(self, new_name):  # type: (str) -&gt; None
        """Try to rename the current varnode. This only makes sense for variables."""
        self.symbol.rename(new_name)

    @property
    def free(self):  # type: () -&gt; Varnode
        return Varnode(GhVarnode(self.raw.getAddress(), self.raw.getSize()))

    @property
    def simple(self):  # type: () -&gt; int|str
        """Convert Varnode to a primitive value (int or a string representation)

        More specifically, this will convert constants and addresses into integers,
        for registers names are returned, and for unique and hash varnodes ad-hoc
        string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).

        This is useful for simple analyses when programmer already knows what
        type of value is expected at the given position."""
        value = self.value
        if value is not None:
            return value
        elif self.is_register:
            if self.is_named_register:
                return self.as_register
            return "reg:{:x}:{:x}".format(self.offset, self.size)
        elif self.is_unique:
            return "uniq:{:x}:{:x}".format(self.offset, self.size)
        elif self.is_hash:
            return "hash:{:x}:{:x}".format(self.offset, self.size)
        elif self.is_stack:
            return "stack:{:x}:{:x}".format(self.offset, self.size)
        raise RuntimeError("Unknown varnode type")

    @property
    def is_unaffected(self):  # type: () -&gt; bool
        return self.raw.isUnaffected()

    @property
    def is_persistent(self):  # type: () -&gt; bool
        return self.raw.isPersistent()

    @property
    def is_addr_tied(self):  # type: () -&gt; bool
        return self.raw.isAddrTied()

    @property
    def is_input(self):  # type: () -&gt; bool
        return self.raw.isInput()

    @property
    def is_free(self):  # type: () -&gt; bool
        return self.raw.isFree()

    @property
    def defining_pcodeop(self):  # type: () -&gt; PcodeOp|None
        """Return a PcodeOp that defined this varnode"""
        raw = self.raw.getDef()
        if raw is None:
            return None
        return PcodeOp(raw)

    @property
    def descendants(self):  # type: () -&gt; list[PcodeOp]
        """Return a list of all descendants of this varnode"""
        if self.raw.getDescendants() is None:
            return []
        return [PcodeOp(x) for x in self.raw.getDescendants()]

    def intersects(self, other):  # type: (Varnode) -&gt; list[PcodeOp]
        """Return true if this varnode intersects other"""
        return self.raw.intersects(other.raw)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.as_register" class="doc doc-heading">
            <code class="highlight language-python">as_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return the name of the register this varnode is stored in.</p>
<p>Warning: even if is_register returns true, this does not mean you can use
this method safely. Use is_named_register to make sure.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.defining_pcodeop" class="doc doc-heading">
            <code class="highlight language-python">defining_pcodeop</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return a PcodeOp that defined this varnode</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.descendants" class="doc doc-heading">
            <code class="highlight language-python">descendants</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return a list of all descendants of this varnode</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.free" class="doc doc-heading">
            <code class="highlight language-python">free</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.has_value" class="doc doc-heading">
            <code class="highlight language-python">has_value</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return true if this varnode can be converted to a integer value.</p>
<p>In particular, this will return true for Address and Constant varnodes</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.high" class="doc doc-heading">
            <code class="highlight language-python">high</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_addr_tied" class="doc doc-heading">
            <code class="highlight language-python">is_addr_tied</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_address" class="doc doc-heading">
            <code class="highlight language-python">is_address</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_constant" class="doc doc-heading">
            <code class="highlight language-python">is_constant</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Note: addresses are not constants in Ghidra-speak.
Use has_value to check if the varnode has a predictable value.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_free" class="doc doc-heading">
            <code class="highlight language-python">is_free</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_hash" class="doc doc-heading">
            <code class="highlight language-python">is_hash</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_input" class="doc doc-heading">
            <code class="highlight language-python">is_input</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_named_register" class="doc doc-heading">
            <code class="highlight language-python">is_named_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>"Return True if this varnode is stored entirely in a named register.</p>
<p>"Named" in this context means that it has a conventional name, like RAX.
Not all register varnodes are named, for example, the upper 32 bits of RAX
have no commonly used name.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_persistent" class="doc doc-heading">
            <code class="highlight language-python">is_persistent</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_register" class="doc doc-heading">
            <code class="highlight language-python">is_register</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Return True if this varnode is stored entirely in a register.</p>
<p>Warning: this does not mean that it can be cast to a register! This may
be, for example, upper 32 bits of RAX. Use is_named_register instead.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_stack" class="doc doc-heading">
            <code class="highlight language-python">is_stack</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_unaffected" class="doc doc-heading">
            <code class="highlight language-python">is_unaffected</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.is_unique" class="doc doc-heading">
            <code class="highlight language-python">is_unique</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.offset" class="doc doc-heading">
            <code class="highlight language-python">offset</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.simple" class="doc doc-heading">
            <code class="highlight language-python">simple</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Convert Varnode to a primitive value (int or a string representation)</p>
<p>More specifically, this will convert constants and addresses into integers,
for registers names are returned, and for unique and hash varnodes ad-hoc
string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).</p>
<p>This is useful for simple analyses when programmer already knows what
type of value is expected at the given position.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.size" class="doc doc-heading">
            <code class="highlight language-python">size</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.symbol" class="doc doc-heading">
            <code class="highlight language-python">symbol</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="ghidralib.Varnode.value" class="doc doc-heading">
            <code class="highlight language-python">value</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


    <div class="doc doc-contents ">

        <p>Get the value of this varnode. Traverse defining pcodeops if necessary.</p>

    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="ghidralib.Varnode.intersects" class="doc doc-heading">
            <code class="highlight language-python">intersects(other)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Return true if this varnode intersects other</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def intersects(self, other):  # type: (Varnode) -&gt; list[PcodeOp]
    """Return true if this varnode intersects other"""
    return self.raw.intersects(other.raw)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="ghidralib.Varnode.rename" class="doc doc-heading">
            <code class="highlight language-python">rename(new_name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Try to rename the current varnode. This only makes sense for variables.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def rename(self, new_name):  # type: (str) -&gt; None
    """Try to rename the current varnode. This only makes sense for variables."""
    self.symbol.rename(new_name)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="ghidralib.unicode" class="doc doc-heading">
            <code>unicode</code>


</h2>


    <div class="doc doc-contents ">


        <p>A fake stub class, to keep type-checker relatively happy</p>







              <details class="quote">
                <summary>Source code in <code>ghidralib.py</code></summary>
                <pre class="highlight"><code class="language-python">class unicode:
    """A fake stub class, to keep type-checker relatively happy"""

    def encode(self):  # type: () -&gt; str
        """A fake method, to keep type-checker relatively happy"""
        raise NotImplementedError("This method should never be called")</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="ghidralib.unicode.encode" class="doc doc-heading">
            <code class="highlight language-python">encode()</code>

</h3>


    <div class="doc doc-contents ">

        <p>A fake method, to keep type-checker relatively happy</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def encode(self):  # type: () -&gt; str
    """A fake method, to keep type-checker relatively happy"""
    raise NotImplementedError("This method should never be called")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="ghidralib.assemble" class="doc doc-heading">
            <code class="highlight language-python">assemble(instructions, address=0)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Assemble the given instructions and return them as a list of instructions.</p>
<p>Note: Address is important, because instruction meaning may depend on the location.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address where the instructious would be written</p>
              </div>
            </li>
            <li>
              <b><code>instructions</code></b>
              –
              <div class="doc-md-description">
                <p>a list of instructions, or a single instruction to assemble</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>the newly assembled instructions</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def assemble(
    instructions, address=0
):  # type: (str|list[str], Addr) -&gt; list[Instruction]
    """Assemble the given instructions and return them as a list of instructions.

    Note: Address is important, because instruction meaning may depend on the location.

    :param address: the address where the instructious would be written
    :param instructions: a list of instructions, or a single instruction to assemble
    :return: the newly assembled instructions"""
    data = assemble_to_bytes(instructions, address)
    return disassemble_bytes(data, address)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.assemble_at" class="doc doc-heading">
            <code class="highlight language-python">assemble_at(address, instructions, pad_to=0)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Assemble the given instructions and write them at the given address.</p>
<p>Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes.
For example, use "MOV EAX, EBX" instead of "mov eax, ebx".</p>
<pre><code>&gt;&gt;&gt; assemble_at(Function("exit").entrypoint, "RET")
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address where to write the instructions</p>
              </div>
            </li>
            <li>
              <b><code>instructions</code></b>
              –
              <div class="doc-md-description">
                <p>a list of instructions, or a single instruction to assemble</p>
              </div>
            </li>
            <li>
              <b><code>pad_to</code></b>
              –
              <div class="doc-md-description">
                <p>optionally, pad the code with NOPs to reach this size</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>the newly assembled instructions</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def assemble_at(
    address, instructions, pad_to=0
):  # type: (Addr, str|list[str], int) -&gt; list[Instruction]
    """Assemble the given instructions and write them at the given address.

    Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes.
    For example, use "MOV EAX, EBX" instead of "mov eax, ebx".

        &gt;&gt;&gt; assemble_at(Function("exit").entrypoint, "RET")

    :param address: the address where to write the instructions
    :param instructions: a list of instructions, or a single instruction to assemble
    :param pad_to: optionally, pad the code with NOPs to reach this size
    :return: the newly assembled instructions"""
    # Note: Assembler API is actually quite user-friendly and doesn't require
    # wrapping. But let's wrap it for consistency.
    addr = resolve(address)
    asm = Assemblers.getAssembler(Program.current())
    result = [Instruction(i) for i in asm.assemble(addr, instructions)]

    # Append NOPs at the end, if length is shorter than pad_to.
    # This is purely to make the assembled code look nicer.
    if result:
        last = result[-1]
        end_addr = last.address + last.length
        code_size = end_addr - addr.getOffset()
        if pad_to &gt; code_size:
            asm.assemble(addr.add(code_size), ["NOP"] * (pad_to - code_size))

    # Do what Ghidra should do automaticaly, and automatically try to disassemble
    # jump targets from the newly assembled instructions
    for instr in result:
        for xref in instr.xrefs_from:
            if xref.is_call or xref.is_jump:
                disassemble(toAddr(xref.to_address))

    return result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.assemble_to_bytes" class="doc doc-heading">
            <code class="highlight language-python">assemble_to_bytes(instructions, address=0)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Assemble the given instructions and return them as an array of bytes.</p>
<p>Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes.
For example, use "MOV EAX, EBX" instead of "mov eax, ebx".</p>
<p>Note: Address is important, because instruction bytes may depend on the location.</p>
<pre><code>&gt;&gt;&gt; assemble_to_bytes("ADD EAX, EAX")
"À"
&gt;&gt;&gt; assemble_to_bytes(["ADD EAX, EAX", "ADD EAX, EAX"])
"ÀÀ"
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address to use as a base for instructions</p>
              </div>
            </li>
            <li>
              <b><code>instructions</code></b>
              –
              <div class="doc-md-description">
                <p>a list of instructions, or a single instruction to assemble</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def assemble_to_bytes(instructions, address=0):  # type: (str|list[str], Addr) -&gt; bytes
    """Assemble the given instructions and return them as an array of bytes.

    Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes.
    For example, use "MOV EAX, EBX" instead of "mov eax, ebx".

    Note: Address is important, because instruction bytes may depend on the location.

        &gt;&gt;&gt; assemble_to_bytes("ADD EAX, EAX")
        "\x01\xc0"
        &gt;&gt;&gt; assemble_to_bytes(["ADD EAX, EAX", "ADD EAX, EAX"])
        "\x01\xc0\x01\xc0"

    :param address: the address to use as a base for instructions
    :param instructions: a list of instructions, or a single instruction to assemble"""
    # Note: Assembler API is actually quite user-friendly and doesn't require
    # wrapping. But let's wrap it for consistency.
    addr_obj = resolve(address)
    asm = Assemblers.getAssembler(Program.current())
    if isinstance(instructions, Str):
        return _bytes_from_bytelist(asm.assembleLine(addr_obj, instructions))
    result = _asbytes("")
    for instr in instructions:
        result += _bytes_from_bytelist(
            asm.assembleLine(addr_obj.add(len(result)), instr)
        )
    return result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.can_resolve" class="doc doc-heading">
            <code class="highlight language-python">can_resolve(addr)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Check if a passed value address can be resolved.</p>
<p>This is useful for checking if <code>resolve()</code> will succeed.
See <code>resolve</code> documentation for more details.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def can_resolve(addr):  # type: (Addr) -&gt; bool
    """Check if a passed value address can be resolved.

    This is useful for checking if `resolve()` will succeed.
    See `resolve` documentation for more details."""
    return isinstance(addr, (GenericAddress, int, long, unicode, str))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.collect_iterator" class="doc doc-heading">
            <code class="highlight language-python">collect_iterator(iterator)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Collect a Java iterator to a Python list.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def collect_iterator(iterator):  # type: (JavaObject) -&gt; list
    """Collect a Java iterator to a Python list."""
    result = []
    while iterator.hasNext():
        result.append(iterator.next())
    return result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.disassemble_at" class="doc doc-heading">
            <code class="highlight language-python">disassemble_at(address, max_instr=None, max_bytes=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Disassemble the bytes from the program memory at the given address.</p>
<p>If neither <code>max_bytes</code> nor <code>max_instr</code> are specified, this function will
disassemble one instruction. If at least one of them is specified,
this function will disassemble until one of the conditions occurs.</p>
<pre><code>&gt;&gt;&gt; disassemble_at(0x0403ED0)
[INC ESI]
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>the address where to start disassembling</p>
              </div>
            </li>
            <li>
              <b><code>max_bytes</code></b>
              –
              <div class="doc-md-description">
                <p>maximum number of bytes to disassemble (None for no limit)</p>
              </div>
            </li>
            <li>
              <b><code>max_instr</code></b>
              –
              <div class="doc-md-description">
                <p>maximum number of instructions to disassemble (None for no limit)</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>a list of Instruction objects</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def disassemble_at(
    address, max_instr=None, max_bytes=None
):  # type: (Addr, int|None, int|None) -&gt; list[Instruction]
    """Disassemble the bytes from the program memory at the given address.

    If neither `max_bytes` nor `max_instr` are specified, this function will
    disassemble one instruction. If at least one of them is specified,
    this function will disassemble until one of the conditions occurs.

        &gt;&gt;&gt; disassemble_at(0x0403ED0)
        [INC ESI]

    :param address: the address where to start disassembling
    :param max_bytes: maximum number of bytes to disassemble (None for no limit)
    :param max_instr: maximum number of instructions to disassemble (None for no limit)
    :return: a list of Instruction objects"""
    addr = resolve(address)

    if max_instr is None:
        _max_instr = 1 if max_bytes is None else max_bytes
    else:
        _max_instr = max_instr

    if max_bytes is None:
        to_block_end = MemoryBlock(addr).end - addr.getOffset()
        # Hacky and inefficient, but good enough for now (and correct)
        _max_bytes = min(to_block_end, _max_instr * 16)
    else:
        _max_bytes = max_bytes
    data = read_bytes(addr, _max_bytes)

    return disassemble_bytes(data, addr, _max_instr)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.disassemble_bytes" class="doc doc-heading">
            <code class="highlight language-python">disassemble_bytes(data, addr=0, max_instr=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Disassemble the given bytes and return a list of Instructions.</p>
<p>This function will return early if an exception during disassembly occurs.</p>
<pre><code>&gt;&gt;&gt; disassemble_bytes('F')
[INC ESI]
</code></pre>
<p>Note: Address is important, because instruction meaning may depend on the location.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>data</code></b>
              –
              <div class="doc-md-description">
                <p>the bytes to disassemble</p>
              </div>
            </li>
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>the (virtual) address of the first instruction</p>
              </div>
            </li>
            <li>
              <b><code>max_instr</code></b>
              –
              <div class="doc-md-description">
                <p>the maximum number of instructions to disassemble, or to disassemble until the end of the data</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>a list of Instruction objects</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def disassemble_bytes(
    data, addr=0, max_instr=None
):  # type: (bytes, Addr, int|None) -&gt; list[Instruction]
    """Disassemble the given bytes and return a list of Instructions.

    This function will return early if an exception during disassembly occurs.

        &gt;&gt;&gt; disassemble_bytes('F')
        [INC ESI]

    Note: Address is important, because instruction meaning may depend on the location.

    :param data: the bytes to disassemble
    :param addr: the (virtual) address of the first instruction
    :param max_instr: the maximum number of instructions to disassemble, or
    to disassemble until the end of the data
    :return: a list of Instruction objects"""
    dis = PseudoDisassembler(Program.current())
    offset = 0
    result = []
    address = resolve(addr)
    if max_instr is None:
        max_instr = 100000000
    for _ in range(0, max_instr):
        try:
            arr = data[offset : offset + 16]
            rawinstr = dis.disassemble(address.add(offset), arr)
            instr = Instruction(rawinstr)
            if offset + instr.length &gt; len(data):
                break
            result.append(instr)
            offset += instr.length
            if offset + instr.length == len(data):
                break
        except:
            break
    return result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.enhex" class="doc doc-heading">
            <code class="highlight language-python">enhex(s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert raw bytes to a hex string.</p>
<pre><code>&gt;&gt;&gt; enhex([0x01, 0x02])
'0102'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>s</code></b>
              –
              <div class="doc-md-description">
                <p>raw bytes to encode.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def enhex(s):  # type: (bytes | list[int]) -&gt; str
    """Convert raw bytes to a hex string.

        &gt;&gt;&gt; enhex([0x01, 0x02])
        '0102'

    :param s: raw bytes to encode."""
    if not isinstance(s, Str):
        return _enhex(_asbytes("".join(chr(c) for c in s)))
    return _enhex(s)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.findall_pattern" class="doc doc-heading">
            <code class="highlight language-python">findall_pattern(byte_pattern)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Find all occurrences of a byte pattern in the program.</p>
<pre><code>&gt;&gt;&gt; findall_pattern("01 02 ?? 04")
[0x1000, 0x1004]
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>byte_pattern</code></b>
              –
              <div class="doc-md-description">
                <p>the pattern string.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>iterator over all addresses of all occurrences.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def findall_pattern(byte_pattern):  # type: (str) -&gt; Iterator[int]
    """Find all occurrences of a byte pattern in the program.

        &gt;&gt;&gt; findall_pattern("01 02 ?? 04")
        [0x1000, 0x1004]

    :param byte_pattern: the pattern string.
    :return: iterator over all addresses of all occurrences."""
    addr = -1
    while True:
        addr = findone_pattern(byte_pattern, start=addr + 1)
        if addr is None:
            break
        yield addr</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.findone_pattern" class="doc doc-heading">
            <code class="highlight language-python">findone_pattern(byte_pattern, start=0)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Find the first occurrence of a byte pattern in the program (or None).</p>
<pre><code>&gt;&gt;&gt; findone_pattern("01 02 ?? 04")
0x1000
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>byte_pattern</code></b>
              –
              <div class="doc-md-description">
                <p>the pattern string.</p>
              </div>
            </li>
            <li>
              <b><code>start</code></b>
              –
              <div class="doc-md-description">
                <p>the address to start searching from.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>address of the first occurrence, or None if not found.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def findone_pattern(byte_pattern, start=0):  # type: (str, Addr) -&gt; int|None
    """Find the first occurrence of a byte pattern in the program (or None).

        &gt;&gt;&gt; findone_pattern("01 02 ?? 04")
        0x1000

    :param byte_pattern: the pattern string.
    :param start: the address to start searching from.
    :return: address of the first occurrence, or None if not found."""
    start = resolve(start)
    bytes = _pattern_to_bytes(byte_pattern)
    mask = _pattern_to_mask(byte_pattern)
    addr = (
        Program.current().getMemory().findBytes(start, bytes, mask, True, getMonitor())
    )
    if not addr:
        return None
    return addr.getOffset()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.from_bytes" class="doc doc-heading">
            <code class="highlight language-python">from_bytes(b)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Decode a bytes as a little-endian integer.</p>
<pre><code>&gt;&gt;&gt; from_bytes('ab')
25185
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>b</code></b>
              –
              <div class="doc-md-description">
                <p>byte stream to decode.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def from_bytes(b):  # type: (bytes) -&gt; int
    """Decode a bytes as a little-endian integer.

        &gt;&gt;&gt; from_bytes('ab')
        25185

    :param b: byte stream to decode."""
    bl = _bytes_as_list(b)
    return sum(v &lt;&lt; (i * 8) for i, v in enumerate(bl))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.get_string" class="doc doc-heading">
            <code class="highlight language-python">get_string(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Get the string defined at the given address.</p>
<p>This function will return None if the data defined in Ghidra at the
given address is not a string. This function will also return None
if the string at <code>adress</code> was not defined in Ghidra. To read a
null-terminated string from Ghidra memory, use <code>read_cstring</code> instead.</p>
<pre><code>&gt;&gt;&gt; get_string(0x1000)
'Hello, world!'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address where string should be located.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_string(address):  # type: (Addr) -&gt; str|None
    """Get the string defined at the given address.

    This function will return None if the data defined in Ghidra at the
    given address is not a string. This function will also return None
    if the string at `adress` was not defined in Ghidra. To read a
    null-terminated string from Ghidra memory, use `read_cstring` instead.

        &gt;&gt;&gt; get_string(0x1000)
        'Hello, world!'

    :param address: address where string should be located."""
    string = getDataAt(resolve(address))
    if string and string.hasStringValue():
        return string.getValue()
    return None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_bytes" class="doc doc-heading">
            <code class="highlight language-python">read_bytes(address, length)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a byte stream from program at address.</p>
<pre><code>&gt;&gt;&gt; read_bytes(0x1000, 4)
'test'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to read.</p>
              </div>
            </li>
            <li>
              <b><code>length</code></b>
              –
              <div class="doc-md-description">
                <p>number of bytes to read.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_bytes(address, length):  # type: (Addr, int) -&gt; bytes
    """Read a byte stream from program at address.

        &gt;&gt;&gt; read_bytes(0x1000, 4)
        'test'

    :param address: address from which to read.
    :param length: number of bytes to read."""
    address = resolve(address)
    return _bytes_from_bytelist(getBytes(address, length))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_cstring" class="doc doc-heading">
            <code class="highlight language-python">read_cstring(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a null-terminated string from Ghidra memory.</p>
<p>This function ignores metadata available to Ghidra and just reads
the bytes until a nullbyte is encountered.</p>
<pre><code>&gt;&gt;&gt; read_cstring(0x1000)
'Hello, world!'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to start reading.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_cstring(address):  # type: (Addr) -&gt; str
    """Read a null-terminated string from Ghidra memory.

    This function ignores metadata available to Ghidra and just reads
    the bytes until a nullbyte is encountered.

        &gt;&gt;&gt; read_cstring(0x1000)
        'Hello, world!'

    :param address: address from which to start reading."""
    addr = resolve(address)
    string = ""
    while True:
        c = read_u8(addr)
        if c == 0:
            break
        string += chr(c)
        addr = addr.add(1)
    return string</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_u16" class="doc doc-heading">
            <code class="highlight language-python">read_u16(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a 16bit integer from program at address.</p>
<pre><code>&gt;&gt;&gt; read_u16(0x1000)
0x0102
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to read.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u16(address):  # type: (Addr) -&gt; int
    """Read a 16bit integer from program at address.

        &gt;&gt;&gt; read_u16(0x1000)
        0x0102

    :param address: address from which to read."""
    return from_bytes(read_bytes(address, 2))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_u32" class="doc doc-heading">
            <code class="highlight language-python">read_u32(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a 32bit integer from program at address.</p>
<pre><code>&gt;&gt;&gt; read_u32(0x1000)
0x01020304
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to read.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u32(address):  # type: (Addr) -&gt; int
    """Read a 32bit integer from program at address.

        &gt;&gt;&gt; read_u32(0x1000)
        0x01020304

    :param address: address from which to read."""
    return from_bytes(read_bytes(address, 4))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_u64" class="doc doc-heading">
            <code class="highlight language-python">read_u64(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a 64bit integer from program at address.</p>
<pre><code>&gt;&gt;&gt; read_u32(0x1000)
0x0102030405060708
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to read.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u64(address):  # type: (Addr) -&gt; int
    """Read a 64bit integer from program at address.

        &gt;&gt;&gt; read_u32(0x1000)
        0x0102030405060708

    :param address: address from which to read."""
    return from_bytes(read_bytes(address, 8))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_u8" class="doc doc-heading">
            <code class="highlight language-python">read_u8(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a byte from program at address.</p>
<pre><code>&gt;&gt;&gt; read_u8(0x1000)
0x01
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to read.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_u8(address):  # type: (Addr) -&gt; int
    """Read a byte from program at address.

        &gt;&gt;&gt; read_u8(0x1000)
        0x01

    :param address: address from which to read."""
    return from_bytes(read_bytes(address, 1))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.read_unicode" class="doc doc-heading">
            <code class="highlight language-python">read_unicode(address)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Read a null-terminated utf-16 string from Ghidra memory.</p>
<p>This function ignores metadata available to Ghidra and just reads
the bytes until a null character is encountered.</p>
<pre><code>&gt;&gt;&gt; read_unicode(0x1000)
'Hello, world!'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address from which to start reading.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def read_unicode(address):  # type: (Addr) -&gt; str
    """Read a null-terminated utf-16 string from Ghidra memory.

    This function ignores metadata available to Ghidra and just reads
    the bytes until a null character is encountered.

        &gt;&gt;&gt; read_unicode(0x1000)
        'Hello, world!'

    :param address: address from which to start reading."""
    addr = resolve(address)
    string = ""
    while True:
        c = read_u16(addr)
        if c == 0:
            break
        string += chr(c)
        addr = addr.add(2)
    return string</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.resolve" class="doc doc-heading">
            <code class="highlight language-python">resolve(addr)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert an arbitrary addressable value to a Ghidra Address object.</p>
<p>This library accepts one of three things as addressses:</p>
<ol>
<li>A Ghidra Address object</li>
<li>An integer representing an address</li>
<li>A string representing a symbol name</li>
</ol>
<p>This function is responsible from converting the addressable values (<code>Addr</code>)
to Ghidra addresses (<code>GenericAddress</code>).</p>
<pre><code>&gt;&gt;&gt; resolve(0x1234)
0x1234
&gt;&gt;&gt; resolve(Symbol("main"))
0x1234
&gt;&gt;&gt; resolve(toAddr(0x1234))
0x1234
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>An addressable value.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>A GenericAddress object representing the passed address.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def resolve(addr):  # type: (Addr) -&gt; GenericAddress
    """Convert an arbitrary addressable value to a Ghidra Address object.

    This library accepts one of three things as addressses:

    1. A Ghidra Address object
    2. An integer representing an address
    3. A string representing a symbol name

    This function is responsible from converting the addressable values (`Addr`)
    to Ghidra addresses (`GenericAddress`).

        &gt;&gt;&gt; resolve(0x1234)
        0x1234
        &gt;&gt;&gt; resolve(Symbol("main"))
        0x1234
        &gt;&gt;&gt; resolve(toAddr(0x1234))
        0x1234

    :param addr: An addressable value.
    :return: A GenericAddress object representing the passed address.

    """
    if isinstance(addr, unicode):  # Why, Ghidra?
        addr = addr.encode()
    if isinstance(addr, GenericAddress):
        return addr
    if isinstance(addr, (int, long)):
        # Why convert to string? Java cannot handle large (unsigned) integers :/
        return toAddr("{:x}".format(addr))
    if isinstance(addr, str):
        return toAddr(Symbol(addr).address)
    raise TypeError("Address must be a ghidra Address, int, or str")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.to_bytes" class="doc doc-heading">
            <code class="highlight language-python">to_bytes(value, length)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Encode an integer as a little-endian byte stream.</p>
<pre><code>&gt;&gt;&gt; to_bytes(0x0102, 2)
'\x01\x02'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>value</code></b>
              –
              <div class="doc-md-description">
                <p>integer to encode.</p>
              </div>
            </li>
            <li>
              <b><code>length</code></b>
              –
              <div class="doc-md-description">
                <p>number of bytes of the result.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def to_bytes(value, length):  # type: (int, int) -&gt; bytes
    """Encode an integer as a little-endian byte stream.

        &gt;&gt;&gt; to_bytes(0x0102, 2)
        '\\x01\\x02'

    :param value: integer to encode.
    :param length: number of bytes of the result."""
    out = ""
    for i in range(length):
        out += chr(value &amp; 0xFF)
        value &gt;&gt;= 8
    return _asbytes(out)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.try_resolve" class="doc doc-heading">
            <code class="highlight language-python">try_resolve(addr)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convert an arbitrary addressable value to a Ghidra Address object.</p>
<p>See <code>resolve</code> documentation for more details.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>addr</code></b>
              –
              <div class="doc-md-description">
                <p>An addressable value.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              –
              <div class="doc-md-description">
                <p>A GenericAddress representing the value, or None resolving failed.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def try_resolve(addr):  # type: (Addr) -&gt; GenericAddress | None
    """Convert an arbitrary addressable value to a Ghidra Address object.

    See `resolve` documentation for more details.

    :param addr: An addressable value.
    :return: A GenericAddress representing the value, or None resolving failed."""
    try:
        return resolve(addr)
    except:
        return None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.unhex" class="doc doc-heading">
            <code class="highlight language-python">unhex(s)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Decode a hex string.</p>
<pre><code>&gt;&gt;&gt; unhex("01 02")
'0102'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>s</code></b>
              –
              <div class="doc-md-description">
                <p>hex string to decode.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def unhex(s):  # type: (str) -&gt; bytes
    """Decode a hex string.

        &gt;&gt;&gt; unhex("01 02")
        '0102'

    :param s: hex string to decode."""
    return _unhex(s)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.unwrap" class="doc doc-heading">
            <code class="highlight language-python">unwrap(wrapper_or_java_type)</code>

</h2>


    <div class="doc doc-contents ">

        <p>If the argument is a GhidraWrapper, return the underlying Java object.</p>


            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def unwrap(wrapper_or_java_type):  # type: (JavaObject|GhidraWrapper) -&gt; JavaObject
    "If the argument is a GhidraWrapper, return the underlying Java object." ""
    if isinstance(wrapper_or_java_type, GhidraWrapper):
        return wrapper_or_java_type.raw
    return wrapper_or_java_type</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.write_bytes" class="doc doc-heading">
            <code class="highlight language-python">write_bytes(address, data)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Write the provided bytes at a given address.</p>
<pre><code>&gt;&gt;&gt; write_bytes(0x1000, "test)
&gt;&gt;&gt; read_bytes(0x1000, 4)
'test'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>address</code></b>
              –
              <div class="doc-md-description">
                <p>address where bytes should be written.</p>
              </div>
            </li>
            <li>
              <b><code>data</code></b>
              –
              <div class="doc-md-description">
                <p>bytes to write.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_bytes(address, data):  # type: (Addr, bytes) -&gt; None
    """Write the provided bytes at a given address.

        &gt;&gt;&gt; write_bytes(0x1000, "test)
        &gt;&gt;&gt; read_bytes(0x1000, 4)
        'test'

    :param address: address where bytes should be written.
    :param data: bytes to write."""
    addr = resolve(address)
    try:
        setBytes(addr, data)
    except:
        clearListing(addr, addr.add(len(data) - 1))
        setBytes(addr, data)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="ghidralib.xor" class="doc doc-heading">
            <code class="highlight language-python">xor(a, b)</code>

</h2>


    <div class="doc doc-contents ">

        <p>XOR two bytestrings together.</p>
<p>If two bytestrings are not the same length, the result will be
truncated to the length of the shorter string.</p>
<pre><code>&gt;&gt;&gt; xor("\x01\x02", "\x03\x04")
'\x02\x06'
</code></pre>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>a</code></b>
              –
              <div class="doc-md-description">
                <p>the first bytestring.</p>
              </div>
            </li>
            <li>
              <b><code>b</code></b>
              –
              <div class="doc-md-description">
                <p>the second bytestring.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>ghidralib.py</code></summary>
              <pre class="highlight"><code class="language-python">def xor(a, b):  # type: (bytes, bytes) -&gt; bytes
    """XOR two bytestrings together.

    If two bytestrings are not the same length, the result will be
    truncated to the length of the shorter string.

        &gt;&gt;&gt; xor("\\x01\\x02", "\\x03\\x04")
        '\\x02\\x06'

    :param a: the first bytestring.
    :param b: the second bytestring."""
    al = _bytes_as_list(a)
    bl = _bytes_as_list(b)
    return _asbytes("".join(chr(x ^ y) for x, y in zip(al, bl)))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../getting_started/" class="btn btn-neutral float-left" title="Getting Started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../getting_started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
