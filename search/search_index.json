{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Project API Documentation ghidralib Addr = GenericAddress | int | str module-attribute Reg = GhRegister | str module-attribute long = int module-attribute BasicBlock Bases: GhidraWrapper Source code in ghidralib.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 class BasicBlock ( GhidraWrapper ): def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def start_address ( self ): # type: () -> int return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def destinations ( self ): # type: () -> list[BasicBlock] raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ] destinations property end_address property instructions property sources property start_address property __init__ ( raw_or_address ) Source code in ghidralib.py 512 513 514 515 516 517 518 519 520 def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore DataType Bases: GhidraWrapper Source code in ghidralib.py 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 class DataType ( GhidraWrapper ): def __init__ ( self , raw_or_name ): # type: (JavaObject|str) -> None if isinstance ( raw_or_name , str ): raw = get_data_type_ ( raw_or_name ) . raw else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type\"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt name property Get a name of this data type __init__ ( raw_or_name ) Source code in ghidralib.py 834 835 836 837 838 839 def __init__ ( self , raw_or_name ): # type: (JavaObject|str) -> None if isinstance ( raw_or_name , str ): raw = get_data_type_ ( raw_or_name ) . raw else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) from_c ( c_code , insert = True ) staticmethod Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; Source code in ghidralib.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt get_name ( value ) Get Enum name for a given value Source code in ghidralib.py 846 847 848 def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) Emulator Bases: GhidraWrapper Source code in ghidralib.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 class Emulator ( GhidraWrapper ): def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state pc property __init__ () Source code in ghidralib.py 886 887 888 def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) emulate ( start , end ) Source code in ghidralib.py 914 915 916 917 918 919 920 921 922 def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) get_bytes ( address , length ) Source code in ghidralib.py 904 905 906 def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) propagate_varnodes ( start , end ) Source code in ghidralib.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state read_memory ( address , length ) Source code in ghidralib.py 908 909 def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) read_register ( reg ) Source code in ghidralib.py 898 899 def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) read_varnode ( varnode ) Source code in ghidralib.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) set_pc ( address ) Source code in ghidralib.py 894 895 896 def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) trace_pcode ( start , end , callback ) Source code in ghidralib.py 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () write_memory ( address , value ) Source code in ghidralib.py 911 912 def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) write_register ( reg , value ) Source code in ghidralib.py 901 902 def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) Function Bases: GhidraWrapper Source code in ghidralib.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 class Function ( GhidraWrapper ): def __init__ ( self , raw_name_or_address ): # type: (JavaObject|int|str) -> None if isinstance ( raw_name_or_address , ( str , int )): raw = get_function_ ( raw_name_or_address ) . raw else : raw = raw_name_or_address GhidraWrapper . __init__ ( self , raw ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) address property basicblocks property called property callers property calls property comment property entrypoint property fixup property writable high_pcode property instructions property is_external property is_thunk property local_variables property name property parameters property repeatable_comment property return_type property return_variable property variables property xref_addrs property xrefs property __init__ ( raw_name_or_address ) Source code in ghidralib.py 652 653 654 655 656 657 def __init__ ( self , raw_name_or_address ): # type: (JavaObject|int|str) -> None if isinstance ( raw_name_or_address , ( str , int )): raw = get_function_ ( raw_name_or_address ) . raw else : raw = raw_name_or_address GhidraWrapper . __init__ ( self , raw ) decompile () Source code in ghidralib.py 776 777 778 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () get_high_function ( simplify = 'decompile' ) Source code in ghidralib.py 780 781 782 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) get_high_pcode ( simplify = 'decompile' ) Source code in ghidralib.py 784 785 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode get_high_pcode_at ( address ) Source code in ghidralib.py 791 792 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) rename ( name ) Source code in ghidralib.py 713 714 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) set_comment ( comment ) Source code in ghidralib.py 683 684 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) set_repeatable_comment ( comment ) Source code in ghidralib.py 698 699 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) FunctionCall Source code in ghidralib.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 class FunctionCall : def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args address = resolve ( address ) instance-attribute function = function instance-attribute __init__ ( function , address ) Source code in ghidralib.py 602 603 604 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) emulate () Source code in ghidralib.py 619 620 621 622 623 def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu get_args ( emulate = True ) Source code in ghidralib.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args get_args_as_varnodes () Source code in ghidralib.py 625 626 627 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr get_high_pcode () Source code in ghidralib.py 606 607 608 609 610 611 612 def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) get_varnodes () Source code in ghidralib.py 614 615 616 617 def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) GhidraWrapper Source code in ghidralib.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class GhidraWrapper : def __init__ ( self , raw ): # type: (JavaObject) -> None assert raw is not None self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = raw def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __repr__ = raw . __repr__ instance-attribute __str__ = raw . __str__ instance-attribute raw = raw instance-attribute __eq__ ( other ) Source code in ghidralib.py 109 110 111 112 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __hash__ () Source code in ghidralib.py 106 107 def __hash__ ( self ): # type: () -> int return self . raw . hashCode () __init__ ( raw ) Source code in ghidralib.py 96 97 98 99 100 def __init__ ( self , raw ): # type: (JavaObject) -> None assert raw is not None self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = raw __tojava__ ( klass ) Make it possible to pass this object to Java methods Source code in ghidralib.py 102 103 104 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw HighFunction Bases: GhidraWrapper Source code in ghidralib.py 292 293 294 295 296 297 298 299 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] pcode property get_pcode_at ( address ) Source code in ghidralib.py 293 294 295 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] HighSymbol Bases: GhidraWrapper Source code in ghidralib.py 124 125 126 127 128 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED ) rename ( new_name ) Source code in ghidralib.py 125 126 127 128 def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED ) HighVariable Bases: GhidraWrapper Source code in ghidralib.py 115 116 117 118 119 120 121 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) symbol property rename ( new_name ) Source code in ghidralib.py 120 121 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) Instruction Bases: GhidraWrapper Source code in ghidralib.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Instruction ( GhidraWrapper ): def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] return get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) @property def address ( self ): # type: () -> int return self . raw . getAddress () @property def flow ( self ): # type: () -> RefType return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) address property flow property high_pcode property mnemonic property next property pcode property previous property xrefs_from property __init__ ( raw_or_address ) Source code in ghidralib.py 451 452 453 454 455 456 def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore add_operand_reference ( op_ndx , ref_addr , ref_type , src_type ) Source code in ghidralib.py 504 505 506 507 508 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) get_scalar ( ndx ) Source code in ghidralib.py 485 486 487 488 489 490 491 492 493 def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) to_bytes () Source code in ghidralib.py 482 483 def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () JavaObject Source code in ghidralib.py 36 37 38 class JavaObject : def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing __getattribute__ ( name ) Source code in ghidralib.py 37 38 def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing Parameter Bases: Variable Source code in ghidralib.py 591 592 593 594 595 596 597 598 class Parameter ( Variable ): @property def ordinal ( self ): # type: () -> int return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType return DataType ( self . raw . getFormalDataType ()) formal_data_type property ordinal property PcodeOp Bases: GhidraWrapper Source code in ghidralib.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class PcodeOp ( GhidraWrapper ): UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ()) BOOL_AND = 39 class-attribute instance-attribute BOOL_NEGATE = 37 class-attribute instance-attribute BOOL_OR = 40 class-attribute instance-attribute BOOL_XOR = 38 class-attribute instance-attribute BRANCH = 4 class-attribute instance-attribute BRANCHIND = 6 class-attribute instance-attribute CALL = 7 class-attribute instance-attribute CALLIND = 8 class-attribute instance-attribute CALLOTHER = 9 class-attribute instance-attribute CAST = 64 class-attribute instance-attribute CBRANCH = 5 class-attribute instance-attribute COPY = 1 class-attribute instance-attribute CPOOLREF = 68 class-attribute instance-attribute EXTRACT = 71 class-attribute instance-attribute FLOAT_ABS = 52 class-attribute instance-attribute FLOAT_ADD = 47 class-attribute instance-attribute FLOAT_CEIL = 57 class-attribute instance-attribute FLOAT_DIV = 48 class-attribute instance-attribute FLOAT_EQUAL = 41 class-attribute instance-attribute FLOAT_FLOAT2FLOAT = 55 class-attribute instance-attribute FLOAT_FLOOR = 58 class-attribute instance-attribute FLOAT_INT2FLOAT = 54 class-attribute instance-attribute FLOAT_LESS = 43 class-attribute instance-attribute FLOAT_LESSEQUAL = 44 class-attribute instance-attribute FLOAT_MULT = 49 class-attribute instance-attribute FLOAT_NAN = 46 class-attribute instance-attribute FLOAT_NEG = 51 class-attribute instance-attribute FLOAT_NOTEQUAL = 42 class-attribute instance-attribute FLOAT_ROUND = 59 class-attribute instance-attribute FLOAT_SQRT = 53 class-attribute instance-attribute FLOAT_SUB = 50 class-attribute instance-attribute FLOAT_TRUNC = 56 class-attribute instance-attribute INDIRECT = 61 class-attribute instance-attribute INSERT = 70 class-attribute instance-attribute INT_2COMP = 24 class-attribute instance-attribute INT_ADD = 19 class-attribute instance-attribute INT_AND = 27 class-attribute instance-attribute INT_CARRY = 21 class-attribute instance-attribute INT_DIV = 33 class-attribute instance-attribute INT_EQUAL = 11 class-attribute instance-attribute INT_LEFT = 29 class-attribute instance-attribute INT_LESS = 15 class-attribute instance-attribute INT_LESSEQUAL = 16 class-attribute instance-attribute INT_MULT = 32 class-attribute instance-attribute INT_NEGATE = 25 class-attribute instance-attribute INT_NOTEQUAL = 12 class-attribute instance-attribute INT_OR = 28 class-attribute instance-attribute INT_REM = 35 class-attribute instance-attribute INT_RIGHT = 30 class-attribute instance-attribute INT_SBORROW = 23 class-attribute instance-attribute INT_SCARRY = 22 class-attribute instance-attribute INT_SDIV = 34 class-attribute instance-attribute INT_SEXT = 18 class-attribute instance-attribute INT_SLESS = 13 class-attribute instance-attribute INT_SLESSEQUAL = 14 class-attribute instance-attribute INT_SREM = 36 class-attribute instance-attribute INT_SRIGHT = 31 class-attribute instance-attribute INT_SUB = 20 class-attribute instance-attribute INT_XOR = 26 class-attribute instance-attribute INT_ZEXT = 17 class-attribute instance-attribute LOAD = 2 class-attribute instance-attribute LZCOUNT = 73 class-attribute instance-attribute MULTIEQUAL = 60 class-attribute instance-attribute NEW = 69 class-attribute instance-attribute PCODE_MAX = 74 class-attribute instance-attribute PIECE = 62 class-attribute instance-attribute POPCOUNT = 72 class-attribute instance-attribute PTRADD = 65 class-attribute instance-attribute PTRSUB = 66 class-attribute instance-attribute RETURN = 10 class-attribute instance-attribute SEGMENTOP = 67 class-attribute instance-attribute STORE = 3 class-attribute instance-attribute SUBPIECE = 63 class-attribute instance-attribute UNIMPLEMENTED = 0 class-attribute instance-attribute inputs property mnemonic property opcode property output property RefType Bases: GhidraWrapper Source code in ghidralib.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () class-attribute instance-attribute CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () class-attribute instance-attribute CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute FALL_THROUGH = _reftype_placeholder () class-attribute instance-attribute FLOW = _reftype_placeholder () class-attribute instance-attribute INDIRECTION = _reftype_placeholder () class-attribute instance-attribute INVALID = _reftype_placeholder () class-attribute instance-attribute JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute JUMP_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute TERMINATOR = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute has_fall property writable is_call property writable is_computed property writable is_conditional property writable is_data property is_flow property is_jump property writable is_override property is_read property is_terminal property is_unconditional property is_write property Reference Bases: GhidraWrapper Source code in ghidralib.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int return self . raw . getToAddress () . getOffset () from_address property is_call property is_jump property reftype property to_address property Symbol Bases: GhidraWrapper Source code in ghidralib.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 class Symbol ( GhidraWrapper ): def __init__ ( self , raw_or_name ): # type: (JavaObject|str|Addr) -> None if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def address ( self ): # type: () -> int return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None force_create_data ( self . address , datatype ) address property name property name_with_namespace property xref_addrs property xrefs property __init__ ( raw_or_name ) Source code in ghidralib.py 796 797 798 799 800 801 802 803 804 805 806 807 def __init__ ( self , raw_or_name ): # type: (JavaObject|str|Addr) -> None if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) # type: ignore set_type ( datatype ) Source code in ghidralib.py 829 830 def set_type ( self , datatype ): # type: (DataType) -> None force_create_data ( self . address , datatype ) Variable Bases: GhidraWrapper Source code in ghidralib.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 class Variable ( GhidraWrapper ): @property def name ( self ): # type: () -> str return self . raw . getName () @property def data_type ( self ): # type: () -> DataType return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool return self . raw . isValid () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol return Symbol ( self . raw . getSymbol ()) comment property data_type property is_compound property is_memory property is_stack property is_unique property is_valid property name property symbol property set_comment ( comment ) Source code in ghidralib.py 567 568 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) Varnode Bases: GhidraWrapper Source code in ghidralib.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) free property has_value property high property is_address property is_constant property Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value. is_free property is_hash property is_register property is_unique property offset property size property symbol property value property Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value. rename ( new_name ) Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 183 184 185 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) can_resolve ( addr ) Source code in ghidralib.py 77 78 def can_resolve ( addr ): # type: (Addr) -> bool return isinstance ( addr , ( GenericAddress , int , long , str )) collect_iterator ( iterator ) Source code in ghidralib.py 59 60 61 62 63 def collect_iterator ( iterator ): result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result create_data ( address , datatype ) Source code in ghidralib.py 1019 1020 def create_data ( address , datatype ): # type: (Addr, DataType) -> None force_create_data ( address , datatype ) create_function ( address , name ) Source code in ghidralib.py 1005 1006 1007 def create_function ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) create_label ( address , name ) Source code in ghidralib.py 1015 1016 def create_label ( address , name ): # type: (Addr, str) -> Symbol return create_symbol ( address , name ) create_symbol ( address , name ) Source code in ghidralib.py 1010 1011 1012 def create_symbol ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw ) current_location () Source code in ghidralib.py 1051 1052 def current_location (): # type: () -> int return currentLocation . getAddress () . getOffset () force_create_data ( address , datatype ) Source code in ghidralib.py 87 88 89 90 91 92 def force_create_data ( address , datatype ): # type: (Addr, DataType) -> None try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype )) from_bytes ( b ) Source code in ghidralib.py 879 880 881 882 def from_bytes ( b ): # type: (str | list[int]) -> int if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b )) get_bytes ( address , length ) Source code in ghidralib.py 874 875 876 def get_bytes ( address , length ): # type: (Addr, int) -> str address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length )) get_data_type ( name ) Source code in ghidralib.py 1023 1024 1025 1026 1027 1028 1029 1030 def get_data_type ( name ): # type: (str) -> DataType|None managers = state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () managers = [ currentProgram . getDataTypeManager ()] + list ( managers ) for manager in managers : for datatype in manager . getAllDataTypes (): if datatype . getName () == name : return DataType ( datatype ) return None get_data_type_ ( name ) Source code in ghidralib.py 1033 1034 1035 1036 1037 def get_data_type_ ( name ): # type: (str) -> DataType raw = get_data_type ( name ) if raw is None : raise RuntimeError ( \"Failed to get a DataType {} \" . format ( name )) return raw get_function ( address ) Source code in ghidralib.py 991 992 993 994 995 def get_function ( address ): # type: (Addr) -> Function|None raw_func = currentProgram . getListing () . getFunctionContaining ( resolve ( address )) if raw_func is None : return None return Function ( raw_func ) get_function_ ( address ) Source code in ghidralib.py 998 999 1000 1001 1002 def get_function_ ( address ): # type: (Addr) -> Function result = get_function ( address ) if result is None : raise RuntimeError ( \"Failed to get a function at {} \" . format ( address )) return result get_functions () Source code in ghidralib.py 986 987 988 def get_functions (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] get_high_pcode_at ( address ) Source code in ghidralib.py 1040 1041 def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] return get_function_ ( address ) . get_high_pcode_at ( address ) get_string ( address ) Source code in ghidralib.py 1044 1045 1046 1047 1048 def get_string ( address ): # type: (Addr) -> str|None string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None get_u32 ( address ) Source code in ghidralib.py 870 871 def get_u32 ( address ): return from_bytes ( get_bytes ( address , 2 )) resolve ( addr ) Source code in ghidralib.py 66 67 68 69 70 71 72 73 74 def resolve ( addr ): # type: (Addr) -> GenericAddress if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" ) unwrap ( wrapper_or_java_type ) Source code in ghidralib.py 81 82 83 84 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type xor ( a , b ) Source code in ghidralib.py 982 983 def xor ( a , b ): # type: (str, str) -> str return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"Welcome to My Project"},{"location":"#welcome-to-my-project","text":"","title":"Welcome to My Project"},{"location":"#api-documentation","text":"","title":"API Documentation"},{"location":"#ghidralib","text":"","title":"ghidralib"},{"location":"#ghidralib.Addr","text":"","title":"Addr"},{"location":"#ghidralib.Reg","text":"","title":"Reg"},{"location":"#ghidralib.long","text":"","title":"long"},{"location":"#ghidralib.BasicBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 class BasicBlock ( GhidraWrapper ): def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def start_address ( self ): # type: () -> int return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def destinations ( self ): # type: () -> list[BasicBlock] raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ]","title":"BasicBlock"},{"location":"#ghidralib.BasicBlock.destinations","text":"","title":"destinations"},{"location":"#ghidralib.BasicBlock.end_address","text":"","title":"end_address"},{"location":"#ghidralib.BasicBlock.instructions","text":"","title":"instructions"},{"location":"#ghidralib.BasicBlock.sources","text":"","title":"sources"},{"location":"#ghidralib.BasicBlock.start_address","text":"","title":"start_address"},{"location":"#ghidralib.BasicBlock.__init__","text":"Source code in ghidralib.py 512 513 514 515 516 517 518 519 520 def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore","title":"__init__"},{"location":"#ghidralib.DataType","text":"Bases: GhidraWrapper Source code in ghidralib.py 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 class DataType ( GhidraWrapper ): def __init__ ( self , raw_or_name ): # type: (JavaObject|str) -> None if isinstance ( raw_or_name , str ): raw = get_data_type_ ( raw_or_name ) . raw else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type\"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"DataType"},{"location":"#ghidralib.DataType.name","text":"Get a name of this data type","title":"name"},{"location":"#ghidralib.DataType.__init__","text":"Source code in ghidralib.py 834 835 836 837 838 839 def __init__ ( self , raw_or_name ): # type: (JavaObject|str) -> None if isinstance ( raw_or_name , str ): raw = get_data_type_ ( raw_or_name ) . raw else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw )","title":"__init__"},{"location":"#ghidralib.DataType.from_c","text":"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; Source code in ghidralib.py 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"from_c"},{"location":"#ghidralib.DataType.get_name","text":"Get Enum name for a given value Source code in ghidralib.py 846 847 848 def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value )","title":"get_name"},{"location":"#ghidralib.Emulator","text":"Bases: GhidraWrapper Source code in ghidralib.py 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 class Emulator ( GhidraWrapper ): def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"Emulator"},{"location":"#ghidralib.Emulator.pc","text":"","title":"pc"},{"location":"#ghidralib.Emulator.__init__","text":"Source code in ghidralib.py 886 887 888 def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw )","title":"__init__"},{"location":"#ghidralib.Emulator.emulate","text":"Source code in ghidralib.py 914 915 916 917 918 919 920 921 922 def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err ))","title":"emulate"},{"location":"#ghidralib.Emulator.get_bytes","text":"Source code in ghidralib.py 904 905 906 def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist )","title":"get_bytes"},{"location":"#ghidralib.Emulator.propagate_varnodes","text":"Source code in ghidralib.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"propagate_varnodes"},{"location":"#ghidralib.Emulator.read_memory","text":"Source code in ghidralib.py 908 909 def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length )","title":"read_memory"},{"location":"#ghidralib.Emulator.read_register","text":"Source code in ghidralib.py 898 899 def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg )","title":"read_register"},{"location":"#ghidralib.Emulator.read_varnode","text":"Source code in ghidralib.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" )","title":"read_varnode"},{"location":"#ghidralib.Emulator.set_pc","text":"Source code in ghidralib.py 894 895 896 def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address )","title":"set_pc"},{"location":"#ghidralib.Emulator.trace_pcode","text":"Source code in ghidralib.py 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress ()","title":"trace_pcode"},{"location":"#ghidralib.Emulator.write_memory","text":"Source code in ghidralib.py 911 912 def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value )","title":"write_memory"},{"location":"#ghidralib.Emulator.write_register","text":"Source code in ghidralib.py 901 902 def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value )","title":"write_register"},{"location":"#ghidralib.Function","text":"Bases: GhidraWrapper Source code in ghidralib.py 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 class Function ( GhidraWrapper ): def __init__ ( self , raw_name_or_address ): # type: (JavaObject|int|str) -> None if isinstance ( raw_name_or_address , ( str , int )): raw = get_function_ ( raw_name_or_address ) . raw else : raw = raw_name_or_address GhidraWrapper . __init__ ( self , raw ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"Function"},{"location":"#ghidralib.Function.address","text":"","title":"address"},{"location":"#ghidralib.Function.basicblocks","text":"","title":"basicblocks"},{"location":"#ghidralib.Function.called","text":"","title":"called"},{"location":"#ghidralib.Function.callers","text":"","title":"callers"},{"location":"#ghidralib.Function.calls","text":"","title":"calls"},{"location":"#ghidralib.Function.comment","text":"","title":"comment"},{"location":"#ghidralib.Function.entrypoint","text":"","title":"entrypoint"},{"location":"#ghidralib.Function.fixup","text":"","title":"fixup"},{"location":"#ghidralib.Function.high_pcode","text":"","title":"high_pcode"},{"location":"#ghidralib.Function.instructions","text":"","title":"instructions"},{"location":"#ghidralib.Function.is_external","text":"","title":"is_external"},{"location":"#ghidralib.Function.is_thunk","text":"","title":"is_thunk"},{"location":"#ghidralib.Function.local_variables","text":"","title":"local_variables"},{"location":"#ghidralib.Function.name","text":"","title":"name"},{"location":"#ghidralib.Function.parameters","text":"","title":"parameters"},{"location":"#ghidralib.Function.repeatable_comment","text":"","title":"repeatable_comment"},{"location":"#ghidralib.Function.return_type","text":"","title":"return_type"},{"location":"#ghidralib.Function.return_variable","text":"","title":"return_variable"},{"location":"#ghidralib.Function.variables","text":"","title":"variables"},{"location":"#ghidralib.Function.xref_addrs","text":"","title":"xref_addrs"},{"location":"#ghidralib.Function.xrefs","text":"","title":"xrefs"},{"location":"#ghidralib.Function.__init__","text":"Source code in ghidralib.py 652 653 654 655 656 657 def __init__ ( self , raw_name_or_address ): # type: (JavaObject|int|str) -> None if isinstance ( raw_name_or_address , ( str , int )): raw = get_function_ ( raw_name_or_address ) . raw else : raw = raw_name_or_address GhidraWrapper . __init__ ( self , raw )","title":"__init__"},{"location":"#ghidralib.Function.decompile","text":"Source code in ghidralib.py 776 777 778 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC ()","title":"decompile"},{"location":"#ghidralib.Function.get_high_function","text":"Source code in ghidralib.py 780 781 782 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ())","title":"get_high_function"},{"location":"#ghidralib.Function.get_high_pcode","text":"Source code in ghidralib.py 784 785 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode","title":"get_high_pcode"},{"location":"#ghidralib.Function.get_high_pcode_at","text":"Source code in ghidralib.py 791 792 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"#ghidralib.Function.rename","text":"Source code in ghidralib.py 713 714 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED )","title":"rename"},{"location":"#ghidralib.Function.set_comment","text":"Source code in ghidralib.py 683 684 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment )","title":"set_comment"},{"location":"#ghidralib.Function.set_repeatable_comment","text":"Source code in ghidralib.py 698 699 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment )","title":"set_repeatable_comment"},{"location":"#ghidralib.FunctionCall","text":"Source code in ghidralib.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 class FunctionCall : def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"FunctionCall"},{"location":"#ghidralib.FunctionCall.address","text":"","title":"address"},{"location":"#ghidralib.FunctionCall.function","text":"","title":"function"},{"location":"#ghidralib.FunctionCall.__init__","text":"Source code in ghidralib.py 602 603 604 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address )","title":"__init__"},{"location":"#ghidralib.FunctionCall.emulate","text":"Source code in ghidralib.py 619 620 621 622 623 def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu","title":"emulate"},{"location":"#ghidralib.FunctionCall.get_args","text":"Source code in ghidralib.py 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"get_args"},{"location":"#ghidralib.FunctionCall.get_args_as_varnodes","text":"Source code in ghidralib.py 625 626 627 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr","title":"get_args_as_varnodes"},{"location":"#ghidralib.FunctionCall.get_high_pcode","text":"Source code in ghidralib.py 606 607 608 609 610 611 612 def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address )))","title":"get_high_pcode"},{"location":"#ghidralib.FunctionCall.get_varnodes","text":"Source code in ghidralib.py 614 615 616 617 def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address )","title":"get_varnodes"},{"location":"#ghidralib.GhidraWrapper","text":"Source code in ghidralib.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class GhidraWrapper : def __init__ ( self , raw ): # type: (JavaObject) -> None assert raw is not None self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = raw def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"GhidraWrapper"},{"location":"#ghidralib.GhidraWrapper.__repr__","text":"","title":"__repr__"},{"location":"#ghidralib.GhidraWrapper.__str__","text":"","title":"__str__"},{"location":"#ghidralib.GhidraWrapper.raw","text":"","title":"raw"},{"location":"#ghidralib.GhidraWrapper.__eq__","text":"Source code in ghidralib.py 109 110 111 112 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"__eq__"},{"location":"#ghidralib.GhidraWrapper.__hash__","text":"Source code in ghidralib.py 106 107 def __hash__ ( self ): # type: () -> int return self . raw . hashCode ()","title":"__hash__"},{"location":"#ghidralib.GhidraWrapper.__init__","text":"Source code in ghidralib.py 96 97 98 99 100 def __init__ ( self , raw ): # type: (JavaObject) -> None assert raw is not None self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = raw","title":"__init__"},{"location":"#ghidralib.GhidraWrapper.__tojava__","text":"Make it possible to pass this object to Java methods Source code in ghidralib.py 102 103 104 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw","title":"__tojava__"},{"location":"#ghidralib.HighFunction","text":"Bases: GhidraWrapper Source code in ghidralib.py 292 293 294 295 296 297 298 299 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()]","title":"HighFunction"},{"location":"#ghidralib.HighFunction.pcode","text":"","title":"pcode"},{"location":"#ghidralib.HighFunction.get_pcode_at","text":"Source code in ghidralib.py 293 294 295 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )]","title":"get_pcode_at"},{"location":"#ghidralib.HighSymbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 124 125 126 127 128 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED )","title":"HighSymbol"},{"location":"#ghidralib.HighSymbol.rename","text":"Source code in ghidralib.py 125 126 127 128 def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED )","title":"rename"},{"location":"#ghidralib.HighVariable","text":"Bases: GhidraWrapper Source code in ghidralib.py 115 116 117 118 119 120 121 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"HighVariable"},{"location":"#ghidralib.HighVariable.symbol","text":"","title":"symbol"},{"location":"#ghidralib.HighVariable.rename","text":"Source code in ghidralib.py 120 121 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"rename"},{"location":"#ghidralib.Instruction","text":"Bases: GhidraWrapper Source code in ghidralib.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 class Instruction ( GhidraWrapper ): def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] return get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) @property def address ( self ): # type: () -> int return self . raw . getAddress () @property def flow ( self ): # type: () -> RefType return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"Instruction"},{"location":"#ghidralib.Instruction.address","text":"","title":"address"},{"location":"#ghidralib.Instruction.flow","text":"","title":"flow"},{"location":"#ghidralib.Instruction.high_pcode","text":"","title":"high_pcode"},{"location":"#ghidralib.Instruction.mnemonic","text":"","title":"mnemonic"},{"location":"#ghidralib.Instruction.next","text":"","title":"next"},{"location":"#ghidralib.Instruction.pcode","text":"","title":"pcode"},{"location":"#ghidralib.Instruction.previous","text":"","title":"previous"},{"location":"#ghidralib.Instruction.xrefs_from","text":"","title":"xrefs_from"},{"location":"#ghidralib.Instruction.__init__","text":"Source code in ghidralib.py 451 452 453 454 455 456 def __init__ ( self , raw_or_address ): # type: (JavaObject|Addr) -> None if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address GhidraWrapper . __init__ ( self , raw ) # type: ignore","title":"__init__"},{"location":"#ghidralib.Instruction.add_operand_reference","text":"Source code in ghidralib.py 504 505 506 507 508 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"add_operand_reference"},{"location":"#ghidralib.Instruction.get_scalar","text":"Source code in ghidralib.py 485 486 487 488 489 490 491 492 493 def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj )","title":"get_scalar"},{"location":"#ghidralib.Instruction.to_bytes","text":"Source code in ghidralib.py 482 483 def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes ()","title":"to_bytes"},{"location":"#ghidralib.JavaObject","text":"Source code in ghidralib.py 36 37 38 class JavaObject : def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing","title":"JavaObject"},{"location":"#ghidralib.JavaObject.__getattribute__","text":"Source code in ghidralib.py 37 38 def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing","title":"__getattribute__"},{"location":"#ghidralib.Parameter","text":"Bases: Variable Source code in ghidralib.py 591 592 593 594 595 596 597 598 class Parameter ( Variable ): @property def ordinal ( self ): # type: () -> int return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType return DataType ( self . raw . getFormalDataType ())","title":"Parameter"},{"location":"#ghidralib.Parameter.formal_data_type","text":"","title":"formal_data_type"},{"location":"#ghidralib.Parameter.ordinal","text":"","title":"ordinal"},{"location":"#ghidralib.PcodeOp","text":"Bases: GhidraWrapper Source code in ghidralib.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class PcodeOp ( GhidraWrapper ): UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ())","title":"PcodeOp"},{"location":"#ghidralib.PcodeOp.BOOL_AND","text":"","title":"BOOL_AND"},{"location":"#ghidralib.PcodeOp.BOOL_NEGATE","text":"","title":"BOOL_NEGATE"},{"location":"#ghidralib.PcodeOp.BOOL_OR","text":"","title":"BOOL_OR"},{"location":"#ghidralib.PcodeOp.BOOL_XOR","text":"","title":"BOOL_XOR"},{"location":"#ghidralib.PcodeOp.BRANCH","text":"","title":"BRANCH"},{"location":"#ghidralib.PcodeOp.BRANCHIND","text":"","title":"BRANCHIND"},{"location":"#ghidralib.PcodeOp.CALL","text":"","title":"CALL"},{"location":"#ghidralib.PcodeOp.CALLIND","text":"","title":"CALLIND"},{"location":"#ghidralib.PcodeOp.CALLOTHER","text":"","title":"CALLOTHER"},{"location":"#ghidralib.PcodeOp.CAST","text":"","title":"CAST"},{"location":"#ghidralib.PcodeOp.CBRANCH","text":"","title":"CBRANCH"},{"location":"#ghidralib.PcodeOp.COPY","text":"","title":"COPY"},{"location":"#ghidralib.PcodeOp.CPOOLREF","text":"","title":"CPOOLREF"},{"location":"#ghidralib.PcodeOp.EXTRACT","text":"","title":"EXTRACT"},{"location":"#ghidralib.PcodeOp.FLOAT_ABS","text":"","title":"FLOAT_ABS"},{"location":"#ghidralib.PcodeOp.FLOAT_ADD","text":"","title":"FLOAT_ADD"},{"location":"#ghidralib.PcodeOp.FLOAT_CEIL","text":"","title":"FLOAT_CEIL"},{"location":"#ghidralib.PcodeOp.FLOAT_DIV","text":"","title":"FLOAT_DIV"},{"location":"#ghidralib.PcodeOp.FLOAT_EQUAL","text":"","title":"FLOAT_EQUAL"},{"location":"#ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT","text":"","title":"FLOAT_FLOAT2FLOAT"},{"location":"#ghidralib.PcodeOp.FLOAT_FLOOR","text":"","title":"FLOAT_FLOOR"},{"location":"#ghidralib.PcodeOp.FLOAT_INT2FLOAT","text":"","title":"FLOAT_INT2FLOAT"},{"location":"#ghidralib.PcodeOp.FLOAT_LESS","text":"","title":"FLOAT_LESS"},{"location":"#ghidralib.PcodeOp.FLOAT_LESSEQUAL","text":"","title":"FLOAT_LESSEQUAL"},{"location":"#ghidralib.PcodeOp.FLOAT_MULT","text":"","title":"FLOAT_MULT"},{"location":"#ghidralib.PcodeOp.FLOAT_NAN","text":"","title":"FLOAT_NAN"},{"location":"#ghidralib.PcodeOp.FLOAT_NEG","text":"","title":"FLOAT_NEG"},{"location":"#ghidralib.PcodeOp.FLOAT_NOTEQUAL","text":"","title":"FLOAT_NOTEQUAL"},{"location":"#ghidralib.PcodeOp.FLOAT_ROUND","text":"","title":"FLOAT_ROUND"},{"location":"#ghidralib.PcodeOp.FLOAT_SQRT","text":"","title":"FLOAT_SQRT"},{"location":"#ghidralib.PcodeOp.FLOAT_SUB","text":"","title":"FLOAT_SUB"},{"location":"#ghidralib.PcodeOp.FLOAT_TRUNC","text":"","title":"FLOAT_TRUNC"},{"location":"#ghidralib.PcodeOp.INDIRECT","text":"","title":"INDIRECT"},{"location":"#ghidralib.PcodeOp.INSERT","text":"","title":"INSERT"},{"location":"#ghidralib.PcodeOp.INT_2COMP","text":"","title":"INT_2COMP"},{"location":"#ghidralib.PcodeOp.INT_ADD","text":"","title":"INT_ADD"},{"location":"#ghidralib.PcodeOp.INT_AND","text":"","title":"INT_AND"},{"location":"#ghidralib.PcodeOp.INT_CARRY","text":"","title":"INT_CARRY"},{"location":"#ghidralib.PcodeOp.INT_DIV","text":"","title":"INT_DIV"},{"location":"#ghidralib.PcodeOp.INT_EQUAL","text":"","title":"INT_EQUAL"},{"location":"#ghidralib.PcodeOp.INT_LEFT","text":"","title":"INT_LEFT"},{"location":"#ghidralib.PcodeOp.INT_LESS","text":"","title":"INT_LESS"},{"location":"#ghidralib.PcodeOp.INT_LESSEQUAL","text":"","title":"INT_LESSEQUAL"},{"location":"#ghidralib.PcodeOp.INT_MULT","text":"","title":"INT_MULT"},{"location":"#ghidralib.PcodeOp.INT_NEGATE","text":"","title":"INT_NEGATE"},{"location":"#ghidralib.PcodeOp.INT_NOTEQUAL","text":"","title":"INT_NOTEQUAL"},{"location":"#ghidralib.PcodeOp.INT_OR","text":"","title":"INT_OR"},{"location":"#ghidralib.PcodeOp.INT_REM","text":"","title":"INT_REM"},{"location":"#ghidralib.PcodeOp.INT_RIGHT","text":"","title":"INT_RIGHT"},{"location":"#ghidralib.PcodeOp.INT_SBORROW","text":"","title":"INT_SBORROW"},{"location":"#ghidralib.PcodeOp.INT_SCARRY","text":"","title":"INT_SCARRY"},{"location":"#ghidralib.PcodeOp.INT_SDIV","text":"","title":"INT_SDIV"},{"location":"#ghidralib.PcodeOp.INT_SEXT","text":"","title":"INT_SEXT"},{"location":"#ghidralib.PcodeOp.INT_SLESS","text":"","title":"INT_SLESS"},{"location":"#ghidralib.PcodeOp.INT_SLESSEQUAL","text":"","title":"INT_SLESSEQUAL"},{"location":"#ghidralib.PcodeOp.INT_SREM","text":"","title":"INT_SREM"},{"location":"#ghidralib.PcodeOp.INT_SRIGHT","text":"","title":"INT_SRIGHT"},{"location":"#ghidralib.PcodeOp.INT_SUB","text":"","title":"INT_SUB"},{"location":"#ghidralib.PcodeOp.INT_XOR","text":"","title":"INT_XOR"},{"location":"#ghidralib.PcodeOp.INT_ZEXT","text":"","title":"INT_ZEXT"},{"location":"#ghidralib.PcodeOp.LOAD","text":"","title":"LOAD"},{"location":"#ghidralib.PcodeOp.LZCOUNT","text":"","title":"LZCOUNT"},{"location":"#ghidralib.PcodeOp.MULTIEQUAL","text":"","title":"MULTIEQUAL"},{"location":"#ghidralib.PcodeOp.NEW","text":"","title":"NEW"},{"location":"#ghidralib.PcodeOp.PCODE_MAX","text":"","title":"PCODE_MAX"},{"location":"#ghidralib.PcodeOp.PIECE","text":"","title":"PIECE"},{"location":"#ghidralib.PcodeOp.POPCOUNT","text":"","title":"POPCOUNT"},{"location":"#ghidralib.PcodeOp.PTRADD","text":"","title":"PTRADD"},{"location":"#ghidralib.PcodeOp.PTRSUB","text":"","title":"PTRSUB"},{"location":"#ghidralib.PcodeOp.RETURN","text":"","title":"RETURN"},{"location":"#ghidralib.PcodeOp.SEGMENTOP","text":"","title":"SEGMENTOP"},{"location":"#ghidralib.PcodeOp.STORE","text":"","title":"STORE"},{"location":"#ghidralib.PcodeOp.SUBPIECE","text":"","title":"SUBPIECE"},{"location":"#ghidralib.PcodeOp.UNIMPLEMENTED","text":"","title":"UNIMPLEMENTED"},{"location":"#ghidralib.PcodeOp.inputs","text":"","title":"inputs"},{"location":"#ghidralib.PcodeOp.mnemonic","text":"","title":"mnemonic"},{"location":"#ghidralib.PcodeOp.opcode","text":"","title":"opcode"},{"location":"#ghidralib.PcodeOp.output","text":"","title":"output"},{"location":"#ghidralib.RefType","text":"Bases: GhidraWrapper Source code in ghidralib.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder ()","title":"RefType"},{"location":"#ghidralib.RefType.CALLOTHER_OVERRIDE_CALL","text":"","title":"CALLOTHER_OVERRIDE_CALL"},{"location":"#ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP","text":"","title":"CALLOTHER_OVERRIDE_JUMP"},{"location":"#ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL","text":"","title":"CALL_OVERRIDE_UNCONDITIONAL"},{"location":"#ghidralib.RefType.CALL_TERMINATOR","text":"","title":"CALL_TERMINATOR"},{"location":"#ghidralib.RefType.COMPUTED_CALL","text":"","title":"COMPUTED_CALL"},{"location":"#ghidralib.RefType.COMPUTED_CALL_TERMINATOR","text":"","title":"COMPUTED_CALL_TERMINATOR"},{"location":"#ghidralib.RefType.COMPUTED_JUMP","text":"","title":"COMPUTED_JUMP"},{"location":"#ghidralib.RefType.CONDITIONAL_CALL","text":"","title":"CONDITIONAL_CALL"},{"location":"#ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR","text":"","title":"CONDITIONAL_CALL_TERMINATOR"},{"location":"#ghidralib.RefType.CONDITIONAL_COMPUTED_CALL","text":"","title":"CONDITIONAL_COMPUTED_CALL"},{"location":"#ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP","text":"","title":"CONDITIONAL_COMPUTED_JUMP"},{"location":"#ghidralib.RefType.CONDITIONAL_JUMP","text":"","title":"CONDITIONAL_JUMP"},{"location":"#ghidralib.RefType.CONDITIONAL_TERMINATOR","text":"","title":"CONDITIONAL_TERMINATOR"},{"location":"#ghidralib.RefType.FALL_THROUGH","text":"","title":"FALL_THROUGH"},{"location":"#ghidralib.RefType.FLOW","text":"","title":"FLOW"},{"location":"#ghidralib.RefType.INDIRECTION","text":"","title":"INDIRECTION"},{"location":"#ghidralib.RefType.INVALID","text":"","title":"INVALID"},{"location":"#ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL","text":"","title":"JUMP_OVERRIDE_UNCONDITIONAL"},{"location":"#ghidralib.RefType.JUMP_TERMINATOR","text":"","title":"JUMP_TERMINATOR"},{"location":"#ghidralib.RefType.TERMINATOR","text":"","title":"TERMINATOR"},{"location":"#ghidralib.RefType.UNCONDITIONAL_CALL","text":"","title":"UNCONDITIONAL_CALL"},{"location":"#ghidralib.RefType.UNCONDITIONAL_JUMP","text":"","title":"UNCONDITIONAL_JUMP"},{"location":"#ghidralib.RefType.has_fall","text":"","title":"has_fall"},{"location":"#ghidralib.RefType.is_call","text":"","title":"is_call"},{"location":"#ghidralib.RefType.is_computed","text":"","title":"is_computed"},{"location":"#ghidralib.RefType.is_conditional","text":"","title":"is_conditional"},{"location":"#ghidralib.RefType.is_data","text":"","title":"is_data"},{"location":"#ghidralib.RefType.is_flow","text":"","title":"is_flow"},{"location":"#ghidralib.RefType.is_jump","text":"","title":"is_jump"},{"location":"#ghidralib.RefType.is_override","text":"","title":"is_override"},{"location":"#ghidralib.RefType.is_read","text":"","title":"is_read"},{"location":"#ghidralib.RefType.is_terminal","text":"","title":"is_terminal"},{"location":"#ghidralib.RefType.is_unconditional","text":"","title":"is_unconditional"},{"location":"#ghidralib.RefType.is_write","text":"","title":"is_write"},{"location":"#ghidralib.Reference","text":"Bases: GhidraWrapper Source code in ghidralib.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int return self . raw . getToAddress () . getOffset ()","title":"Reference"},{"location":"#ghidralib.Reference.from_address","text":"","title":"from_address"},{"location":"#ghidralib.Reference.is_call","text":"","title":"is_call"},{"location":"#ghidralib.Reference.is_jump","text":"","title":"is_jump"},{"location":"#ghidralib.Reference.reftype","text":"","title":"reftype"},{"location":"#ghidralib.Reference.to_address","text":"","title":"to_address"},{"location":"#ghidralib.Symbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 class Symbol ( GhidraWrapper ): def __init__ ( self , raw_or_name ): # type: (JavaObject|str|Addr) -> None if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) # type: ignore @property def address ( self ): # type: () -> int return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None force_create_data ( self . address , datatype )","title":"Symbol"},{"location":"#ghidralib.Symbol.address","text":"","title":"address"},{"location":"#ghidralib.Symbol.name","text":"","title":"name"},{"location":"#ghidralib.Symbol.name_with_namespace","text":"","title":"name_with_namespace"},{"location":"#ghidralib.Symbol.xref_addrs","text":"","title":"xref_addrs"},{"location":"#ghidralib.Symbol.xrefs","text":"","title":"xrefs"},{"location":"#ghidralib.Symbol.__init__","text":"Source code in ghidralib.py 796 797 798 799 800 801 802 803 804 805 806 807 def __init__ ( self , raw_or_name ): # type: (JavaObject|str|Addr) -> None if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name GhidraWrapper . __init__ ( self , raw ) # type: ignore","title":"__init__"},{"location":"#ghidralib.Symbol.set_type","text":"Source code in ghidralib.py 829 830 def set_type ( self , datatype ): # type: (DataType) -> None force_create_data ( self . address , datatype )","title":"set_type"},{"location":"#ghidralib.Variable","text":"Bases: GhidraWrapper Source code in ghidralib.py 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 class Variable ( GhidraWrapper ): @property def name ( self ): # type: () -> str return self . raw . getName () @property def data_type ( self ): # type: () -> DataType return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool return self . raw . isValid () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol return Symbol ( self . raw . getSymbol ())","title":"Variable"},{"location":"#ghidralib.Variable.comment","text":"","title":"comment"},{"location":"#ghidralib.Variable.data_type","text":"","title":"data_type"},{"location":"#ghidralib.Variable.is_compound","text":"","title":"is_compound"},{"location":"#ghidralib.Variable.is_memory","text":"","title":"is_memory"},{"location":"#ghidralib.Variable.is_stack","text":"","title":"is_stack"},{"location":"#ghidralib.Variable.is_unique","text":"","title":"is_unique"},{"location":"#ghidralib.Variable.is_valid","text":"","title":"is_valid"},{"location":"#ghidralib.Variable.name","text":"","title":"name"},{"location":"#ghidralib.Variable.symbol","text":"","title":"symbol"},{"location":"#ghidralib.Variable.set_comment","text":"Source code in ghidralib.py 567 568 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment )","title":"set_comment"},{"location":"#ghidralib.Varnode","text":"Bases: GhidraWrapper Source code in ghidralib.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ()))","title":"Varnode"},{"location":"#ghidralib.Varnode.free","text":"","title":"free"},{"location":"#ghidralib.Varnode.has_value","text":"","title":"has_value"},{"location":"#ghidralib.Varnode.high","text":"","title":"high"},{"location":"#ghidralib.Varnode.is_address","text":"","title":"is_address"},{"location":"#ghidralib.Varnode.is_constant","text":"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.","title":"is_constant"},{"location":"#ghidralib.Varnode.is_free","text":"","title":"is_free"},{"location":"#ghidralib.Varnode.is_hash","text":"","title":"is_hash"},{"location":"#ghidralib.Varnode.is_register","text":"","title":"is_register"},{"location":"#ghidralib.Varnode.is_unique","text":"","title":"is_unique"},{"location":"#ghidralib.Varnode.offset","text":"","title":"offset"},{"location":"#ghidralib.Varnode.size","text":"","title":"size"},{"location":"#ghidralib.Varnode.symbol","text":"","title":"symbol"},{"location":"#ghidralib.Varnode.value","text":"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.","title":"value"},{"location":"#ghidralib.Varnode.rename","text":"Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 183 184 185 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name )","title":"rename"},{"location":"#ghidralib.can_resolve","text":"Source code in ghidralib.py 77 78 def can_resolve ( addr ): # type: (Addr) -> bool return isinstance ( addr , ( GenericAddress , int , long , str ))","title":"can_resolve"},{"location":"#ghidralib.collect_iterator","text":"Source code in ghidralib.py 59 60 61 62 63 def collect_iterator ( iterator ): result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result","title":"collect_iterator"},{"location":"#ghidralib.create_data","text":"Source code in ghidralib.py 1019 1020 def create_data ( address , datatype ): # type: (Addr, DataType) -> None force_create_data ( address , datatype )","title":"create_data"},{"location":"#ghidralib.create_function","text":"Source code in ghidralib.py 1005 1006 1007 def create_function ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func )","title":"create_function"},{"location":"#ghidralib.create_label","text":"Source code in ghidralib.py 1015 1016 def create_label ( address , name ): # type: (Addr, str) -> Symbol return create_symbol ( address , name )","title":"create_label"},{"location":"#ghidralib.create_symbol","text":"Source code in ghidralib.py 1010 1011 1012 def create_symbol ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw )","title":"create_symbol"},{"location":"#ghidralib.current_location","text":"Source code in ghidralib.py 1051 1052 def current_location (): # type: () -> int return currentLocation . getAddress () . getOffset ()","title":"current_location"},{"location":"#ghidralib.force_create_data","text":"Source code in ghidralib.py 87 88 89 90 91 92 def force_create_data ( address , datatype ): # type: (Addr, DataType) -> None try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype ))","title":"force_create_data"},{"location":"#ghidralib.from_bytes","text":"Source code in ghidralib.py 879 880 881 882 def from_bytes ( b ): # type: (str | list[int]) -> int if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b ))","title":"from_bytes"},{"location":"#ghidralib.get_bytes","text":"Source code in ghidralib.py 874 875 876 def get_bytes ( address , length ): # type: (Addr, int) -> str address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length ))","title":"get_bytes"},{"location":"#ghidralib.get_data_type","text":"Source code in ghidralib.py 1023 1024 1025 1026 1027 1028 1029 1030 def get_data_type ( name ): # type: (str) -> DataType|None managers = state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () managers = [ currentProgram . getDataTypeManager ()] + list ( managers ) for manager in managers : for datatype in manager . getAllDataTypes (): if datatype . getName () == name : return DataType ( datatype ) return None","title":"get_data_type"},{"location":"#ghidralib.get_data_type_","text":"Source code in ghidralib.py 1033 1034 1035 1036 1037 def get_data_type_ ( name ): # type: (str) -> DataType raw = get_data_type ( name ) if raw is None : raise RuntimeError ( \"Failed to get a DataType {} \" . format ( name )) return raw","title":"get_data_type_"},{"location":"#ghidralib.get_function","text":"Source code in ghidralib.py 991 992 993 994 995 def get_function ( address ): # type: (Addr) -> Function|None raw_func = currentProgram . getListing () . getFunctionContaining ( resolve ( address )) if raw_func is None : return None return Function ( raw_func )","title":"get_function"},{"location":"#ghidralib.get_function_","text":"Source code in ghidralib.py 998 999 1000 1001 1002 def get_function_ ( address ): # type: (Addr) -> Function result = get_function ( address ) if result is None : raise RuntimeError ( \"Failed to get a function at {} \" . format ( address )) return result","title":"get_function_"},{"location":"#ghidralib.get_functions","text":"Source code in ghidralib.py 986 987 988 def get_functions (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ]","title":"get_functions"},{"location":"#ghidralib.get_high_pcode_at","text":"Source code in ghidralib.py 1040 1041 def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] return get_function_ ( address ) . get_high_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"#ghidralib.get_string","text":"Source code in ghidralib.py 1044 1045 1046 1047 1048 def get_string ( address ): # type: (Addr) -> str|None string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None","title":"get_string"},{"location":"#ghidralib.get_u32","text":"Source code in ghidralib.py 870 871 def get_u32 ( address ): return from_bytes ( get_bytes ( address , 2 ))","title":"get_u32"},{"location":"#ghidralib.resolve","text":"Source code in ghidralib.py 66 67 68 69 70 71 72 73 74 def resolve ( addr ): # type: (Addr) -> GenericAddress if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" )","title":"resolve"},{"location":"#ghidralib.unwrap","text":"Source code in ghidralib.py 81 82 83 84 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type","title":"unwrap"},{"location":"#ghidralib.xor","text":"Source code in ghidralib.py 982 983 def xor ( a , b ): # type: (str, str) -> str return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"xor"}]}