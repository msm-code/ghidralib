{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index Welcome to ghidralib documentation! This library is an attempt to provide a Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (no static type-checking) and with camelCaseEverywhere. The goal of this library is to make scripting easier and... fun. for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args)) Basic Usage This section contains a few small snippets to get you started. For actually useful examples, check out the examples directory on Github. For more in-depth explanation of the API, check out the program model section. General conventions There are a few conventions that this library follows, and which may be useful when orienting yourself in it: Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"#welcome-to-ghidralib-documentation","text":"This library is an attempt to provide a Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (no static type-checking) and with camelCaseEverywhere. The goal of this library is to make scripting easier and... fun. for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args))","title":"Welcome to ghidralib documentation!"},{"location":"#basic-usage","text":"This section contains a few small snippets to get you started. For actually useful examples, check out the examples directory on Github. For more in-depth explanation of the API, check out the program model section.","title":"Basic Usage"},{"location":"#general-conventions","text":"There are a few conventions that this library follows, and which may be useful when orienting yourself in it: Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"General conventions"},{"location":"everything/","text":"Ghidralib API Documentation ghidralib This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/. Addr = GenericAddress | int | str module-attribute Reg = GhRegister | str module-attribute long = int module-attribute BasicBlock Bases: GhidraWrapper Source code in ghidralib.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class BasicBlock ( GhidraWrapper ): @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ] destinations property Get a list of basic blocks that this basic block jumps to end_address property Get the address of the last instruction in this basic block. instructions property Get a list of instructions in this basic block. pcode property Get a list of Pcode operations that this basic block was parsed to sources property Get a list of basic blocks that jump to this basic block start_address property Get the address of the first instruction in this basic block. get ( raw_or_address ) staticmethod Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) BlockGraph Bases: PcodeBlock Source code in ghidralib.py 428 429 430 431 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())] blocks property DataType Bases: GhidraWrapper Source code in ghidralib.py 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 class DataType ( GhidraWrapper ): @staticmethod def get ( name ): # type: (str) -> DataType|None for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type\"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt name property Get a name of this data type all ( only_local = False ) staticmethod Source code in ghidralib.py 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes from_c ( c_code , insert = True ) staticmethod Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; Source code in ghidralib.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt get ( name ) staticmethod Source code in ghidralib.py 1046 1047 1048 1049 1050 1051 @staticmethod def get ( name ): # type: (str) -> DataType|None for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None get_name ( value ) Get Enum name for a given value Source code in ghidralib.py 1071 1072 1073 def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) Emulator Bases: GhidraWrapper Source code in ghidralib.py 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 class Emulator ( GhidraWrapper ): def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state pc property __init__ () Source code in ghidralib.py 1096 1097 1098 def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) emulate ( start , end ) Source code in ghidralib.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) get_bytes ( address , length ) Source code in ghidralib.py 1114 1115 1116 def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) propagate_varnodes ( start , end ) Source code in ghidralib.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state read_memory ( address , length ) Source code in ghidralib.py 1118 1119 def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) read_register ( reg ) Source code in ghidralib.py 1108 1109 def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) read_varnode ( varnode ) Source code in ghidralib.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) set_pc ( address ) Source code in ghidralib.py 1104 1105 1106 def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) trace_pcode ( start , end , callback ) Source code in ghidralib.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () write_memory ( address , value ) Source code in ghidralib.py 1121 1122 def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) write_register ( reg , value ) Source code in ghidralib.py 1111 1112 def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) Function Bases: GhidraWrapper Source code in ghidralib.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class Function ( GhidraWrapper ): @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) address property basicblocks property called property callers property calls property comment property entrypoint property fixup property writable high_pcode property instructions property is_external property is_thunk property local_variables property name property parameters property repeatable_comment property return_type property return_variable property variables property xref_addrs property xrefs property all () staticmethod Source code in ghidralib.py 849 850 851 852 @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] create ( address , name ) staticmethod Source code in ghidralib.py 854 855 856 857 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) decompile () Source code in ghidralib.py 976 977 978 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () get ( addr ) staticmethod Source code in ghidralib.py 842 843 844 845 846 847 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore get_high_function ( simplify = 'decompile' ) Source code in ghidralib.py 980 981 982 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) get_high_pcode ( simplify = 'decompile' ) Source code in ghidralib.py 984 985 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode get_high_pcode_at ( address ) Source code in ghidralib.py 991 992 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) rename ( name ) Source code in ghidralib.py 913 914 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) set_comment ( comment ) Source code in ghidralib.py 883 884 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) set_repeatable_comment ( comment ) Source code in ghidralib.py 898 899 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) FunctionCall Source code in ghidralib.py 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 class FunctionCall : def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args address = resolve ( address ) instance-attribute function = function instance-attribute __init__ ( function , address ) Source code in ghidralib.py 792 793 794 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) emulate () Source code in ghidralib.py 809 810 811 812 813 def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu get_args ( emulate = True ) Source code in ghidralib.py 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args get_args_as_varnodes () Source code in ghidralib.py 815 816 817 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr get_high_pcode () Source code in ghidralib.py 796 797 798 799 800 801 802 def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) get_varnodes () Source code in ghidralib.py 804 805 806 807 def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) GhidraWrapper Source code in ghidralib.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class GhidraWrapper : def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __repr__ = raw . __repr__ instance-attribute __str__ = raw . __str__ instance-attribute raw = _as_javaobject ( raw ) instance-attribute __eq__ ( other ) Source code in ghidralib.py 149 150 151 152 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __hash__ () Source code in ghidralib.py 146 147 def __hash__ ( self ): # type: () -> int return self . raw . hashCode () __init__ ( raw ) Source code in ghidralib.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject __tojava__ ( klass ) Make it possible to pass this object to Java methods Source code in ghidralib.py 142 143 144 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw HighFunction Bases: GhidraWrapper Source code in ghidralib.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basic_blocks ( self ): # type: () -> list[PcodeBlock] return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] def get_ast ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) basic_blocks property pcode property get_ast () Source code in ghidralib.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def get_ast ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) get_pcode_at ( address ) Source code in ghidralib.py 435 436 437 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] HighSymbol Bases: GhidraWrapper Source code in ghidralib.py 164 165 166 167 168 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED ) rename ( new_name ) Source code in ghidralib.py 165 166 167 168 def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED ) HighVariable Bases: GhidraWrapper Source code in ghidralib.py 155 156 157 158 159 160 161 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) symbol property rename ( new_name ) Source code in ghidralib.py 160 161 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) Instruction Bases: GhidraWrapper Source code in ghidralib.py 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class Instruction ( GhidraWrapper ): def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) @property def address ( self ): # type: () -> int return self . raw . getAddress () @property def flow ( self ): # type: () -> RefType return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) address property flow property high_pcode property Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead. mnemonic property next property pcode property Get a list of Pcode operations that this instruction was parsed to previous property xrefs_from property add_operand_reference ( op_ndx , ref_addr , ref_type , src_type ) Source code in ghidralib.py 672 673 674 675 676 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) get ( raw_or_address ) Source code in ghidralib.py 615 616 617 618 619 620 def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) get_scalar ( ndx ) Source code in ghidralib.py 653 654 655 656 657 658 659 660 661 def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) to_bytes () Source code in ghidralib.py 650 651 def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () JavaObject Source code in ghidralib.py 58 59 60 class JavaObject : def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing __getattribute__ ( name ) Source code in ghidralib.py 59 60 def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing Parameter Bases: Variable Source code in ghidralib.py 781 782 783 784 785 786 787 788 class Parameter ( Variable ): @property def ordinal ( self ): # type: () -> int return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType return DataType ( self . raw . getFormalDataType ()) formal_data_type property ordinal property PcodeBlock Bases: GhidraWrapper Source code in ghidralib.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def is_graph ( self ): # type: () -> bool return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ] incoming_edges property is_graph property outgoing_edges property pcode property PcodeOp Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High PCode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High PCode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ()) BOOL_AND = 39 class-attribute instance-attribute BOOL_NEGATE = 37 class-attribute instance-attribute BOOL_OR = 40 class-attribute instance-attribute BOOL_XOR = 38 class-attribute instance-attribute BRANCH = 4 class-attribute instance-attribute BRANCHIND = 6 class-attribute instance-attribute CALL = 7 class-attribute instance-attribute CALLIND = 8 class-attribute instance-attribute CALLOTHER = 9 class-attribute instance-attribute CAST = 64 class-attribute instance-attribute CBRANCH = 5 class-attribute instance-attribute COPY = 1 class-attribute instance-attribute CPOOLREF = 68 class-attribute instance-attribute EXTRACT = 71 class-attribute instance-attribute FLOAT_ABS = 52 class-attribute instance-attribute FLOAT_ADD = 47 class-attribute instance-attribute FLOAT_CEIL = 57 class-attribute instance-attribute FLOAT_DIV = 48 class-attribute instance-attribute FLOAT_EQUAL = 41 class-attribute instance-attribute FLOAT_FLOAT2FLOAT = 55 class-attribute instance-attribute FLOAT_FLOOR = 58 class-attribute instance-attribute FLOAT_INT2FLOAT = 54 class-attribute instance-attribute FLOAT_LESS = 43 class-attribute instance-attribute FLOAT_LESSEQUAL = 44 class-attribute instance-attribute FLOAT_MULT = 49 class-attribute instance-attribute FLOAT_NAN = 46 class-attribute instance-attribute FLOAT_NEG = 51 class-attribute instance-attribute FLOAT_NOTEQUAL = 42 class-attribute instance-attribute FLOAT_ROUND = 59 class-attribute instance-attribute FLOAT_SQRT = 53 class-attribute instance-attribute FLOAT_SUB = 50 class-attribute instance-attribute FLOAT_TRUNC = 56 class-attribute instance-attribute INDIRECT = 61 class-attribute instance-attribute INSERT = 70 class-attribute instance-attribute INT_2COMP = 24 class-attribute instance-attribute INT_ADD = 19 class-attribute instance-attribute INT_AND = 27 class-attribute instance-attribute INT_CARRY = 21 class-attribute instance-attribute INT_DIV = 33 class-attribute instance-attribute INT_EQUAL = 11 class-attribute instance-attribute INT_LEFT = 29 class-attribute instance-attribute INT_LESS = 15 class-attribute instance-attribute INT_LESSEQUAL = 16 class-attribute instance-attribute INT_MULT = 32 class-attribute instance-attribute INT_NEGATE = 25 class-attribute instance-attribute INT_NOTEQUAL = 12 class-attribute instance-attribute INT_OR = 28 class-attribute instance-attribute INT_REM = 35 class-attribute instance-attribute INT_RIGHT = 30 class-attribute instance-attribute INT_SBORROW = 23 class-attribute instance-attribute INT_SCARRY = 22 class-attribute instance-attribute INT_SDIV = 34 class-attribute instance-attribute INT_SEXT = 18 class-attribute instance-attribute INT_SLESS = 13 class-attribute instance-attribute INT_SLESSEQUAL = 14 class-attribute instance-attribute INT_SREM = 36 class-attribute instance-attribute INT_SRIGHT = 31 class-attribute instance-attribute INT_SUB = 20 class-attribute instance-attribute INT_XOR = 26 class-attribute instance-attribute INT_ZEXT = 17 class-attribute instance-attribute LOAD = 2 class-attribute instance-attribute LZCOUNT = 73 class-attribute instance-attribute MULTIEQUAL = 60 class-attribute instance-attribute NEW = 69 class-attribute instance-attribute PCODE_MAX = 74 class-attribute instance-attribute PIECE = 62 class-attribute instance-attribute POPCOUNT = 72 class-attribute instance-attribute PTRADD = 65 class-attribute instance-attribute PTRSUB = 66 class-attribute instance-attribute RETURN = 10 class-attribute instance-attribute SEGMENTOP = 67 class-attribute instance-attribute STORE = 3 class-attribute instance-attribute SUBPIECE = 63 class-attribute instance-attribute UNIMPLEMENTED = 0 class-attribute instance-attribute address property Get an address in the program where this instruction is located inputs property inputs_simple property Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). mnemonic property Get a string representation of the operation, for example \"COPY\" opcode property output property get_high_pcode_at ( address ) staticmethod Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 356 357 358 359 360 361 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) RefType Bases: GhidraWrapper Source code in ghidralib.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () class-attribute instance-attribute CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () class-attribute instance-attribute CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute FALL_THROUGH = _reftype_placeholder () class-attribute instance-attribute FLOW = _reftype_placeholder () class-attribute instance-attribute INDIRECTION = _reftype_placeholder () class-attribute instance-attribute INVALID = _reftype_placeholder () class-attribute instance-attribute JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute JUMP_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute TERMINATOR = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute has_fall property writable is_call property writable is_computed property writable is_conditional property writable is_data property is_flow property is_jump property writable is_override property is_read property is_terminal property is_unconditional property is_write property Reference Bases: GhidraWrapper Source code in ghidralib.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int return self . raw . getToAddress () . getOffset () from_address property is_call property is_jump property reftype property to_address property Register Bases: GhidraWrapper Source code in ghidralib.py 171 172 173 174 class Register ( GhidraWrapper ): @property def name ( self ): return self . raw . getName () name property Symbol Bases: GhidraWrapper Source code in ghidralib.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 class Symbol ( GhidraWrapper ): @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw ) @property def address ( self ): # type: () -> int return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None create_data ( self . address , datatype ) address property name property name_with_namespace property xref_addrs property xrefs property all () staticmethod Source code in ghidralib.py 1010 1011 1012 1013 1014 @staticmethod def all (): # type: () -> list[Symbol] symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] create ( address , name ) staticmethod Source code in ghidralib.py 1016 1017 1018 1019 @staticmethod def create ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw ) get ( raw_or_name ) staticmethod Source code in ghidralib.py 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name return Symbol ( raw ) set_type ( datatype ) Source code in ghidralib.py 1041 1042 def set_type ( self , datatype ): # type: (DataType) -> None create_data ( self . address , datatype ) Variable Bases: GhidraWrapper Source code in ghidralib.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 class Variable ( GhidraWrapper ): @property def name ( self ): # type: () -> str return self . raw . getName () @property def data_type ( self ): # type: () -> DataType return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool return self . raw . isValid () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol return Symbol ( self . raw . getSymbol ()) comment property data_type property is_compound property is_memory property is_stack property is_unique property is_valid property name property symbol property set_comment ( comment ) Source code in ghidralib.py 757 758 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) Varnode Bases: GhidraWrapper Source code in ghidralib.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def as_register ( self ): # type: () -> Register language = currentProgram . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return Register ( raw ) @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register . name elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" ) as_register property free property has_value property high property is_address property is_constant property Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value. is_free property is_hash property is_register property is_unique property offset property simple property Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position. size property symbol property value property Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value. rename ( new_name ) Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 235 236 237 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) can_resolve ( addr ) Source code in ghidralib.py 99 100 def can_resolve ( addr ): # type: (Addr) -> bool return isinstance ( addr , ( GenericAddress , int , long , str )) collect_iterator ( iterator ) Source code in ghidralib.py 81 82 83 84 85 def collect_iterator ( iterator ): result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result create_data ( address , datatype ) Source code in ghidralib.py 1196 1197 1198 1199 1200 1201 def create_data ( address , datatype ): # type: (Addr, DataType) -> None try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype )) current_location () Source code in ghidralib.py 1211 1212 def current_location (): # type: () -> int return currentLocation . getAddress () . getOffset () from_bytes ( b ) Source code in ghidralib.py 1224 1225 1226 1227 def from_bytes ( b ): # type: (str | list[int]) -> int if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b )) get_bytes ( address , length ) Source code in ghidralib.py 1219 1220 1221 def get_bytes ( address , length ): # type: (Addr, int) -> str address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length )) get_string ( address ) Source code in ghidralib.py 1204 1205 1206 1207 1208 def get_string ( address ): # type: (Addr) -> str|None string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None get_u32 ( address ) Source code in ghidralib.py 1215 1216 def get_u32 ( address ): return from_bytes ( get_bytes ( address , 2 )) resolve ( addr ) Source code in ghidralib.py 88 89 90 91 92 93 94 95 96 def resolve ( addr ): # type: (Addr) -> GenericAddress if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" ) unwrap ( wrapper_or_java_type ) Source code in ghidralib.py 103 104 105 106 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type xor ( a , b ) Source code in ghidralib.py 1192 1193 def xor ( a , b ): # type: (str, str) -> str return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"Ghidralib"},{"location":"everything/#ghidralib_1","text":"","title":"Ghidralib"},{"location":"everything/#api-documentation","text":"","title":"API Documentation"},{"location":"everything/#ghidralib","text":"This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/.","title":"ghidralib"},{"location":"everything/#ghidralib.Addr","text":"","title":"Addr"},{"location":"everything/#ghidralib.Reg","text":"","title":"Reg"},{"location":"everything/#ghidralib.long","text":"","title":"long"},{"location":"everything/#ghidralib.BasicBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class BasicBlock ( GhidraWrapper ): @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ]","title":"BasicBlock"},{"location":"everything/#ghidralib.BasicBlock.destinations","text":"Get a list of basic blocks that this basic block jumps to","title":"destinations"},{"location":"everything/#ghidralib.BasicBlock.end_address","text":"Get the address of the last instruction in this basic block.","title":"end_address"},{"location":"everything/#ghidralib.BasicBlock.instructions","text":"Get a list of instructions in this basic block.","title":"instructions"},{"location":"everything/#ghidralib.BasicBlock.pcode","text":"Get a list of Pcode operations that this basic block was parsed to","title":"pcode"},{"location":"everything/#ghidralib.BasicBlock.sources","text":"Get a list of basic blocks that jump to this basic block","title":"sources"},{"location":"everything/#ghidralib.BasicBlock.start_address","text":"Get the address of the first instruction in this basic block.","title":"start_address"},{"location":"everything/#ghidralib.BasicBlock.get","text":"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw )","title":"get"},{"location":"everything/#ghidralib.BlockGraph","text":"Bases: PcodeBlock Source code in ghidralib.py 428 429 430 431 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())]","title":"BlockGraph"},{"location":"everything/#ghidralib.BlockGraph.blocks","text":"","title":"blocks"},{"location":"everything/#ghidralib.DataType","text":"Bases: GhidraWrapper Source code in ghidralib.py 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 class DataType ( GhidraWrapper ): @staticmethod def get ( name ): # type: (str) -> DataType|None for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type\"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"DataType"},{"location":"everything/#ghidralib.DataType.name","text":"Get a name of this data type","title":"name"},{"location":"everything/#ghidralib.DataType.all","text":"Source code in ghidralib.py 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes","title":"all"},{"location":"everything/#ghidralib.DataType.from_c","text":"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; Source code in ghidralib.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"from_c"},{"location":"everything/#ghidralib.DataType.get","text":"Source code in ghidralib.py 1046 1047 1048 1049 1050 1051 @staticmethod def get ( name ): # type: (str) -> DataType|None for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None","title":"get"},{"location":"everything/#ghidralib.DataType.get_name","text":"Get Enum name for a given value Source code in ghidralib.py 1071 1072 1073 def get_name ( self , value ): # type: (int) -> str \"\"\"Get Enum name for a given value\"\"\" return self . raw . getName ( value )","title":"get_name"},{"location":"everything/#ghidralib.Emulator","text":"Bases: GhidraWrapper Source code in ghidralib.py 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 class Emulator ( GhidraWrapper ): def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"Emulator"},{"location":"everything/#ghidralib.Emulator.pc","text":"","title":"pc"},{"location":"everything/#ghidralib.Emulator.__init__","text":"Source code in ghidralib.py 1096 1097 1098 def __init__ ( self ): # type: () -> None raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw )","title":"__init__"},{"location":"everything/#ghidralib.Emulator.emulate","text":"Source code in ghidralib.py 1124 1125 1126 1127 1128 1129 1130 1131 1132 def emulate ( self , start , end ): # type: (Addr, Addr) -> None self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err ))","title":"emulate"},{"location":"everything/#ghidralib.Emulator.get_bytes","text":"Source code in ghidralib.py 1114 1115 1116 def get_bytes ( self , address , length ): # type: (Addr, int) -> str bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist )","title":"get_bytes"},{"location":"everything/#ghidralib.Emulator.propagate_varnodes","text":"Source code in ghidralib.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"propagate_varnodes"},{"location":"everything/#ghidralib.Emulator.read_memory","text":"Source code in ghidralib.py 1118 1119 def read_memory ( self , address , length ): # type: (Addr, int) -> str return self . get_bytes ( address , length )","title":"read_memory"},{"location":"everything/#ghidralib.Emulator.read_register","text":"Source code in ghidralib.py 1108 1109 def read_register ( self , reg ): # type: (Reg) -> int return self . raw . readRegister ( reg )","title":"read_register"},{"location":"everything/#ghidralib.Emulator.read_varnode","text":"Source code in ghidralib.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def read_varnode ( self , varnode ): # type: (Varnode) -> int if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" )","title":"read_varnode"},{"location":"everything/#ghidralib.Emulator.set_pc","text":"Source code in ghidralib.py 1104 1105 1106 def set_pc ( self , address ): # type: (Addr) -> None pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address )","title":"set_pc"},{"location":"everything/#ghidralib.Emulator.trace_pcode","text":"Source code in ghidralib.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress ()","title":"trace_pcode"},{"location":"everything/#ghidralib.Emulator.write_memory","text":"Source code in ghidralib.py 1121 1122 def write_memory ( self , address , value ): # type: (Addr, str) -> None self . raw . writeMemory ( address , value )","title":"write_memory"},{"location":"everything/#ghidralib.Emulator.write_register","text":"Source code in ghidralib.py 1111 1112 def write_register ( self , reg , value ): # type: (Reg, int) -> None self . raw . writeRegister ( reg , value )","title":"write_register"},{"location":"everything/#ghidralib.Function","text":"Bases: GhidraWrapper Source code in ghidralib.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class Function ( GhidraWrapper ): @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"Function"},{"location":"everything/#ghidralib.Function.address","text":"","title":"address"},{"location":"everything/#ghidralib.Function.basicblocks","text":"","title":"basicblocks"},{"location":"everything/#ghidralib.Function.called","text":"","title":"called"},{"location":"everything/#ghidralib.Function.callers","text":"","title":"callers"},{"location":"everything/#ghidralib.Function.calls","text":"","title":"calls"},{"location":"everything/#ghidralib.Function.comment","text":"","title":"comment"},{"location":"everything/#ghidralib.Function.entrypoint","text":"","title":"entrypoint"},{"location":"everything/#ghidralib.Function.fixup","text":"","title":"fixup"},{"location":"everything/#ghidralib.Function.high_pcode","text":"","title":"high_pcode"},{"location":"everything/#ghidralib.Function.instructions","text":"","title":"instructions"},{"location":"everything/#ghidralib.Function.is_external","text":"","title":"is_external"},{"location":"everything/#ghidralib.Function.is_thunk","text":"","title":"is_thunk"},{"location":"everything/#ghidralib.Function.local_variables","text":"","title":"local_variables"},{"location":"everything/#ghidralib.Function.name","text":"","title":"name"},{"location":"everything/#ghidralib.Function.parameters","text":"","title":"parameters"},{"location":"everything/#ghidralib.Function.repeatable_comment","text":"","title":"repeatable_comment"},{"location":"everything/#ghidralib.Function.return_type","text":"","title":"return_type"},{"location":"everything/#ghidralib.Function.return_variable","text":"","title":"return_variable"},{"location":"everything/#ghidralib.Function.variables","text":"","title":"variables"},{"location":"everything/#ghidralib.Function.xref_addrs","text":"","title":"xref_addrs"},{"location":"everything/#ghidralib.Function.xrefs","text":"","title":"xrefs"},{"location":"everything/#ghidralib.Function.all","text":"Source code in ghidralib.py 849 850 851 852 @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ]","title":"all"},{"location":"everything/#ghidralib.Function.create","text":"Source code in ghidralib.py 854 855 856 857 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func )","title":"create"},{"location":"everything/#ghidralib.Function.decompile","text":"Source code in ghidralib.py 976 977 978 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC ()","title":"decompile"},{"location":"everything/#ghidralib.Function.get","text":"Source code in ghidralib.py 842 843 844 845 846 847 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore","title":"get"},{"location":"everything/#ghidralib.Function.get_high_function","text":"Source code in ghidralib.py 980 981 982 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ())","title":"get_high_function"},{"location":"everything/#ghidralib.Function.get_high_pcode","text":"Source code in ghidralib.py 984 985 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode","title":"get_high_pcode"},{"location":"everything/#ghidralib.Function.get_high_pcode_at","text":"Source code in ghidralib.py 991 992 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"everything/#ghidralib.Function.rename","text":"Source code in ghidralib.py 913 914 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED )","title":"rename"},{"location":"everything/#ghidralib.Function.set_comment","text":"Source code in ghidralib.py 883 884 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment )","title":"set_comment"},{"location":"everything/#ghidralib.Function.set_repeatable_comment","text":"Source code in ghidralib.py 898 899 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment )","title":"set_repeatable_comment"},{"location":"everything/#ghidralib.FunctionCall","text":"Source code in ghidralib.py 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 class FunctionCall : def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"FunctionCall"},{"location":"everything/#ghidralib.FunctionCall.address","text":"","title":"address"},{"location":"everything/#ghidralib.FunctionCall.function","text":"","title":"function"},{"location":"everything/#ghidralib.FunctionCall.__init__","text":"Source code in ghidralib.py 792 793 794 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address )","title":"__init__"},{"location":"everything/#ghidralib.FunctionCall.emulate","text":"Source code in ghidralib.py 809 810 811 812 813 def emulate ( self ): # type: () -> Emulator basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu","title":"emulate"},{"location":"everything/#ghidralib.FunctionCall.get_args","text":"Source code in ghidralib.py 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 def get_args ( self , emulate = True ): # type: (bool) -> list[int] basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"get_args"},{"location":"everything/#ghidralib.FunctionCall.get_args_as_varnodes","text":"Source code in ghidralib.py 815 816 817 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr","title":"get_args_as_varnodes"},{"location":"everything/#ghidralib.FunctionCall.get_high_pcode","text":"Source code in ghidralib.py 796 797 798 799 800 801 802 def get_high_pcode ( self ): # type: () -> PcodeOp for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address )))","title":"get_high_pcode"},{"location":"everything/#ghidralib.FunctionCall.get_varnodes","text":"Source code in ghidralib.py 804 805 806 807 def get_varnodes ( self ): # type: () -> dict[Varnode, int] basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address )","title":"get_varnodes"},{"location":"everything/#ghidralib.GhidraWrapper","text":"Source code in ghidralib.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class GhidraWrapper : def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"GhidraWrapper"},{"location":"everything/#ghidralib.GhidraWrapper.__repr__","text":"","title":"__repr__"},{"location":"everything/#ghidralib.GhidraWrapper.__str__","text":"","title":"__str__"},{"location":"everything/#ghidralib.GhidraWrapper.raw","text":"","title":"raw"},{"location":"everything/#ghidralib.GhidraWrapper.__eq__","text":"Source code in ghidralib.py 149 150 151 152 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"__eq__"},{"location":"everything/#ghidralib.GhidraWrapper.__hash__","text":"Source code in ghidralib.py 146 147 def __hash__ ( self ): # type: () -> int return self . raw . hashCode ()","title":"__hash__"},{"location":"everything/#ghidralib.GhidraWrapper.__init__","text":"Source code in ghidralib.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject","title":"__init__"},{"location":"everything/#ghidralib.GhidraWrapper.__tojava__","text":"Make it possible to pass this object to Java methods Source code in ghidralib.py 142 143 144 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw","title":"__tojava__"},{"location":"everything/#ghidralib.HighFunction","text":"Bases: GhidraWrapper Source code in ghidralib.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basic_blocks ( self ): # type: () -> list[PcodeBlock] return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] def get_ast ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph )","title":"HighFunction"},{"location":"everything/#ghidralib.HighFunction.basic_blocks","text":"","title":"basic_blocks"},{"location":"everything/#ghidralib.HighFunction.pcode","text":"","title":"pcode"},{"location":"everything/#ghidralib.HighFunction.get_ast","text":"Source code in ghidralib.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 def get_ast ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph )","title":"get_ast"},{"location":"everything/#ghidralib.HighFunction.get_pcode_at","text":"Source code in ghidralib.py 435 436 437 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )]","title":"get_pcode_at"},{"location":"everything/#ghidralib.HighSymbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 164 165 166 167 168 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED )","title":"HighSymbol"},{"location":"everything/#ghidralib.HighSymbol.rename","text":"Source code in ghidralib.py 165 166 167 168 def rename ( self , new_name ): # type: (str) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , SourceType . USER_DEFINED )","title":"rename"},{"location":"everything/#ghidralib.HighVariable","text":"Bases: GhidraWrapper Source code in ghidralib.py 155 156 157 158 159 160 161 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"HighVariable"},{"location":"everything/#ghidralib.HighVariable.symbol","text":"","title":"symbol"},{"location":"everything/#ghidralib.HighVariable.rename","text":"Source code in ghidralib.py 160 161 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"rename"},{"location":"everything/#ghidralib.Instruction","text":"Bases: GhidraWrapper Source code in ghidralib.py 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class Instruction ( GhidraWrapper ): def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) @property def mnemonic ( self ): # type: () -> str return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes () def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj ) @property def address ( self ): # type: () -> int return self . raw . getAddress () @property def flow ( self ): # type: () -> RefType return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"Instruction"},{"location":"everything/#ghidralib.Instruction.address","text":"","title":"address"},{"location":"everything/#ghidralib.Instruction.flow","text":"","title":"flow"},{"location":"everything/#ghidralib.Instruction.high_pcode","text":"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.","title":"high_pcode"},{"location":"everything/#ghidralib.Instruction.mnemonic","text":"","title":"mnemonic"},{"location":"everything/#ghidralib.Instruction.next","text":"","title":"next"},{"location":"everything/#ghidralib.Instruction.pcode","text":"Get a list of Pcode operations that this instruction was parsed to","title":"pcode"},{"location":"everything/#ghidralib.Instruction.previous","text":"","title":"previous"},{"location":"everything/#ghidralib.Instruction.xrefs_from","text":"","title":"xrefs_from"},{"location":"everything/#ghidralib.Instruction.add_operand_reference","text":"Source code in ghidralib.py 672 673 674 675 676 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"add_operand_reference"},{"location":"everything/#ghidralib.Instruction.get","text":"Source code in ghidralib.py 615 616 617 618 619 620 def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw )","title":"get"},{"location":"everything/#ghidralib.Instruction.get_scalar","text":"Source code in ghidralib.py 653 654 655 656 657 658 659 660 661 def get_scalar ( self , ndx ): # type: (int) -> int scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Can't convert operand {} to scalar\" , obj )","title":"get_scalar"},{"location":"everything/#ghidralib.Instruction.to_bytes","text":"Source code in ghidralib.py 650 651 def to_bytes ( self ): # type: () -> bytes return self . raw . getBytes ()","title":"to_bytes"},{"location":"everything/#ghidralib.JavaObject","text":"Source code in ghidralib.py 58 59 60 class JavaObject : def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing","title":"JavaObject"},{"location":"everything/#ghidralib.JavaObject.__getattribute__","text":"Source code in ghidralib.py 59 60 def __getattribute__ ( self , name ): # type: (str) -> Any pass # this class exists just for static typing","title":"__getattribute__"},{"location":"everything/#ghidralib.Parameter","text":"Bases: Variable Source code in ghidralib.py 781 782 783 784 785 786 787 788 class Parameter ( Variable ): @property def ordinal ( self ): # type: () -> int return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType return DataType ( self . raw . getFormalDataType ())","title":"Parameter"},{"location":"everything/#ghidralib.Parameter.formal_data_type","text":"","title":"formal_data_type"},{"location":"everything/#ghidralib.Parameter.ordinal","text":"","title":"ordinal"},{"location":"everything/#ghidralib.PcodeBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def is_graph ( self ): # type: () -> bool return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ]","title":"PcodeBlock"},{"location":"everything/#ghidralib.PcodeBlock.incoming_edges","text":"","title":"incoming_edges"},{"location":"everything/#ghidralib.PcodeBlock.is_graph","text":"","title":"is_graph"},{"location":"everything/#ghidralib.PcodeBlock.outgoing_edges","text":"","title":"outgoing_edges"},{"location":"everything/#ghidralib.PcodeBlock.pcode","text":"","title":"pcode"},{"location":"everything/#ghidralib.PcodeOp","text":"Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High PCode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High PCode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ())","title":"PcodeOp"},{"location":"everything/#ghidralib.PcodeOp.BOOL_AND","text":"","title":"BOOL_AND"},{"location":"everything/#ghidralib.PcodeOp.BOOL_NEGATE","text":"","title":"BOOL_NEGATE"},{"location":"everything/#ghidralib.PcodeOp.BOOL_OR","text":"","title":"BOOL_OR"},{"location":"everything/#ghidralib.PcodeOp.BOOL_XOR","text":"","title":"BOOL_XOR"},{"location":"everything/#ghidralib.PcodeOp.BRANCH","text":"","title":"BRANCH"},{"location":"everything/#ghidralib.PcodeOp.BRANCHIND","text":"","title":"BRANCHIND"},{"location":"everything/#ghidralib.PcodeOp.CALL","text":"","title":"CALL"},{"location":"everything/#ghidralib.PcodeOp.CALLIND","text":"","title":"CALLIND"},{"location":"everything/#ghidralib.PcodeOp.CALLOTHER","text":"","title":"CALLOTHER"},{"location":"everything/#ghidralib.PcodeOp.CAST","text":"","title":"CAST"},{"location":"everything/#ghidralib.PcodeOp.CBRANCH","text":"","title":"CBRANCH"},{"location":"everything/#ghidralib.PcodeOp.COPY","text":"","title":"COPY"},{"location":"everything/#ghidralib.PcodeOp.CPOOLREF","text":"","title":"CPOOLREF"},{"location":"everything/#ghidralib.PcodeOp.EXTRACT","text":"","title":"EXTRACT"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_ABS","text":"","title":"FLOAT_ABS"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_ADD","text":"","title":"FLOAT_ADD"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_CEIL","text":"","title":"FLOAT_CEIL"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_DIV","text":"","title":"FLOAT_DIV"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_EQUAL","text":"","title":"FLOAT_EQUAL"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT","text":"","title":"FLOAT_FLOAT2FLOAT"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_FLOOR","text":"","title":"FLOAT_FLOOR"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_INT2FLOAT","text":"","title":"FLOAT_INT2FLOAT"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_LESS","text":"","title":"FLOAT_LESS"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_LESSEQUAL","text":"","title":"FLOAT_LESSEQUAL"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_MULT","text":"","title":"FLOAT_MULT"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_NAN","text":"","title":"FLOAT_NAN"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_NEG","text":"","title":"FLOAT_NEG"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_NOTEQUAL","text":"","title":"FLOAT_NOTEQUAL"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_ROUND","text":"","title":"FLOAT_ROUND"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_SQRT","text":"","title":"FLOAT_SQRT"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_SUB","text":"","title":"FLOAT_SUB"},{"location":"everything/#ghidralib.PcodeOp.FLOAT_TRUNC","text":"","title":"FLOAT_TRUNC"},{"location":"everything/#ghidralib.PcodeOp.INDIRECT","text":"","title":"INDIRECT"},{"location":"everything/#ghidralib.PcodeOp.INSERT","text":"","title":"INSERT"},{"location":"everything/#ghidralib.PcodeOp.INT_2COMP","text":"","title":"INT_2COMP"},{"location":"everything/#ghidralib.PcodeOp.INT_ADD","text":"","title":"INT_ADD"},{"location":"everything/#ghidralib.PcodeOp.INT_AND","text":"","title":"INT_AND"},{"location":"everything/#ghidralib.PcodeOp.INT_CARRY","text":"","title":"INT_CARRY"},{"location":"everything/#ghidralib.PcodeOp.INT_DIV","text":"","title":"INT_DIV"},{"location":"everything/#ghidralib.PcodeOp.INT_EQUAL","text":"","title":"INT_EQUAL"},{"location":"everything/#ghidralib.PcodeOp.INT_LEFT","text":"","title":"INT_LEFT"},{"location":"everything/#ghidralib.PcodeOp.INT_LESS","text":"","title":"INT_LESS"},{"location":"everything/#ghidralib.PcodeOp.INT_LESSEQUAL","text":"","title":"INT_LESSEQUAL"},{"location":"everything/#ghidralib.PcodeOp.INT_MULT","text":"","title":"INT_MULT"},{"location":"everything/#ghidralib.PcodeOp.INT_NEGATE","text":"","title":"INT_NEGATE"},{"location":"everything/#ghidralib.PcodeOp.INT_NOTEQUAL","text":"","title":"INT_NOTEQUAL"},{"location":"everything/#ghidralib.PcodeOp.INT_OR","text":"","title":"INT_OR"},{"location":"everything/#ghidralib.PcodeOp.INT_REM","text":"","title":"INT_REM"},{"location":"everything/#ghidralib.PcodeOp.INT_RIGHT","text":"","title":"INT_RIGHT"},{"location":"everything/#ghidralib.PcodeOp.INT_SBORROW","text":"","title":"INT_SBORROW"},{"location":"everything/#ghidralib.PcodeOp.INT_SCARRY","text":"","title":"INT_SCARRY"},{"location":"everything/#ghidralib.PcodeOp.INT_SDIV","text":"","title":"INT_SDIV"},{"location":"everything/#ghidralib.PcodeOp.INT_SEXT","text":"","title":"INT_SEXT"},{"location":"everything/#ghidralib.PcodeOp.INT_SLESS","text":"","title":"INT_SLESS"},{"location":"everything/#ghidralib.PcodeOp.INT_SLESSEQUAL","text":"","title":"INT_SLESSEQUAL"},{"location":"everything/#ghidralib.PcodeOp.INT_SREM","text":"","title":"INT_SREM"},{"location":"everything/#ghidralib.PcodeOp.INT_SRIGHT","text":"","title":"INT_SRIGHT"},{"location":"everything/#ghidralib.PcodeOp.INT_SUB","text":"","title":"INT_SUB"},{"location":"everything/#ghidralib.PcodeOp.INT_XOR","text":"","title":"INT_XOR"},{"location":"everything/#ghidralib.PcodeOp.INT_ZEXT","text":"","title":"INT_ZEXT"},{"location":"everything/#ghidralib.PcodeOp.LOAD","text":"","title":"LOAD"},{"location":"everything/#ghidralib.PcodeOp.LZCOUNT","text":"","title":"LZCOUNT"},{"location":"everything/#ghidralib.PcodeOp.MULTIEQUAL","text":"","title":"MULTIEQUAL"},{"location":"everything/#ghidralib.PcodeOp.NEW","text":"","title":"NEW"},{"location":"everything/#ghidralib.PcodeOp.PCODE_MAX","text":"","title":"PCODE_MAX"},{"location":"everything/#ghidralib.PcodeOp.PIECE","text":"","title":"PIECE"},{"location":"everything/#ghidralib.PcodeOp.POPCOUNT","text":"","title":"POPCOUNT"},{"location":"everything/#ghidralib.PcodeOp.PTRADD","text":"","title":"PTRADD"},{"location":"everything/#ghidralib.PcodeOp.PTRSUB","text":"","title":"PTRSUB"},{"location":"everything/#ghidralib.PcodeOp.RETURN","text":"","title":"RETURN"},{"location":"everything/#ghidralib.PcodeOp.SEGMENTOP","text":"","title":"SEGMENTOP"},{"location":"everything/#ghidralib.PcodeOp.STORE","text":"","title":"STORE"},{"location":"everything/#ghidralib.PcodeOp.SUBPIECE","text":"","title":"SUBPIECE"},{"location":"everything/#ghidralib.PcodeOp.UNIMPLEMENTED","text":"","title":"UNIMPLEMENTED"},{"location":"everything/#ghidralib.PcodeOp.address","text":"Get an address in the program where this instruction is located","title":"address"},{"location":"everything/#ghidralib.PcodeOp.inputs","text":"","title":"inputs"},{"location":"everything/#ghidralib.PcodeOp.inputs_simple","text":"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).","title":"inputs_simple"},{"location":"everything/#ghidralib.PcodeOp.mnemonic","text":"Get a string representation of the operation, for example \"COPY\"","title":"mnemonic"},{"location":"everything/#ghidralib.PcodeOp.opcode","text":"","title":"opcode"},{"location":"everything/#ghidralib.PcodeOp.output","text":"","title":"output"},{"location":"everything/#ghidralib.PcodeOp.get_high_pcode_at","text":"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 356 357 358 359 360 361 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"everything/#ghidralib.RefType","text":"Bases: GhidraWrapper Source code in ghidralib.py 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder ()","title":"RefType"},{"location":"everything/#ghidralib.RefType.CALLOTHER_OVERRIDE_CALL","text":"","title":"CALLOTHER_OVERRIDE_CALL"},{"location":"everything/#ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP","text":"","title":"CALLOTHER_OVERRIDE_JUMP"},{"location":"everything/#ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL","text":"","title":"CALL_OVERRIDE_UNCONDITIONAL"},{"location":"everything/#ghidralib.RefType.CALL_TERMINATOR","text":"","title":"CALL_TERMINATOR"},{"location":"everything/#ghidralib.RefType.COMPUTED_CALL","text":"","title":"COMPUTED_CALL"},{"location":"everything/#ghidralib.RefType.COMPUTED_CALL_TERMINATOR","text":"","title":"COMPUTED_CALL_TERMINATOR"},{"location":"everything/#ghidralib.RefType.COMPUTED_JUMP","text":"","title":"COMPUTED_JUMP"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_CALL","text":"","title":"CONDITIONAL_CALL"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR","text":"","title":"CONDITIONAL_CALL_TERMINATOR"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_COMPUTED_CALL","text":"","title":"CONDITIONAL_COMPUTED_CALL"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP","text":"","title":"CONDITIONAL_COMPUTED_JUMP"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_JUMP","text":"","title":"CONDITIONAL_JUMP"},{"location":"everything/#ghidralib.RefType.CONDITIONAL_TERMINATOR","text":"","title":"CONDITIONAL_TERMINATOR"},{"location":"everything/#ghidralib.RefType.FALL_THROUGH","text":"","title":"FALL_THROUGH"},{"location":"everything/#ghidralib.RefType.FLOW","text":"","title":"FLOW"},{"location":"everything/#ghidralib.RefType.INDIRECTION","text":"","title":"INDIRECTION"},{"location":"everything/#ghidralib.RefType.INVALID","text":"","title":"INVALID"},{"location":"everything/#ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL","text":"","title":"JUMP_OVERRIDE_UNCONDITIONAL"},{"location":"everything/#ghidralib.RefType.JUMP_TERMINATOR","text":"","title":"JUMP_TERMINATOR"},{"location":"everything/#ghidralib.RefType.TERMINATOR","text":"","title":"TERMINATOR"},{"location":"everything/#ghidralib.RefType.UNCONDITIONAL_CALL","text":"","title":"UNCONDITIONAL_CALL"},{"location":"everything/#ghidralib.RefType.UNCONDITIONAL_JUMP","text":"","title":"UNCONDITIONAL_JUMP"},{"location":"everything/#ghidralib.RefType.has_fall","text":"","title":"has_fall"},{"location":"everything/#ghidralib.RefType.is_call","text":"","title":"is_call"},{"location":"everything/#ghidralib.RefType.is_computed","text":"","title":"is_computed"},{"location":"everything/#ghidralib.RefType.is_conditional","text":"","title":"is_conditional"},{"location":"everything/#ghidralib.RefType.is_data","text":"","title":"is_data"},{"location":"everything/#ghidralib.RefType.is_flow","text":"","title":"is_flow"},{"location":"everything/#ghidralib.RefType.is_jump","text":"","title":"is_jump"},{"location":"everything/#ghidralib.RefType.is_override","text":"","title":"is_override"},{"location":"everything/#ghidralib.RefType.is_read","text":"","title":"is_read"},{"location":"everything/#ghidralib.RefType.is_terminal","text":"","title":"is_terminal"},{"location":"everything/#ghidralib.RefType.is_unconditional","text":"","title":"is_unconditional"},{"location":"everything/#ghidralib.RefType.is_write","text":"","title":"is_write"},{"location":"everything/#ghidralib.Reference","text":"Bases: GhidraWrapper Source code in ghidralib.py 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int return self . raw . getToAddress () . getOffset ()","title":"Reference"},{"location":"everything/#ghidralib.Reference.from_address","text":"","title":"from_address"},{"location":"everything/#ghidralib.Reference.is_call","text":"","title":"is_call"},{"location":"everything/#ghidralib.Reference.is_jump","text":"","title":"is_jump"},{"location":"everything/#ghidralib.Reference.reftype","text":"","title":"reftype"},{"location":"everything/#ghidralib.Reference.to_address","text":"","title":"to_address"},{"location":"everything/#ghidralib.Register","text":"Bases: GhidraWrapper Source code in ghidralib.py 171 172 173 174 class Register ( GhidraWrapper ): @property def name ( self ): return self . raw . getName ()","title":"Register"},{"location":"everything/#ghidralib.Register.name","text":"","title":"name"},{"location":"everything/#ghidralib.Symbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 class Symbol ( GhidraWrapper ): @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw ) @property def address ( self ): # type: () -> int return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None create_data ( self . address , datatype )","title":"Symbol"},{"location":"everything/#ghidralib.Symbol.address","text":"","title":"address"},{"location":"everything/#ghidralib.Symbol.name","text":"","title":"name"},{"location":"everything/#ghidralib.Symbol.name_with_namespace","text":"","title":"name_with_namespace"},{"location":"everything/#ghidralib.Symbol.xref_addrs","text":"","title":"xref_addrs"},{"location":"everything/#ghidralib.Symbol.xrefs","text":"","title":"xrefs"},{"location":"everything/#ghidralib.Symbol.all","text":"Source code in ghidralib.py 1010 1011 1012 1013 1014 @staticmethod def all (): # type: () -> list[Symbol] symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ]","title":"all"},{"location":"everything/#ghidralib.Symbol.create","text":"Source code in ghidralib.py 1016 1017 1018 1019 @staticmethod def create ( address , name ): # type: (Addr, str) -> Symbol raw = createLabel ( resolve ( address ), name , False , SourceType . USER_DEFINED ) return Symbol ( raw )","title":"create"},{"location":"everything/#ghidralib.Symbol.get","text":"Source code in ghidralib.py 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : raise RuntimeError ( \"Symbol {} not found\" . format ( raw_or_name )) raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) else : raw = raw_or_name return Symbol ( raw )","title":"get"},{"location":"everything/#ghidralib.Symbol.set_type","text":"Source code in ghidralib.py 1041 1042 def set_type ( self , datatype ): # type: (DataType) -> None create_data ( self . address , datatype )","title":"set_type"},{"location":"everything/#ghidralib.Variable","text":"Bases: GhidraWrapper Source code in ghidralib.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 class Variable ( GhidraWrapper ): @property def name ( self ): # type: () -> str return self . raw . getName () @property def data_type ( self ): # type: () -> DataType return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool return self . raw . isValid () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol return Symbol ( self . raw . getSymbol ())","title":"Variable"},{"location":"everything/#ghidralib.Variable.comment","text":"","title":"comment"},{"location":"everything/#ghidralib.Variable.data_type","text":"","title":"data_type"},{"location":"everything/#ghidralib.Variable.is_compound","text":"","title":"is_compound"},{"location":"everything/#ghidralib.Variable.is_memory","text":"","title":"is_memory"},{"location":"everything/#ghidralib.Variable.is_stack","text":"","title":"is_stack"},{"location":"everything/#ghidralib.Variable.is_unique","text":"","title":"is_unique"},{"location":"everything/#ghidralib.Variable.is_valid","text":"","title":"is_valid"},{"location":"everything/#ghidralib.Variable.name","text":"","title":"name"},{"location":"everything/#ghidralib.Variable.symbol","text":"","title":"symbol"},{"location":"everything/#ghidralib.Variable.set_comment","text":"Source code in ghidralib.py 757 758 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment )","title":"set_comment"},{"location":"everything/#ghidralib.Varnode","text":"Bases: GhidraWrapper Source code in ghidralib.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def as_register ( self ): # type: () -> Register language = currentProgram . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return Register ( raw ) @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register . name elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" )","title":"Varnode"},{"location":"everything/#ghidralib.Varnode.as_register","text":"","title":"as_register"},{"location":"everything/#ghidralib.Varnode.free","text":"","title":"free"},{"location":"everything/#ghidralib.Varnode.has_value","text":"","title":"has_value"},{"location":"everything/#ghidralib.Varnode.high","text":"","title":"high"},{"location":"everything/#ghidralib.Varnode.is_address","text":"","title":"is_address"},{"location":"everything/#ghidralib.Varnode.is_constant","text":"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.","title":"is_constant"},{"location":"everything/#ghidralib.Varnode.is_free","text":"","title":"is_free"},{"location":"everything/#ghidralib.Varnode.is_hash","text":"","title":"is_hash"},{"location":"everything/#ghidralib.Varnode.is_register","text":"","title":"is_register"},{"location":"everything/#ghidralib.Varnode.is_unique","text":"","title":"is_unique"},{"location":"everything/#ghidralib.Varnode.offset","text":"","title":"offset"},{"location":"everything/#ghidralib.Varnode.simple","text":"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.","title":"simple"},{"location":"everything/#ghidralib.Varnode.size","text":"","title":"size"},{"location":"everything/#ghidralib.Varnode.symbol","text":"","title":"symbol"},{"location":"everything/#ghidralib.Varnode.value","text":"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.","title":"value"},{"location":"everything/#ghidralib.Varnode.rename","text":"Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 235 236 237 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name )","title":"rename"},{"location":"everything/#ghidralib.can_resolve","text":"Source code in ghidralib.py 99 100 def can_resolve ( addr ): # type: (Addr) -> bool return isinstance ( addr , ( GenericAddress , int , long , str ))","title":"can_resolve"},{"location":"everything/#ghidralib.collect_iterator","text":"Source code in ghidralib.py 81 82 83 84 85 def collect_iterator ( iterator ): result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result","title":"collect_iterator"},{"location":"everything/#ghidralib.create_data","text":"Source code in ghidralib.py 1196 1197 1198 1199 1200 1201 def create_data ( address , datatype ): # type: (Addr, DataType) -> None try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype ))","title":"create_data"},{"location":"everything/#ghidralib.current_location","text":"Source code in ghidralib.py 1211 1212 def current_location (): # type: () -> int return currentLocation . getAddress () . getOffset ()","title":"current_location"},{"location":"everything/#ghidralib.from_bytes","text":"Source code in ghidralib.py 1224 1225 1226 1227 def from_bytes ( b ): # type: (str | list[int]) -> int if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b ))","title":"from_bytes"},{"location":"everything/#ghidralib.get_bytes","text":"Source code in ghidralib.py 1219 1220 1221 def get_bytes ( address , length ): # type: (Addr, int) -> str address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length ))","title":"get_bytes"},{"location":"everything/#ghidralib.get_string","text":"Source code in ghidralib.py 1204 1205 1206 1207 1208 def get_string ( address ): # type: (Addr) -> str|None string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None","title":"get_string"},{"location":"everything/#ghidralib.get_u32","text":"Source code in ghidralib.py 1215 1216 def get_u32 ( address ): return from_bytes ( get_bytes ( address , 2 ))","title":"get_u32"},{"location":"everything/#ghidralib.resolve","text":"Source code in ghidralib.py 88 89 90 91 92 93 94 95 96 def resolve ( addr ): # type: (Addr) -> GenericAddress if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" )","title":"resolve"},{"location":"everything/#ghidralib.unwrap","text":"Source code in ghidralib.py 103 104 105 106 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type","title":"unwrap"},{"location":"everything/#ghidralib.xor","text":"Source code in ghidralib.py 1192 1193 def xor ( a , b ): # type: (str, str) -> str return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"xor"},{"location":"program_model/","text":"Program Model Ghidra models all kinds of various objects encountered during reverse-engineering: functions, instructions, basic blocks, datatypes... All that entities live in the ghidra.program.model namespace. Since they are crucial for any scripting, ghidralib wraps many of them. In this section we'll take a closer look at them and how to use them. provides a structured framework for understanding and analyzing the components of a binary program. It includes essential elements like instructions, basic blocks, functions, and symbols, which together define the program's logic and structure. This namespace is crucial for reverse engineering, as it enables efficient navigation, analysis, and manipulation of the program's code and data. Foobar ghidralib.Function Bases: GhidraWrapper Source code in ghidralib.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class Function ( GhidraWrapper ): @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) address property basicblocks property called property callers property calls property comment property entrypoint property fixup property writable high_pcode property instructions property is_external property is_thunk property local_variables property name property parameters property repeatable_comment property return_type property return_variable property variables property xref_addrs property xrefs property all () staticmethod Source code in ghidralib.py 849 850 851 852 @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] create ( address , name ) staticmethod Source code in ghidralib.py 854 855 856 857 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) decompile () Source code in ghidralib.py 976 977 978 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () get ( addr ) staticmethod Source code in ghidralib.py 842 843 844 845 846 847 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore get_high_function ( simplify = 'decompile' ) Source code in ghidralib.py 980 981 982 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) get_high_pcode ( simplify = 'decompile' ) Source code in ghidralib.py 984 985 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode get_high_pcode_at ( address ) Source code in ghidralib.py 991 992 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address ) rename ( name ) Source code in ghidralib.py 913 914 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) set_comment ( comment ) Source code in ghidralib.py 883 884 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) set_repeatable_comment ( comment ) Source code in ghidralib.py 898 899 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment )","title":"Program Model"},{"location":"program_model/#program-model","text":"Ghidra models all kinds of various objects encountered during reverse-engineering: functions, instructions, basic blocks, datatypes... All that entities live in the ghidra.program.model namespace. Since they are crucial for any scripting, ghidralib wraps many of them. In this section we'll take a closer look at them and how to use them. provides a structured framework for understanding and analyzing the components of a binary program. It includes essential elements like instructions, basic blocks, functions, and symbols, which together define the program's logic and structure. This namespace is crucial for reverse engineering, as it enables efficient navigation, analysis, and manipulation of the program's code and data.","title":"Program Model"},{"location":"program_model/#foobar","text":"","title":"Foobar"},{"location":"program_model/#ghidralib.Function","text":"Bases: GhidraWrapper Source code in ghidralib.py 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 class Function ( GhidraWrapper ): @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int return self . entrypoint @property def name ( self ): # type: () -> str return self . raw . getName () @property def comment ( self ): # type: () -> str return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode @property def high_pcode ( self ): # type: () -> list[PcodeOp] return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"Function"},{"location":"program_model/#ghidralib.Function.address","text":"","title":"address"},{"location":"program_model/#ghidralib.Function.basicblocks","text":"","title":"basicblocks"},{"location":"program_model/#ghidralib.Function.called","text":"","title":"called"},{"location":"program_model/#ghidralib.Function.callers","text":"","title":"callers"},{"location":"program_model/#ghidralib.Function.calls","text":"","title":"calls"},{"location":"program_model/#ghidralib.Function.comment","text":"","title":"comment"},{"location":"program_model/#ghidralib.Function.entrypoint","text":"","title":"entrypoint"},{"location":"program_model/#ghidralib.Function.fixup","text":"","title":"fixup"},{"location":"program_model/#ghidralib.Function.high_pcode","text":"","title":"high_pcode"},{"location":"program_model/#ghidralib.Function.instructions","text":"","title":"instructions"},{"location":"program_model/#ghidralib.Function.is_external","text":"","title":"is_external"},{"location":"program_model/#ghidralib.Function.is_thunk","text":"","title":"is_thunk"},{"location":"program_model/#ghidralib.Function.local_variables","text":"","title":"local_variables"},{"location":"program_model/#ghidralib.Function.name","text":"","title":"name"},{"location":"program_model/#ghidralib.Function.parameters","text":"","title":"parameters"},{"location":"program_model/#ghidralib.Function.repeatable_comment","text":"","title":"repeatable_comment"},{"location":"program_model/#ghidralib.Function.return_type","text":"","title":"return_type"},{"location":"program_model/#ghidralib.Function.return_variable","text":"","title":"return_variable"},{"location":"program_model/#ghidralib.Function.variables","text":"","title":"variables"},{"location":"program_model/#ghidralib.Function.xref_addrs","text":"","title":"xref_addrs"},{"location":"program_model/#ghidralib.Function.xrefs","text":"","title":"xrefs"},{"location":"program_model/#ghidralib.Function.all","text":"Source code in ghidralib.py 849 850 851 852 @staticmethod def all (): # type: () -> list[Function] raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ]","title":"all"},{"location":"program_model/#ghidralib.Function.create","text":"Source code in ghidralib.py 854 855 856 857 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function func = createFunction ( resolve ( address ), name ) return Function ( func )","title":"create"},{"location":"program_model/#ghidralib.Function.decompile","text":"Source code in ghidralib.py 976 977 978 def decompile ( self ): # type: () -> str decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC ()","title":"decompile"},{"location":"program_model/#ghidralib.Function.get","text":"Source code in ghidralib.py 842 843 844 845 846 847 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore","title":"get"},{"location":"program_model/#ghidralib.Function.get_high_function","text":"Source code in ghidralib.py 980 981 982 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ())","title":"get_high_function"},{"location":"program_model/#ghidralib.Function.get_high_pcode","text":"Source code in ghidralib.py 984 985 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] return self . get_high_function ( simplify ) . pcode","title":"get_high_pcode"},{"location":"program_model/#ghidralib.Function.get_high_pcode_at","text":"Source code in ghidralib.py 991 992 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] return self . get_high_function () . get_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"program_model/#ghidralib.Function.rename","text":"Source code in ghidralib.py 913 914 def rename ( self , name ): # type: (str) -> None self . raw . setName ( name , SourceType . USER_DEFINED )","title":"rename"},{"location":"program_model/#ghidralib.Function.set_comment","text":"Source code in ghidralib.py 883 884 def set_comment ( self , comment ): # type: (str) -> None self . raw . setComment ( comment )","title":"set_comment"},{"location":"program_model/#ghidralib.Function.set_repeatable_comment","text":"Source code in ghidralib.py 898 899 def set_repeatable_comment ( self , comment ): # type: (str) -> None self . raw . setRepeatableComment ( comment )","title":"set_repeatable_comment"}]}