{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ghidralib Welcome to ghidralib documentation! This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args)) Basic Usage To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. For a showcase of useful API functions, check out the Getting Started section ( recommended ). For a few more practical examples, check out the examples directory on Github. Read the autogenerated API documentation here . Check the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it?","title":"Ghidralib"},{"location":"#ghidralib","text":"","title":"Ghidralib"},{"location":"#welcome-to-ghidralib-documentation","text":"This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args))","title":"Welcome to ghidralib documentation!"},{"location":"#basic-usage","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. For a showcase of useful API functions, check out the Getting Started section ( recommended ). For a few more practical examples, check out the examples directory on Github. Read the autogenerated API documentation here . Check the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it?","title":"Basic Usage"},{"location":"getting_started/","text":"Getting Started This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. If you prefer to learn by example, check out the examples directory , or the tests . For a more complete reference, see the API documentation . Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier. IDE configuration I strongly recommend using an IDE that supports type-checking. Installation To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. Main actors A lot of objects are wrapped by this library. The most important at the beginning are: Function - a function recognised by Ghidra Instruction - assembly instruction DataType - a configured data type Symbol - a named address (also called a label) Function A function is a named block of code. Not all code in Ghidra belongs to a function, but being in a function makes it easier to reason about - for example, we can talk about parameters, variables, return values, etc. Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Print high variables in main function # These are the variables as seen by decompiler - the ones # that one thinks about when reversing print(Function(\"main\").high_variables) # Get the control flow graph of the main function... # ...and show it! (you can do something more useful instead) Function(\"main\").control_flow.show() # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Infer a value of eax and edx at each call of this function for call in Function(\"MyCustomCrypto\").calls: ctx = call.infer_context() key, data = ctx[\"eax\"], ctx[\"edx\"] print(key, data) # Infer parameters for each call to this function (using the decmopiler) for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) Read more in the Function object documentation . Instruction Instructions represent a single assembly operation. They have a mnemonic (e.g. mov ), operands (e.g. eax, 3 ), and a pcode representation used for further analysis. Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation . DataType Data types are used to describe the structure of data in memory. Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) # You can also create structures from C code strings: foo = DataType.from_c('struct foo { int a; int b; };') Read more in the DataType object documentation . Symbol Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(\"funniner_\" + symbol.name\") Read more in the Symbol object documentation . Working at various abstraction levels In this section I'll briefly summarize ghidralib objects that you can use to work at various abstraction levels. Assembly instructions - at the lowest level, there is assembler. You will use familiar Instruction , BasicBlock and Function . When analysing data, you will think in terms of Register s of Variables , and references are in terms of Symbols . Pcode instructions - here you think in terms of PcodeOp s, and PcodeBlocks . You still work with Functions , but the data flows between architecture-independent Varnodes now instead. High Pcode instructions - after the decompilation, many things change. You stil work with PcodeOps , but they are significantly transformed - referred as \"High Pcode\" in this library. You now think in terms of High Functions , High Variables , and High Symbols . Even Varnodes are now slightly more powerful (under the hood they are VarnodeASTs now). Pcode syntax tree ( Function.pcode_tree ) - As far as I know, there was no easy way to work with it. I hope ghidralib makes this much easier. On this level, you still have high PcodeOps , but syntactic elements like \"dowhile\" loops, \"if\" statements etc, are now recovered and you can traverse the syntax tree (while still dealing with PcodeOps ). C abstract syntax tree (AST) - built internally by the decompiler, but not exported by Ghidra. I hope to add support for it in ghidralib one way or another, but for now there is no way to access it. Clang tokens ( Function.tokens ) - a stream of tokens that represent the C code. It is very detailed, to the level that it contains even whitespace. You can clean them up, but the data is still overprocessed a bit too much, and not useful (IMO) during analysis. Ghidra uses it for display. Showcase In this section I'll present a few examples of impressive-but-not-necessarily-useful things you can do with ghidralib. Emulation Emulate the program from 0x400300 to 0x400400. When finished, read the value of eax and the memory at 0x401000. # Create a new emulator and execute code between 0x400300 and 0x400400 emu = Emulator() emu.emulate(0x400300, 0x400400) print(emu[\"eax\"]) print(emu.read_bytes(0x401000, 16)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) In practice you can often use this for recovering obfuscated strings, or unpacking simple packers. Graphs # Get the control flow graph of the main function (and display it) Function(\"main\").control_flow.show() Graph visualisation is not the most useful feature of this library, but it looks cool: And you can easily build the graph yourself: g = Graph.create() foo = g.vertex(\"foo\") bar = g.vertex(\"bar\") g.edge(foo, bar) g.show() Or you can do some actually useful things with included graph algorithms (DFS, BFS, and topological sort) - like tracing paths between functions. Path finding Find the shortest path from source to target in the program control flow graph. If it exists, highlight all basic blocks along the way. source, target = BasicBlock(\"entry\"), BasicBlock(0x00405073) path = Program.control_flow().bfs(source) while path.get(target): target.highlight() target = path[target] You can highlight anything that has an address (like a basic block, function, or a single instruction). Call .unhighlight() to clear the highlight. Conventions There are a few conventions that this library follows, and which may be useful when learning: This library completely ignores the Ghidra \"Address\" abstraction. Plain integers are used everywhere instead. Address abstraction is very powerful, but not necessary for most use cases (at least my use cases). If this is a problem for you, please let me know - maybe there is a simple way to make ghidralib work for you. Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found. IDE Configuration I strongly recommend using an IDE that supports type-checking. This is why: I personally use is VS Code with Python extensions. If you install VsCode/VsCodium, a Python extension, and just drop ghidralib.py in the ghidra_scripts directory, then everything should \"just work\". If for some reason your script lives in a different directory than ghidralib, override the PYTHONPATH so the typechecker knows how to import it: { \"python.analysis.extraPaths\": [\"/home/you/Projects/ghidralib\"], \"terminal.integrated.env.windows\": { \"PYTHONPATH\": \"/home/you/Projects/ghidralib\", } }","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. If you prefer to learn by example, check out the examples directory , or the tests . For a more complete reference, see the API documentation . Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier. IDE configuration I strongly recommend using an IDE that supports type-checking.","title":"Getting Started"},{"location":"getting_started/#installation","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link.","title":"Installation"},{"location":"getting_started/#main-actors","text":"A lot of objects are wrapped by this library. The most important at the beginning are: Function - a function recognised by Ghidra Instruction - assembly instruction DataType - a configured data type Symbol - a named address (also called a label)","title":"Main actors"},{"location":"getting_started/#function","text":"A function is a named block of code. Not all code in Ghidra belongs to a function, but being in a function makes it easier to reason about - for example, we can talk about parameters, variables, return values, etc. Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Print high variables in main function # These are the variables as seen by decompiler - the ones # that one thinks about when reversing print(Function(\"main\").high_variables) # Get the control flow graph of the main function... # ...and show it! (you can do something more useful instead) Function(\"main\").control_flow.show() # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Infer a value of eax and edx at each call of this function for call in Function(\"MyCustomCrypto\").calls: ctx = call.infer_context() key, data = ctx[\"eax\"], ctx[\"edx\"] print(key, data) # Infer parameters for each call to this function (using the decmopiler) for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) Read more in the Function object documentation .","title":"Function"},{"location":"getting_started/#instruction","text":"Instructions represent a single assembly operation. They have a mnemonic (e.g. mov ), operands (e.g. eax, 3 ), and a pcode representation used for further analysis. Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation .","title":"Instruction"},{"location":"getting_started/#datatype","text":"Data types are used to describe the structure of data in memory. Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) # You can also create structures from C code strings: foo = DataType.from_c('struct foo { int a; int b; };') Read more in the DataType object documentation .","title":"DataType"},{"location":"getting_started/#symbol","text":"Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(\"funniner_\" + symbol.name\") Read more in the Symbol object documentation .","title":"Symbol"},{"location":"getting_started/#working-at-various-abstraction-levels","text":"In this section I'll briefly summarize ghidralib objects that you can use to work at various abstraction levels. Assembly instructions - at the lowest level, there is assembler. You will use familiar Instruction , BasicBlock and Function . When analysing data, you will think in terms of Register s of Variables , and references are in terms of Symbols . Pcode instructions - here you think in terms of PcodeOp s, and PcodeBlocks . You still work with Functions , but the data flows between architecture-independent Varnodes now instead. High Pcode instructions - after the decompilation, many things change. You stil work with PcodeOps , but they are significantly transformed - referred as \"High Pcode\" in this library. You now think in terms of High Functions , High Variables , and High Symbols . Even Varnodes are now slightly more powerful (under the hood they are VarnodeASTs now). Pcode syntax tree ( Function.pcode_tree ) - As far as I know, there was no easy way to work with it. I hope ghidralib makes this much easier. On this level, you still have high PcodeOps , but syntactic elements like \"dowhile\" loops, \"if\" statements etc, are now recovered and you can traverse the syntax tree (while still dealing with PcodeOps ). C abstract syntax tree (AST) - built internally by the decompiler, but not exported by Ghidra. I hope to add support for it in ghidralib one way or another, but for now there is no way to access it. Clang tokens ( Function.tokens ) - a stream of tokens that represent the C code. It is very detailed, to the level that it contains even whitespace. You can clean them up, but the data is still overprocessed a bit too much, and not useful (IMO) during analysis. Ghidra uses it for display.","title":"Working at various abstraction levels"},{"location":"getting_started/#showcase","text":"In this section I'll present a few examples of impressive-but-not-necessarily-useful things you can do with ghidralib.","title":"Showcase"},{"location":"getting_started/#emulation","text":"Emulate the program from 0x400300 to 0x400400. When finished, read the value of eax and the memory at 0x401000. # Create a new emulator and execute code between 0x400300 and 0x400400 emu = Emulator() emu.emulate(0x400300, 0x400400) print(emu[\"eax\"]) print(emu.read_bytes(0x401000, 16)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) In practice you can often use this for recovering obfuscated strings, or unpacking simple packers.","title":"Emulation"},{"location":"getting_started/#graphs","text":"# Get the control flow graph of the main function (and display it) Function(\"main\").control_flow.show() Graph visualisation is not the most useful feature of this library, but it looks cool: And you can easily build the graph yourself: g = Graph.create() foo = g.vertex(\"foo\") bar = g.vertex(\"bar\") g.edge(foo, bar) g.show() Or you can do some actually useful things with included graph algorithms (DFS, BFS, and topological sort) - like tracing paths between functions.","title":"Graphs"},{"location":"getting_started/#path-finding","text":"Find the shortest path from source to target in the program control flow graph. If it exists, highlight all basic blocks along the way. source, target = BasicBlock(\"entry\"), BasicBlock(0x00405073) path = Program.control_flow().bfs(source) while path.get(target): target.highlight() target = path[target] You can highlight anything that has an address (like a basic block, function, or a single instruction). Call .unhighlight() to clear the highlight.","title":"Path finding"},{"location":"getting_started/#conventions","text":"There are a few conventions that this library follows, and which may be useful when learning: This library completely ignores the Ghidra \"Address\" abstraction. Plain integers are used everywhere instead. Address abstraction is very powerful, but not necessary for most use cases (at least my use cases). If this is a problem for you, please let me know - maybe there is a simple way to make ghidralib work for you. Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"Conventions"},{"location":"getting_started/#ide-configuration","text":"I strongly recommend using an IDE that supports type-checking. This is why: I personally use is VS Code with Python extensions. If you install VsCode/VsCodium, a Python extension, and just drop ghidralib.py in the ghidra_scripts directory, then everything should \"just work\". If for some reason your script lives in a different directory than ghidralib, override the PYTHONPATH so the typechecker knows how to import it: { \"python.analysis.extraPaths\": [\"/home/you/Projects/ghidralib\"], \"terminal.integrated.env.windows\": { \"PYTHONPATH\": \"/home/you/Projects/ghidralib\", } }","title":"IDE Configuration"},{"location":"reference/","text":"API reference ghidralib This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/. Addr = GenericAddress | int | str module-attribute DataT = GhidraWrapper | JavaObject | str module-attribute HIGHLIGHT_COLOR = SearchConstants . SEARCH_HIGHLIGHT_COLOR module-attribute Reg = GhRegister | str module-attribute Str = ( str , unicode ) module-attribute T = TypeVar ( 'T' ) module-attribute long = int module-attribute unicode = str module-attribute AddressRange Bases: GhidraWrapper Wraps a Ghidra AddressRange object. Source code in ghidralib.py 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 class AddressRange ( GhidraWrapper ): \"\"\"Wraps a Ghidra AddressRange object.\"\"\" @property def addresses ( self ): # type: () -> list[int] \"\"\"Return the addresses in this range.\"\"\" return [ a . getOffset () for a in self . raw . getAddresses ( True )] def __iter__ ( self ): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self . addresses . __iter__ () @property def start ( self ): # type: () -> int \"\"\"Get the first address in this range.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end ( self ): # type: () -> int \"\"\"Get the last address in this range.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def length ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . raw . getLength () def __len__ ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . length def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . raw . contains ( resolve ( addr )) def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . contains ( addr ) @property def is_empty ( self ): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self . raw . isEmpty () def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty def __and__ ( self , other ): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange ( self . raw . intersect ( other . raw )) addresses property Return the addresses in this range. end property Get the last address in this range. is_empty property Return True if this range is empty. length property Get the length of this range. start property Get the first address in this range. __and__ ( other ) Return the intersection of this range and the given range. Source code in ghidralib.py 1485 1486 1487 def __and__ ( self , other ): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange ( self . raw . intersect ( other . raw )) __contains__ ( addr ) Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py 1471 1472 1473 1474 def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . contains ( addr ) __iter__ () Iterate over the addresses in this range. Source code in ghidralib.py 1442 1443 1444 def __iter__ ( self ): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self . addresses . __iter__ () __len__ () Get the length of this range. Source code in ghidralib.py 1461 1462 1463 def __len__ ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . length __nonzero__ () Return True if this range is not empty. Source code in ghidralib.py 1481 1482 1483 def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty contains ( addr ) Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py 1465 1466 1467 1468 1469 def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . raw . contains ( resolve ( addr )) AddressSet Bases: GhidraWrapper Wraps a Ghidra AddressSetView object. Source code in ghidralib.py 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 class AddressSet ( GhidraWrapper ): \"\"\"Wraps a Ghidra AddressSetView object.\"\"\" @staticmethod def empty (): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet ( GhAddressSet ()) @staticmethod def create ( start , length ): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve ( start ) return AddressSet ( GhAddressSet ( addr , addr . add ( length - 1 ))) @property def addresses ( self ): # type: () -> list[int] \"\"\"Return the addresses in this set.\"\"\" return [ a . getOffset () for a in self . raw . getAddresses ( True )] @property def ranges ( self ): # type: () -> list[AddressRange] return [ AddressRange ( r ) for r in self . raw . iterator ( True )] def __iter__ ( self ): # type: () -> Iterator[int] return self . addresses . __iter__ () def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . raw . contains ( resolve ( addr )) def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . contains ( addr ) @property def is_empty ( self ): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self . raw . isEmpty () def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty def __and__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet ( self . raw . intersect ( other . raw )) def __sub__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet ( self . raw . subtract ( other . raw )) def __xor__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet ( self . raw . xor ( other . raw )) def __or__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet ( self . raw . union ( other . raw )) def __get_highlighter ( self ): # type: () -> Any tool = state . getTool () service = tool . getService ( ColorizingService ) if service is None : raise RuntimeError ( \"Cannot highlight without the ColorizingService\" ) return service def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None service = self . __get_highlighter () service . setBackgroundColor ( self . raw , color ) def unhighlight ( self ): # type: (Color) -> None service = self . __get_highlighter () service . clearBackgroundColor ( self . raw ) addresses property Return the addresses in this set. is_empty property Return True if this range is empty. ranges property __and__ ( other ) Return the intersection of this set and the given set. Source code in ghidralib.py 1533 1534 1535 def __and__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet ( self . raw . intersect ( other . raw )) __contains__ ( addr ) Return True if the given address is in this range. Source code in ghidralib.py 1520 1521 1522 def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . contains ( addr ) __get_highlighter () Source code in ghidralib.py 1549 1550 1551 1552 1553 1554 def __get_highlighter ( self ): # type: () -> Any tool = state . getTool () service = tool . getService ( ColorizingService ) if service is None : raise RuntimeError ( \"Cannot highlight without the ColorizingService\" ) return service __iter__ () Source code in ghidralib.py 1513 1514 def __iter__ ( self ): # type: () -> Iterator[int] return self . addresses . __iter__ () __nonzero__ () Return True if this range is not empty. Source code in ghidralib.py 1529 1530 1531 def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty __or__ ( other ) Computes the union of this set and the given set. Source code in ghidralib.py 1545 1546 1547 def __or__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet ( self . raw . union ( other . raw )) __sub__ ( other ) Subtract the given set from this set. Source code in ghidralib.py 1537 1538 1539 def __sub__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet ( self . raw . subtract ( other . raw )) __xor__ ( other ) Computes the symmetric difference of this set and the given set. Source code in ghidralib.py 1541 1542 1543 def __xor__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet ( self . raw . xor ( other . raw )) contains ( addr ) Return True if the given address is in this range. Source code in ghidralib.py 1516 1517 1518 def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . raw . contains ( resolve ( addr )) create ( start , length ) staticmethod Create a new AddressSet with given address and length. Source code in ghidralib.py 1498 1499 1500 1501 1502 @staticmethod def create ( start , length ): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve ( start ) return AddressSet ( GhAddressSet ( addr , addr . add ( length - 1 ))) empty () staticmethod Create a new empty address set Source code in ghidralib.py 1493 1494 1495 1496 @staticmethod def empty (): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet ( GhAddressSet ()) highlight ( color = HIGHLIGHT_COLOR ) Source code in ghidralib.py 1556 1557 1558 def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None service = self . __get_highlighter () service . setBackgroundColor ( self . raw , color ) unhighlight () Source code in ghidralib.py 1560 1561 1562 def unhighlight ( self ): # type: (Color) -> None service = self . __get_highlighter () service . clearBackgroundColor ( self . raw ) BasicBlock Bases: AddressSet , BodyTrait Wraps a Ghidra CodeBlock object Source code in ghidralib.py 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 class BasicBlock ( AddressSet , BodyTrait ): \"\"\"Wraps a Ghidra CodeBlock object\"\"\" @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock|None \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if raw_or_address is None : return None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( Program . current ()) addr = try_resolve ( raw_or_address ) if addr is None : return None raw = block_model . getFirstCodeBlockContaining ( addr , TaskMonitor . DUMMY ) if raw is None : return None else : raw = raw_or_address return BasicBlock ( raw ) @staticmethod def all (): # type: () -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = SimpleBlockModel ( Program . current ()) return [ BasicBlock ( b ) for b in block_model . getCodeBlocks ( TaskMonitor . DUMMY )] @property def name ( self ): # type: () -> str \"\"\"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.\"\"\" return self . raw . getName () @property def address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . start_address @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ] @property def body ( self ): # type: () -> AddressSet \"\"\"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.\"\"\" return AddressSet ( self . raw ) @property def flow_type ( self ): # type: () -> FlowType \"\"\"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.\"\"\" return FlowType ( self . raw . getFlowType ()) def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance ( other , BasicBlock ): return False # This is not fully correct, but more correct than the default. return self . address == other . address address property Get the address of the first instruction in this basic block. body property Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep. destinations property Get a list of basic blocks that this basic block jumps to end_address property Get the address of the last instruction in this basic block. flow_type property Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node. instructions property Get a list of instructions in this basic block. name property Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string. pcode property Get a list of Pcode operations that this basic block was parsed to sources property Get a list of basic blocks that jump to this basic block start_address property Get the address of the first instruction in this basic block. __eq__ ( other ) Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this Source code in ghidralib.py 1667 1668 1669 1670 1671 1672 1673 1674 def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance ( other , BasicBlock ): return False # This is not fully correct, but more correct than the default. return self . address == other . address all () staticmethod Get a list of all basic blocks in the program. Source code in ghidralib.py 1592 1593 1594 1595 1596 @staticmethod def all (): # type: () -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = SimpleBlockModel ( Program . current ()) return [ BasicBlock ( b ) for b in block_model . getCodeBlocks ( TaskMonitor . DUMMY )] get ( raw_or_address ) staticmethod Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock|None \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if raw_or_address is None : return None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( Program . current ()) addr = try_resolve ( raw_or_address ) if addr is None : return None raw = block_model . getFirstCodeBlockContaining ( addr , TaskMonitor . DUMMY ) if raw is None : return None else : raw = raw_or_address return BasicBlock ( raw ) BlockGraph Bases: PcodeBlock Source code in ghidralib.py 952 953 954 955 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())] blocks property BodyTrait A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting. Source code in ghidralib.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 class BodyTrait : \"\"\"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting.\"\"\" @property @abstractmethod def body ( self ): # type: () -> AddressSet \"\"\"The body of this object\"\"\" def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self . body . highlight ( color ) def unhighlight ( self ): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self . body . unhighlight () body abstractmethod property The body of this object highlight ( color = HIGHLIGHT_COLOR ) Highlight this instruction in the listing. Source code in ghidralib.py 509 510 511 def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self . body . highlight ( color ) unhighlight () Clear the highlight from this instruction. Source code in ghidralib.py 513 514 515 def unhighlight ( self ): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self . body . unhighlight () ClangTokenGroup Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 class ClangTokenGroup ( GhidraWrapper ): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup ( self , token ): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup ( token . Parent ()) for token in list ( token . iterator ()): if isinstance ( token , ( ClangCommentToken , ClangBreak )): continue if isinstance ( token , ClangSyntaxToken ): if not token . getText () or token . getText () . isspace (): continue if isinstance ( token , GhClangTokenGroup ): token = self . _cleanup ( token ) new . AddTokenGroup ( token ) return new @property def cleaned ( self ): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup ( self . _cleanup ( self . raw )) def _dump ( self , token , indent = 0 ): # type: (JavaObject, int) -> None if isinstance ( token , GhClangTokenGroup ): print ( \" {} [group]\" . format ( indent * \" \" , token . __class__ . __name__ )) for child in token . iterator (): self . _dump ( child , indent + 1 ) else : print ( \" {}{} ( {} )\" . format ( indent * \" \" , token , token . __class__ . __name__ )) def dump ( self ): # type: () -> None self . _dump ( self . raw ) cleaned property Remove all whitespace and comments from this token group, recursively. dump () Source code in ghidralib.py 1992 1993 def dump ( self ): # type: () -> None self . _dump ( self . raw ) DataType Bases: GhidraWrapper Source code in ghidralib.py 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 class DataType ( GhidraWrapper ): @staticmethod def get ( name_or_raw ): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance ( name_or_raw , Str ): return DataType ( name_or_raw ) for datatype in DataType . all (): if datatype . name == name_or_raw : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( Program . current () . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' . \"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) def length ( self ): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self . raw . getLength () __len__ = length @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program . current () . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt __len__ = length class-attribute instance-attribute name property Get a name of this data type >>> DataType('int').name 'int' . all ( only_local = False ) staticmethod Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( Program . current () . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes from_c ( c_code , insert = True ) staticmethod Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program . current () . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt get ( name_or_raw ) staticmethod Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name_or_raw \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 @staticmethod def get ( name_or_raw ): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance ( name_or_raw , Str ): return DataType ( name_or_raw ) for datatype in DataType . all (): if datatype . name == name_or_raw : return DataType ( datatype ) return None get_name ( value ) If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py 2545 2546 2547 2548 2549 def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) length () Get the length of this data type in bytes >>> DataType('int').length() 4 . Source code in ghidralib.py 2551 2552 2553 2554 2555 2556 2557 2558 def length ( self ): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self . raw . getLength () Emulator Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 class Emulator ( GhidraWrapper ): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( Program . current ()) GhidraWrapper . __init__ ( self , raw ) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr ( 0 ) . getAddressSpace () . getMaxAddress () . getOffset () stack_off = ( max_pointer >> 1 ) - 0x8000 self . raw . writeRegister ( self . raw . getStackPointerRegister (), stack_off ) # TODO: add a simple allocation manager @property def pc ( self ): # type: () -> int \"\"\"Get the program counter of the emulated program.\"\"\" return self . raw . getExecutionAddress () . getOffset () def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , resolve ( address ) . getOffset ()) def __getitem__ ( self , reg ): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self . read_register ( reg ) def __setitem__ ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self . write_register ( reg , value ) def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) def read_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( resolve ( address ), length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_u8 ( self , address ): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 1 )) def read_u16 ( self , address ): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 2 )) def read_u32 ( self , address ): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 4 )) def read_u64 ( self , address ): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 8 )) def read_cstring ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string def read_unicode ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . read_bytes ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . read_bytes ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_stack : return self . raw . readStackValue ( varnode . offset , varnode . size , False ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . read_register ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) def write_bytes ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( resolve ( address ), value ) def write_u8 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 8 , \"value out of range\" self . write_bytes ( address , chr ( value )) def write_u16 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 16 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 2 )) def write_u32 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 32 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 4 )) def write_u64 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 64 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 8 )) def write_varnode ( self , varnode , value ): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : raise ValueError ( \"Can't set value of a constant varnodes\" ) elif varnode . is_address : self . write_bytes ( varnode . offset , to_bytes ( value , varnode . size )) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) self . write_bytes ( offset , to_bytes ( value , varnode . size )) elif varnode . is_stack : self . raw . writeStackValue ( varnode . offset , varnode . size , value ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) self . raw . writeRegister ( reg , value ) else : raise RuntimeError ( \"Unsupported varnode type\" ) def emulate ( self , start , ends ): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self . set_pc ( start ) if not isinstance ( ends , ( list , tuple )): ends = [ ends ] for end in ends : end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( monitor ) for end in ends : end = resolve ( end ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def emulate_while ( self , start , condition ): # type: (Addr, Callable[[Emulator], bool]) -> None \"\"\"Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. :param start: the start address to emulate :param condition: a function that takes an Emulator instance as a parameter, and decides if emulation should be continued\"\"\" self . set_pc ( start ) emu = self . raw . getEmulator () emu . setHalt ( False ) while not emu . getHalt () and condition ( self ): emu . executeInstruction ( True , monitor ) if self . raw . getLastError () is not None : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def trace ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[Instruction], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed instruction :param maxsteps: the maximum number of steps to execute\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end and maxsteps > 0 : success = self . raw . step ( monitor ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) callback ( Instruction ( current )) current = self . raw . getExecutionAddress () maxsteps -= 1 def trace_pcode ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[PcodeOp], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed pcode op\"\"\" def instr_callback ( instruction ): # type: (Instruction) -> None for op in instruction . pcode : callback ( op ) self . trace ( start , end , instr_callback , maxsteps ) def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] \"\"\"Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. :param start: the start address to propagate from :param end: the end address to propagate to\"\"\" known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state pc property Get the program counter of the emulated program. __getitem__ ( reg ) Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 Parameters: reg \u2013 the register or address to read from Source code in ghidralib.py 2621 2622 2623 2624 2625 2626 2627 2628 2629 def __getitem__ ( self , reg ): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self . read_register ( reg ) __init__ () Create a new Emulator object. Source code in ghidralib.py 2599 2600 2601 2602 2603 2604 2605 2606 2607 def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( Program . current ()) GhidraWrapper . __init__ ( self , raw ) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr ( 0 ) . getAddressSpace () . getMaxAddress () . getOffset () stack_off = ( max_pointer >> 1 ) - 0x8000 self . raw . writeRegister ( self . raw . getStackPointerRegister (), stack_off ) __setitem__ ( reg , value ) Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 def __setitem__ ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self . write_register ( reg , value ) emulate ( start , ends ) Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Parameters: start \u2013 the start address to emulate ends \u2013 one or many end address Source code in ghidralib.py 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 def emulate ( self , start , ends ): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self . set_pc ( start ) if not isinstance ( ends , ( list , tuple )): ends = [ ends ] for end in ends : end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( monitor ) for end in ends : end = resolve ( end ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) emulate_while ( start , condition ) Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. Parameters: start \u2013 the start address to emulate condition \u2013 a function that takes an Emulator instance as a parameter, and decides if emulation should be continued Source code in ghidralib.py 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 def emulate_while ( self , start , condition ): # type: (Addr, Callable[[Emulator], bool]) -> None \"\"\"Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. :param start: the start address to emulate :param condition: a function that takes an Emulator instance as a parameter, and decides if emulation should be continued\"\"\" self . set_pc ( start ) emu = self . raw . getEmulator () emu . setHalt ( False ) while not emu . getHalt () and condition ( self ): emu . executeInstruction ( True , monitor ) if self . raw . getLastError () is not None : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) propagate_varnodes ( start , end ) Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. Parameters: start \u2013 the start address to propagate from end \u2013 the end address to propagate to Source code in ghidralib.py 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] \"\"\"Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. :param start: the start address to propagate from :param end: the end address to propagate to\"\"\" known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state read_bytes ( address , length ) Read length bytes at address from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 def read_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( resolve ( address ), length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) read_cstring ( address ) Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 def read_cstring ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string read_register ( reg ) Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py 2642 2643 2644 2645 2646 2647 2648 2649 2650 def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) read_u16 ( address ) Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2674 2675 2676 2677 2678 2679 2680 2681 2682 def read_u16 ( self , address ): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 2 )) read_u32 ( address ) Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2684 2685 2686 2687 2688 2689 2690 2691 2692 def read_u32 ( self , address ): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 4 )) read_u64 ( address ) Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2694 2695 2696 2697 2698 2699 2700 2701 2702 def read_u64 ( self , address ): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 8 )) read_u8 ( address ) Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2664 2665 2666 2667 2668 2669 2670 2671 2672 def read_u8 ( self , address ): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 1 )) read_unicode ( address ) Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 def read_unicode ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string read_varnode ( varnode ) Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . read_bytes ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . read_bytes ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_stack : return self . raw . readStackValue ( varnode . offset , varnode . size , False ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . read_register ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) set_pc ( address ) Set the program counter of the emulated program. Source code in ghidralib.py 2616 2617 2618 2619 def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , resolve ( address ) . getOffset ()) trace ( start , end , callback , maxsteps = 2 ** 48 ) Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed instruction maxsteps \u2013 the maximum number of steps to execute Source code in ghidralib.py 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 def trace ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[Instruction], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed instruction :param maxsteps: the maximum number of steps to execute\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end and maxsteps > 0 : success = self . raw . step ( monitor ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) callback ( Instruction ( current )) current = self . raw . getExecutionAddress () maxsteps -= 1 trace_pcode ( start , end , callback , maxsteps = 2 ** 48 ) Emulate from start to end address, with callback for each executed PcodeOp. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed pcode op Source code in ghidralib.py 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 def trace_pcode ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[PcodeOp], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed pcode op\"\"\" def instr_callback ( instruction ): # type: (Instruction) -> None for op in instruction . pcode : callback ( op ) self . trace ( start , end , instr_callback , maxsteps ) write_bytes ( address , value ) Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 def write_bytes ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( resolve ( address ), value ) write_register ( reg , value ) Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) write_u16 ( address , value ) Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 def write_u16 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 16 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 2 )) write_u32 ( address , value ) Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 def write_u32 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 32 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 4 )) write_u64 ( address , value ) Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 def write_u64 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 64 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 8 )) write_u8 ( address , value ) Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 def write_u8 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 8 , \"value out of range\" self . write_bytes ( address , chr ( value )) write_varnode ( varnode , value ) Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 def write_varnode ( self , varnode , value ): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : raise ValueError ( \"Can't set value of a constant varnodes\" ) elif varnode . is_address : self . write_bytes ( varnode . offset , to_bytes ( value , varnode . size )) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) self . write_bytes ( offset , to_bytes ( value , varnode . size )) elif varnode . is_stack : self . raw . writeStackValue ( varnode . offset , varnode . size , value ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) self . raw . writeRegister ( reg , value ) else : raise RuntimeError ( \"Unsupported varnode type\" ) FlowType Bases: GhidraWrapper Wraps a Ghidra FlowType object Source code in ghidralib.py 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 class FlowType ( GhidraWrapper ): \"\"\"Wraps a Ghidra FlowType object\"\"\" @property def is_call ( self ): # type: () -> bool \"\"\"Return True if this flow is a call.\"\"\" return self . raw . isCall () @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if this flow is a jump.\"\"\" return self . raw . isJump () @property def is_computed ( self ): # type: () -> bool \"\"\"Return True if this flow is a computed jump.\"\"\" return self . raw . isComputed () @property def is_conditional ( self ): # type: () -> bool \"\"\"Return True if this flow is a conditional jump.\"\"\" return self . raw . isConditional () @property def is_unconditional ( self ): # type: () -> bool \"\"\"Return True if this flow is an unconditional jump.\"\"\" return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool \"\"\"Return True if this flow is a terminator.\"\"\" return self . raw . isTerminator () @property def has_fallthrough ( self ): # type: () -> bool \"\"\"Return True if this flow has a fallthrough.\"\"\" return self . raw . hasFallThrough () @property def is_override ( self ): # type: () -> bool \"\"\"Return True if this flow is an override.\"\"\" return self . raw . isOverride () has_fallthrough property Return True if this flow has a fallthrough. is_call property Return True if this flow is a call. is_computed property Return True if this flow is a computed jump. is_conditional property Return True if this flow is a conditional jump. is_jump property Return True if this flow is a jump. is_override property Return True if this flow is an override. is_terminal property Return True if this flow is a terminator. is_unconditional property Return True if this flow is an unconditional jump. Function Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Function object. Source code in ghidralib.py 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 class Function ( GhidraWrapper , BodyTrait ): \"\"\"Wraps a Ghidra Function object.\"\"\" UNDERLYING_CLASS = GhFunction @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance ( addr , GhFunction ): return Function ( addr ) if isinstance ( addr , Function ): return Function ( addr . raw ) addr = try_resolve ( addr ) if addr is None : return None raw = Program . current () . getListing () . getFunctionContaining ( addr ) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program . current () . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self . entrypoint @property def name ( self ): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self . raw . getName () @property def comment ( self ): # type: () -> str|None \"\"\"Get the comment of this function, if any.\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str|None \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] \"\"\"Get the parameters of this function.\"\"\" return [ Parameter ( raw ) for raw in self . raw . getParameters ()] def add_named_parameter ( self , datatype , name ): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self . raw . hasCustomVariableStorage (): raise ValueError ( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , 0 , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) def add_register_parameter ( self , datatype , register , name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self . raw . hasCustomVariableStorage (): self . raw . setCustomVariableStorage ( True ) reg = Register ( register ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , reg . raw , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) @property def local_variables ( self ): # type: () -> list[Variable] \"\"\"Get the local variables of this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with a variable in this function.\"\"\" varnodes = [] for var in self . variables : varnodes . extend ( var . varnodes ) return varnodes @property def high_variables ( self ): # type: () -> list[HighVariable] \"\"\"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . high_function . variables @property def stack ( self ): # type: () -> list[Variable] \"\"\"Get the defined stack variables (both parameters and locals).\"\"\" raw_vars = self . raw . getStackFrame () . getStackVariables () return [ Variable ( raw ) for raw in raw_vars ] def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = Program . current () . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] xrefs_to = xrefs @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str|None \"\"\"Get the fixup of this function.\"\"\" return self . raw . getCallFixup () @fixup . setter def fixup ( self , fixup ): # type: (str|None) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self . raw . setCallFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] \"\"\"Get all function calls to this function.\"\"\" calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel ( Program . current ()) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface () decompiler . openProgram ( Program . current ()) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () @property def clang_tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ()) @property def high_function ( self ): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . pcode_tree @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self . basicblocks : result . extend ( block . pcode ) return result @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_pcode () @property def high_basicblocks ( self ): # type: () -> list[PcodeBlock] \"\"\"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . high_function . basicblocks def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address ) @property def high_symbols ( self ): # type: () -> list[HighSymbol] \"\"\"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . symbols @property def primary_symbols ( self ): # type: () -> list[Symbol] \"\"\"Get the primary symbols for this function.\"\"\" symtable = Program . current () . getSymbolTable () syms = symtable . getPrimarySymbolIterator ( self . raw . getBody (), True ) return [ Symbol ( s ) for s in syms ] @property def symbols ( self ): # type: () -> list[Symbol] \"\"\"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.\"\"\" body = self . raw . getBody () symbols = [] symtable = Program . current () . getSymbolTable () for rng in body : for addr in rng : symbols . extend ( symtable . getSymbols ( addr )) return [ Symbol ( raw ) for raw in symbols ] @property def body ( self ): # type: () -> AddressSet \"\"\"Get the set of addresses of this function.\"\"\" return AddressSet ( self . raw . getBody ()) @property def control_flow ( self ): # type: () -> Graph[BasicBlock] \"\"\"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.\"\"\" g = Graph . create () for block in self . basicblocks : g . vertex ( block ) for block in self . basicblocks : for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g def emulate ( self , * args , ** kwargs ): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs : # Jython doesn't support keyword arguments after args, apparently emulator = kwargs [ \"emulator\" ] else : emulator = Emulator () if len ( args ) != len ( self . raw . getParameters ()): raise ValueError ( \"Wrong number of arguments for {} - got {} expected {} \" . format ( self . name , len ( args ), len ( self . raw . getParameters ()) ) ) for param , value in zip ( self . parameters , args ): emulator . write_varnode ( param . varnode , value ) emulator . emulate_while ( self . entrypoint , lambda e : e . pc in self . body ) return emulator UNDERLYING_CLASS = GhFunction class-attribute instance-attribute address property Get the address of this function. basicblocks property Get the basic blocks of this function. body property Get the set of addresses of this function. called property Get all functions that are called by this function. callers property Get all functions that call this function. calls property Get all function calls to this function. clang_tokens property Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value. comment property Get the comment of this function, if any. control_flow property Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function. entrypoint property Get the entrypoint of this function. fixup property writable Get the fixup of this function. high_basicblocks property Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow. high_function property Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. high_pcode property Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow. high_symbols property Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow. high_variables property Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow. instructions property Get the assembler instructions for this function. is_external property Return True if this function is external. is_thunk property Return True if this function is a thunk. local_variables property Get the local variables of this function. name property Get the name of this function. parameters property Get the parameters of this function. pcode property Get the (low-level) Pcode for this function. pcode_tree property Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. primary_symbols property Get the primary symbols for this function. repeatable_comment property Get the repeatable comment of this function, if any. return_type property Get the return type of this function. return_variable property Get the variable representing a return value of this function. stack property Get the defined stack variables (both parameters and locals). symbols property Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate. variables property Get all variables defined in this function. varnodes property Get all varnodes associated with a variable in this function. xref_addrs property Get the source addresses of references to this function. xrefs property Get the references to this function. xrefs_to = xrefs class-attribute instance-attribute add_named_parameter ( datatype , name ) Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented Source code in ghidralib.py 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 def add_named_parameter ( self , datatype , name ): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self . raw . hasCustomVariableStorage (): raise ValueError ( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , 0 , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) add_register_parameter ( datatype , register , name ) Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore Source code in ghidralib.py 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 def add_register_parameter ( self , datatype , register , name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self . raw . hasCustomVariableStorage (): self . raw . setCustomVariableStorage ( True ) reg = Register ( register ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , reg . raw , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) all () staticmethod Return all functions in the current program. Source code in ghidralib.py 2017 2018 2019 2020 2021 @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program . current () . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] create ( address , name ) staticmethod Create a new function at the given address with the given name. Source code in ghidralib.py 2023 2024 2025 2026 2027 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) decompile () Get decompiled C code for the function as string. Source code in ghidralib.py 2226 2227 2228 2229 def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () emulate ( * args , ** kwargs ) Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 def emulate ( self , * args , ** kwargs ): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs : # Jython doesn't support keyword arguments after args, apparently emulator = kwargs [ \"emulator\" ] else : emulator = Emulator () if len ( args ) != len ( self . raw . getParameters ()): raise ValueError ( \"Wrong number of arguments for {} - got {} expected {} \" . format ( self . name , len ( args ), len ( self . raw . getParameters ()) ) ) for param , value in zip ( self . parameters , args ): emulator . write_varnode ( param . varnode , value ) emulator . emulate_while ( self . entrypoint , lambda e : e . pc in self . body ) return emulator get ( addr ) staticmethod Return a function at the given address, or None if no function exists there. Source code in ghidralib.py 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance ( addr , GhFunction ): return Function ( addr ) if isinstance ( addr , Function ): return Function ( addr . raw ) addr = try_resolve ( addr ) if addr is None : return None raw = Program . current () . getListing () . getFunctionContaining ( addr ) if raw is None : return None return Function ( raw ) # type: ignore get_high_function ( simplify = 'decompile' ) Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 2246 2247 2248 2249 2250 2251 2252 2253 2254 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) get_high_pcode ( simplify = 'decompile' ) Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 2256 2257 2258 2259 2260 2261 2262 2263 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode get_high_pcode_at ( address ) Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py 2294 2295 2296 2297 2298 2299 2300 2301 2302 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address ) rename ( name ) Change the name of this function. Source code in ghidralib.py 2148 2149 2150 def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) set_comment ( comment ) Set the comment of this function. Source code in ghidralib.py 2059 2060 2061 def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) set_repeatable_comment ( comment ) Set the repeatable comment of this function. Source code in ghidralib.py 2078 2079 2080 def set_repeatable_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) FunctionCall Bases: BodyTrait Represents an abstract function call. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 class FunctionCall ( BodyTrait ): \"\"\"Represents an abstract function call. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . called_function = function self . address = resolve ( address ) @property def caller ( self ): # type: () -> Function|None \"\"\"Get the function where this function call takes place.\"\"\" return Function . get ( self . address ) calling_function = caller @property def instruction ( self ): # type: () -> Instruction return Instruction ( self . address ) @property def callee ( self ): # type: () -> Function \"\"\"Get the function being called.\"\"\" return self . called_function def infer_context ( self ): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. \"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu @property def high_pcodeop ( self ): # type: () -> PcodeOp|None \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) @property def high_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" op = self . high_pcodeop if not op : return [] return op . inputs [ 1 :] # skip function addr def infer_args ( self ): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" basicblock = BasicBlock ( self . address ) state = {} # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . high_varnodes : varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args @property def body ( self ): return self . instruction . body address = resolve ( address ) instance-attribute body property called_function = function instance-attribute callee property Get the function being called. caller property Get the function where this function call takes place. calling_function = caller class-attribute instance-attribute high_pcodeop property Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. high_varnodes property Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. instruction property __init__ ( function , address ) Source code in ghidralib.py 1853 1854 1855 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . called_function = function self . address = resolve ( address ) infer_args () Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 def infer_args ( self ): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" basicblock = BasicBlock ( self . address ) state = {} # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . high_varnodes : varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args infer_context () Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. Source code in ghidralib.py 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 def infer_context ( self ): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. \"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu GenericT Source code in ghidralib.py 275 276 class GenericT : pass GhidraWrapper Bases: object The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class GhidraWrapper ( object ): \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__ ( self , raw ): # type: (JavaObject|int|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str , unicode , GenericAddress )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) # TODO - remove the conditional checks and implement this everywhere if hasattr ( self , \"UNDERLYING_CLASS\" ): wrapped_type = getattr ( self , \"UNDERLYING_CLASS\" ) if not isinstance ( raw , wrapped_type ): raise RuntimeError ( \"You are trying to wrap {} as {} \" . format ( raw . __class__ . __name__ , self . __class__ . __name__ ) ) self . raw = _as_javaobject ( raw ) # type: JavaObject def __str__ ( self ): # type: () -> str return self . raw . __str__ () def __repr__ ( self ): # type: () -> str return self . raw . __repr__ () def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) raw = _as_javaobject ( raw ) instance-attribute __eq__ ( other ) Source code in ghidralib.py 164 165 166 167 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __hash__ () Source code in ghidralib.py 161 162 def __hash__ ( self ): # type: () -> int return self . raw . hashCode () __init__ ( raw ) Source code in ghidralib.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , raw ): # type: (JavaObject|int|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str , unicode , GenericAddress )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) # TODO - remove the conditional checks and implement this everywhere if hasattr ( self , \"UNDERLYING_CLASS\" ): wrapped_type = getattr ( self , \"UNDERLYING_CLASS\" ) if not isinstance ( raw , wrapped_type ): raise RuntimeError ( \"You are trying to wrap {} as {} \" . format ( raw . __class__ . __name__ , self . __class__ . __name__ ) ) self . raw = _as_javaobject ( raw ) # type: JavaObject __repr__ () Source code in ghidralib.py 154 155 def __repr__ ( self ): # type: () -> str return self . raw . __repr__ () __str__ () Source code in ghidralib.py 151 152 def __str__ ( self ): # type: () -> str return self . raw . __str__ () __tojava__ ( klass ) Make it possible to pass this object to Java methods Source code in ghidralib.py 157 158 159 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw Graph Bases: GenericT , GhidraWrapper Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see get_unique_string() method. Source code in ghidralib.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 class Graph ( GenericT , GhidraWrapper ): \"\"\"Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see get_unique_string() method.\"\"\" def __init__ ( self , raw ): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper . __init__ ( self , raw ) self . data = {} @staticmethod def create ( name = None , description = None ): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType ( name , description , [], []) return Graph ( AttributedGraph ( name , graphtype , description )) def __contains__ ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = get_unique_string ( vtx ) vobj = self . raw . getVertex ( vid ) return self . raw . containsVertex ( vobj ) def has_vertex ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self def vertex ( self , vtx , name = None ): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = get_unique_string ( vtx ) name = name or vid self . raw . addVertex ( vid , name ) self . data [ vid ] = vtx return vtx def edge ( self , src , dst ): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = get_unique_string ( src ) dstid = get_unique_string ( dst ) srcobj = self . raw . getVertex ( srcid ) dstobj = self . raw . getVertex ( dstid ) self . raw . addEdge ( srcobj , dstobj ) @property def vertices ( self ): # type: () -> list[T] \"\"\"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.\"\"\" return [ self . __resolve ( vid . getId ()) for vid in self . raw . vertexSet ()] @property def vertex_count ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph.\"\"\" return self . raw . vertexSet () . size () def __len__ ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self . vertex_count @property def edges ( self ): # type: () -> list[T] \"\"\"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.\"\"\" result = [] for e in self . raw . edgeSet (): frm = self . raw . getEdgeSource ( e ) to = self . raw . getEdgeTarget ( e ) frmobj = self . data . get ( frm , frm ) toobj = self . data . get ( to , frm ) result . append (( frmobj , toobj )) return result @property def edge_count ( self ): # type: () -> int \"\"\"Return the number of edges in this graph.\"\"\" return self . raw . edgeSet () . size () @property def name ( self ): # type: () -> str \"\"\"Return the name of this graph.\"\"\" return self . raw . getName () @property def description ( self ): # type: () -> str \"\"\"Return the description of this graph.\"\"\" return self . raw . getDescription () def show ( self ): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self . raw . getGraphType () description = graphtype . getDescription () options = GraphDisplayOptions ( graphtype ) broker = state . tool . getService ( GraphDisplayBroker ) display = broker . getDefaultGraphDisplay ( False , monitor ) display . setGraph ( self . raw , options , description , False , monitor ) def __resolve ( self , vid ): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self . data : return self . data [ vid ] else : return vid # type: ignore graph created outside of ghidralib? def dfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop () if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents def toposort ( self , origin ): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. :returns: a list of vertex IDs in topological order.\"\"\" visited = set () result = [] def dfs ( vid ): visited . add ( vid ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): target = self . raw . getEdgeTarget ( edge ) if target . getId () not in visited : dfs ( target . getId ()) result . append ( self . __resolve ( vid )) dfs ( get_unique_string ( origin )) for vid in self . raw . vertexSet (): if vid . getId () not in visited : dfs ( vid . getId ()) return result def bfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop ( 0 ) if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents data = {} instance-attribute description property Return the description of this graph. edge_count property Return the number of edges in this graph. edges property Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting. name property Return the name of this graph. vertex_count property Return the number of vertices in this graph. vertices property Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting. __contains__ ( vtx ) Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py 310 311 312 313 314 315 316 def __contains__ ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = get_unique_string ( vtx ) vobj = self . raw . getVertex ( vid ) return self . raw . containsVertex ( vobj ) __init__ ( raw ) Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. Parameters: raw \u2013 The AttributedGraph object to wrap. Source code in ghidralib.py 286 287 288 289 290 291 292 293 294 def __init__ ( self , raw ): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper . __init__ ( self , raw ) self . data = {} __len__ () Return the number of vertices in this graph. To get the number of edges, use edge_count. Source code in ghidralib.py 362 363 364 365 366 def __len__ ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self . vertex_count __resolve ( vid ) Resolve a vertex ID to a vertex object. Parameters: vid \u2013 The ID of the vertex to resolve. Source code in ghidralib.py 408 409 410 411 412 413 414 415 def __resolve ( self , vid ): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self . data : return self . data [ vid ] else : return vid # type: ignore graph created outside of ghidralib? bfs ( origin , callback = lambda _ : None ) Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Source code in ghidralib.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def bfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop ( 0 ) if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents create ( name = None , description = None ) staticmethod Create a new Graph. Parameters: name \u2013 The name of the graph. If None, a default name will be used. description \u2013 The description of the graph. If None, a default description will be used. Returns: \u2013 a new Graph object. Source code in ghidralib.py 296 297 298 299 300 301 302 303 304 305 306 307 308 @staticmethod def create ( name = None , description = None ): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType ( name , description , [], []) return Graph ( AttributedGraph ( name , graphtype , description )) dfs ( origin , callback = lambda _ : None ) Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Returns: \u2013 A dictionary of parent vertices for each visited vertex. Source code in ghidralib.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def dfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop () if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents edge ( src , dst ) Create an edge between two vertices in this graph. Parameters: src \u2013 The source vertex ID. dst \u2013 The destination vertex ID. Source code in ghidralib.py 338 339 340 341 342 343 344 345 346 347 def edge ( self , src , dst ): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = get_unique_string ( src ) dstid = get_unique_string ( dst ) srcobj = self . raw . getVertex ( srcid ) dstobj = self . raw . getVertex ( dstid ) self . raw . addEdge ( srcobj , dstobj ) has_vertex ( vtx ) Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py 318 319 320 321 322 def has_vertex ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self show () Display this graph in the Ghidra GUI. Source code in ghidralib.py 398 399 400 401 402 403 404 405 406 def show ( self ): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self . raw . getGraphType () description = graphtype . getDescription () options = GraphDisplayOptions ( graphtype ) broker = state . tool . getService ( GraphDisplayBroker ) display = broker . getDefaultGraphDisplay ( False , monitor ) display . setGraph ( self . raw , options , description , False , monitor ) toposort ( origin ) Perform a topological sort on this graph, starting from the given vertex. Parameters: origin \u2013 The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. Returns: \u2013 a list of vertex IDs in topological order. Source code in ghidralib.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def toposort ( self , origin ): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. :returns: a list of vertex IDs in topological order.\"\"\" visited = set () result = [] def dfs ( vid ): visited . add ( vid ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): target = self . raw . getEdgeTarget ( edge ) if target . getId () not in visited : dfs ( target . getId ()) result . append ( self . __resolve ( vid )) dfs ( get_unique_string ( origin )) for vid in self . raw . vertexSet (): if vid . getId () not in visited : dfs ( vid . getId ()) return result vertex ( vtx , name = None ) Get or create a vertex in this graph. Parameters: vtx \u2013 The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. name \u2013 The name of the vertex. If not provided, the ID will be used as the name. Returns: \u2013 vtx parameter is returned Source code in ghidralib.py 324 325 326 327 328 329 330 331 332 333 334 335 336 def vertex ( self , vtx , name = None ): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = get_unique_string ( vtx ) name = name or vid self . raw . addVertex ( vid , name ) self . data [ vid ] = vtx return vtx HighFunction Bases: GhidraWrapper Source code in ghidralib.py 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 class HighFunction ( GhidraWrapper ): @staticmethod def get ( address ): # type: (JavaObject|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance ( address , GhHighFunction ): return HighFunction ( address ) func = Function . get ( address ) if func is None : return None return func . high_function @property def function ( self ): # type: () -> Function \"\"\"Get the underlying function of this high function.\"\"\" return Function ( self . raw . getFunction ()) def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basicblocks ( self ): # type: () -> list[PcodeBlock] \"\"\"Get a list of basic blocks in this high function.\"\"\" return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" edge_map = {} ingraph = GhBlockGraph () for block in self . basicblocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basicblocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( Program . current ()) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) @property def symbols ( self ): # type: () -> list[HighSymbol] \"\"\"Get high symbols used in this function (including parameters).\"\"\" sm = self . raw . getLocalSymbolMap () return [ HighSymbol ( symbol ) for symbol in sm . getSymbols ()] @property def variables ( self ): # type: () -> list[HighVariable] \"\"\"Get high variables defined in this function.\"\"\" result = [] for sym in self . symbols : var = sym . variable if var is not None : result . append ( var ) return result def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance ( other , HighFunction ): return False return self . function == other . function basicblocks property Get a list of basic blocks in this high function. function property Get the underlying function of this high function. pcode property Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally. pcode_tree property Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. symbols property Get high symbols used in this function (including parameters). variables property Get high variables defined in this function. __eq__ ( other ) Compare two high functions. Fun fact - Ghidra doesn't know how to do this. Source code in ghidralib.py 1031 1032 1033 1034 1035 1036 1037 def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance ( other , HighFunction ): return False return self . function == other . function get ( address ) staticmethod Get a HighFunction at a given address, or None if there is none. Source code in ghidralib.py 959 960 961 962 963 964 965 966 967 @staticmethod def get ( address ): # type: (JavaObject|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance ( address , GhHighFunction ): return HighFunction ( address ) func = Function . get ( address ) if func is None : return None return func . high_function get_pcode_at ( address ) Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address. Source code in ghidralib.py 974 975 976 977 978 979 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] HighSymbol Bases: GhidraWrapper Source code in ghidralib.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source ) @property def size ( self ): # type: () -> int \"\"\"Return the size of this symbol in bytes\"\"\" return self . raw . getSize () @property def data_type ( self ): # type: () -> DataType \"\"\"Return the data type of this symbol\"\"\" return DataType ( self . raw . getDataType ()) @property def variable ( self ): # type: () -> HighVariable|None \"\"\"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.\"\"\" raw = self . raw . getHighVariable () if raw is None : return None return HighVariable ( raw ) @property def name ( self ): # type: () -> str \"\"\"Return the name of this symbol\"\"\" return self . raw . getName () @property def symbol ( self ): # type: () -> Symbol|None \"\"\"Get the corresponding symbol, if it exists.\"\"\" raw = self . raw . getSymbol () if raw is None : return None return Symbol ( raw ) @property def is_this_pointer ( self ): # type: () -> bool \"\"\"Return True if this symbol is a \"this\" pointer for a class\"\"\" return self . raw . isThisPointer () data_type property Return the data type of this symbol is_this_pointer property Return True if this symbol is a \"this\" pointer for a class name property Return the name of this symbol size property Return the size of this symbol in bytes symbol property Get the corresponding symbol, if it exists. variable property Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one. rename ( new_name , source = SourceType . USER_DEFINED ) Rename this high symbol. Parameters: new_name \u2013 The new name of the symbol source \u2013 The source of the symbol Source code in ghidralib.py 579 580 581 582 583 584 585 586 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source ) HighVariable Bases: GhidraWrapper Source code in ghidralib.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self . symbol . rename ( new_name ) @property def size ( self ): # type: () -> int \"\"\"Return the size of this variable in bytes\"\"\" return self . raw . getSize () @property def data_type ( self ): # type: () -> DataType \"\"\"Return the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @property def name ( self ): # type: () -> str \"\"\"Return the name of this variable\"\"\" return self . raw . getName () @property def varnode ( self ): # type: () -> Varnode \"\"\"Return the Varnode that represents this variable\"\"\" return Varnode ( self . raw . getRepresentative ()) @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Return all Varnodes that represent this variable at some point\"\"\" return [ Varnode ( vn ) for vn in self . raw . getInstances ()] @property def is_unaffected ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are is unaffected.\"\"\" return any ( vn . is_unaffected for vn in self . varnodes ) @property def is_persistent ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are persistent.\"\"\" return any ( vn . is_persistent for vn in self . varnodes ) @property def is_addr_tied ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are addr tied.\"\"\" return any ( vn . is_addr_tied for vn in self . varnodes ) @property def is_input ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are input.\"\"\" return any ( vn . is_input for vn in self . varnodes ) @property def is_free ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are free.\"\"\" return all ( vn . is_free for vn in self . varnodes ) data_type property Return the data type of this variable is_addr_tied property Return True if ALL varnodes of this variable are addr tied. is_free property Return True if ALL varnodes of this variable are free. is_input property Return True if ALL varnodes of this variable are input. is_persistent property Return True if ALL varnodes of this variable are persistent. is_unaffected property Return True if ALL varnodes of this variable are is unaffected. name property Return the name of this variable size property Return the size of this variable in bytes symbol property varnode property Return the Varnode that represents this variable varnodes property Return all Varnodes that represent this variable at some point rename ( new_name ) Rename this high variable. Source code in ghidralib.py 523 524 525 def rename ( self , new_name ): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self . symbol . rename ( new_name ) Instruction Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Instruction object Source code in ghidralib.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 class Instruction ( GhidraWrapper , BodyTrait ): \"\"\"Wraps a Ghidra Instruction object\"\"\" @staticmethod def get ( address ): # type: (Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve ( address ): raw = getInstructionAt ( resolve ( address )) else : raw = address if raw is None : return None return Instruction ( raw ) @staticmethod def all (): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program . current () . getListing () . getInstructions ( True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def mnemonic ( self ): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction ( self . raw . getPrevious ()) prev = previous @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] \"\"\"Get a list of references from this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] @property def to ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesTo ()] def to_bytes ( self ): # type: () -> str \"\"\"Get the bytes of this instruction.\"\"\" return to_bytestring ( self . raw . getBytes ()) @property def length ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . raw . getLength () def __len__ ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . length def operand ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , Str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out @property def address ( self ): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self . raw . getAddress () . getOffset () @property def operands ( self ): # type: () -> list[int|str] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.\"\"\" return [ self . operand ( i ) for i in range ( self . raw . getNumOperands ())] @property def flow_type ( self ): # type: () -> FlowType \"\"\"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return FlowType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type = SourceType . USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) @property def body ( self ): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet . create ( self . address , self . length ) @property def fallthrough_override ( self ): # type: () -> int|None \"\"\"Get the fallthrough address override, if any. Fallthrough override is the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere.\"\"\" fall = self . raw . getFallThrough () if not fall : return None return fall . getOffset () @fallthrough_override . setter def fallthrough_override ( self , value ): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. :param value: new fallthrough address\"\"\" self . raw . setFallThrough ( resolve ( value )) @fallthrough_override . deleter def fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction.\"\"\" self . raw . clearFallThroughOverride () def clear_fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" del self . fallthrough_override def write_jumptable ( self , targets ): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [ resolve ( addr ) for addr in targets ] for dest in targets : self . add_operand_reference ( 0 , dest , RefType . COMPUTED_JUMP ) func = Function . get ( self . address ) if func is None : raise RuntimeError ( \"Instruction is not part of a function\" ) targetlist = ArrayList ( dest for dest in targets ) jumpTab = JumpTable ( toAddr ( self . address ), targetlist , True ) jumpTab . writeOverride ( func ) CreateFunctionCmd . fixupFunctionBody ( Program . current (), func . raw , monitor ) address property Get the address of this instruction. body property Get the address range this instruction. fallthrough_override deletable property writable Get the fallthrough address override, if any. Fallthrough override is the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. flow_type property Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP high_pcode property Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead. length property Get the length of this instruction in bytes. mnemonic property Get the mnemonic of this instruction. next property Get the next instruction. operands property Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. pcode property Get a list of Pcode operations that this instruction was parsed to prev = previous class-attribute instance-attribute previous property Get the previous instruction. to property Get a list of references to this instruction. xrefs_from property Get a list of references from this instruction. __len__ () Get the length of this instruction in bytes. Source code in ghidralib.py 1312 1313 1314 def __len__ ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . length add_operand_reference ( op_ndx , ref_addr , ref_type , src_type = SourceType . USER_DEFINED ) Add a reference to an operand of this instruction. Source code in ghidralib.py 1365 1366 1367 1368 1369 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type = SourceType . USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) all () staticmethod Get all instruction defined in the current program. Source code in ghidralib.py 1258 1259 1260 1261 1262 @staticmethod def all (): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program . current () . getListing () . getInstructions ( True ) return [ Instruction ( raw ) for raw in raw_instructions ] clear_fallthrough_override () This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override Source code in ghidralib.py 1402 1403 1404 1405 1406 def clear_fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" del self . fallthrough_override get ( address ) staticmethod Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func: disassemble_at instead. Parameters: address \u2013 The address of the instruction. Returns: \u2013 The instruction at the address, or None if not found. Source code in ghidralib.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 @staticmethod def get ( address ): # type: (Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve ( address ): raw = getInstructionAt ( resolve ( address )) else : raw = address if raw is None : return None return Instruction ( raw ) operand ( ndx ) Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 def operand ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) register ( ndx ) Get the nth operand of this instruction as a register name. Source code in ghidralib.py 1337 1338 1339 1340 1341 1342 def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , Str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out scalar ( ndx ) Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 1330 1331 1332 1333 1334 1335 def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out to_bytes () Get the bytes of this instruction. Source code in ghidralib.py 1303 1304 1305 def to_bytes ( self ): # type: () -> str \"\"\"Get the bytes of this instruction.\"\"\" return to_bytestring ( self . raw . getBytes ()) write_jumptable ( targets ) Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?). Source code in ghidralib.py 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 def write_jumptable ( self , targets ): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [ resolve ( addr ) for addr in targets ] for dest in targets : self . add_operand_reference ( 0 , dest , RefType . COMPUTED_JUMP ) func = Function . get ( self . address ) if func is None : raise RuntimeError ( \"Instruction is not part of a function\" ) targetlist = ArrayList ( dest for dest in targets ) jumpTab = JumpTable ( toAddr ( self . address ), targetlist , True ) jumpTab . writeOverride ( func ) CreateFunctionCmd . fixupFunctionBody ( Program . current (), func . raw , monitor ) JavaObject A fake class, used for static type hints. Source code in ghidralib.py 86 87 88 89 90 91 class JavaObject : \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass __getattribute__ ( name ) This attribute exists to make mypy happy. Source code in ghidralib.py 89 90 91 def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass Parameter Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 class Parameter ( Variable ): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal ( self ): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType ( self . raw . getFormalDataType ()) formal_data_type property Returns the formal data type of this parameter. ordinal property Returns the ordinal of this parameter. PcodeBlock Bases: GhidraWrapper Source code in ghidralib.py 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def has_children ( self ): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ] has_children property Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph. incoming_edges property outgoing_edges property pcode property PcodeOp Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ()) BOOL_AND = 39 class-attribute instance-attribute BOOL_NEGATE = 37 class-attribute instance-attribute BOOL_OR = 40 class-attribute instance-attribute BOOL_XOR = 38 class-attribute instance-attribute BRANCH = 4 class-attribute instance-attribute BRANCHIND = 6 class-attribute instance-attribute CALL = 7 class-attribute instance-attribute CALLIND = 8 class-attribute instance-attribute CALLOTHER = 9 class-attribute instance-attribute CAST = 64 class-attribute instance-attribute CBRANCH = 5 class-attribute instance-attribute COPY = 1 class-attribute instance-attribute CPOOLREF = 68 class-attribute instance-attribute EXTRACT = 71 class-attribute instance-attribute FLOAT_ABS = 52 class-attribute instance-attribute FLOAT_ADD = 47 class-attribute instance-attribute FLOAT_CEIL = 57 class-attribute instance-attribute FLOAT_DIV = 48 class-attribute instance-attribute FLOAT_EQUAL = 41 class-attribute instance-attribute FLOAT_FLOAT2FLOAT = 55 class-attribute instance-attribute FLOAT_FLOOR = 58 class-attribute instance-attribute FLOAT_INT2FLOAT = 54 class-attribute instance-attribute FLOAT_LESS = 43 class-attribute instance-attribute FLOAT_LESSEQUAL = 44 class-attribute instance-attribute FLOAT_MULT = 49 class-attribute instance-attribute FLOAT_NAN = 46 class-attribute instance-attribute FLOAT_NEG = 51 class-attribute instance-attribute FLOAT_NOTEQUAL = 42 class-attribute instance-attribute FLOAT_ROUND = 59 class-attribute instance-attribute FLOAT_SQRT = 53 class-attribute instance-attribute FLOAT_SUB = 50 class-attribute instance-attribute FLOAT_TRUNC = 56 class-attribute instance-attribute INDIRECT = 61 class-attribute instance-attribute INSERT = 70 class-attribute instance-attribute INT_2COMP = 24 class-attribute instance-attribute INT_ADD = 19 class-attribute instance-attribute INT_AND = 27 class-attribute instance-attribute INT_CARRY = 21 class-attribute instance-attribute INT_DIV = 33 class-attribute instance-attribute INT_EQUAL = 11 class-attribute instance-attribute INT_LEFT = 29 class-attribute instance-attribute INT_LESS = 15 class-attribute instance-attribute INT_LESSEQUAL = 16 class-attribute instance-attribute INT_MULT = 32 class-attribute instance-attribute INT_NEGATE = 25 class-attribute instance-attribute INT_NOTEQUAL = 12 class-attribute instance-attribute INT_OR = 28 class-attribute instance-attribute INT_REM = 35 class-attribute instance-attribute INT_RIGHT = 30 class-attribute instance-attribute INT_SBORROW = 23 class-attribute instance-attribute INT_SCARRY = 22 class-attribute instance-attribute INT_SDIV = 34 class-attribute instance-attribute INT_SEXT = 18 class-attribute instance-attribute INT_SLESS = 13 class-attribute instance-attribute INT_SLESSEQUAL = 14 class-attribute instance-attribute INT_SREM = 36 class-attribute instance-attribute INT_SRIGHT = 31 class-attribute instance-attribute INT_SUB = 20 class-attribute instance-attribute INT_XOR = 26 class-attribute instance-attribute INT_ZEXT = 17 class-attribute instance-attribute LOAD = 2 class-attribute instance-attribute LZCOUNT = 73 class-attribute instance-attribute MULTIEQUAL = 60 class-attribute instance-attribute NEW = 69 class-attribute instance-attribute PCODE_MAX = 74 class-attribute instance-attribute PIECE = 62 class-attribute instance-attribute POPCOUNT = 72 class-attribute instance-attribute PTRADD = 65 class-attribute instance-attribute PTRSUB = 66 class-attribute instance-attribute RETURN = 10 class-attribute instance-attribute SEGMENTOP = 67 class-attribute instance-attribute STORE = 3 class-attribute instance-attribute SUBPIECE = 63 class-attribute instance-attribute UNIMPLEMENTED = 0 class-attribute instance-attribute address property Get an address in the program where this instruction is located inputs property inputs_simple property Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). mnemonic property Get a string representation of the operation, for example \"COPY\" opcode property output property get_high_pcode_at ( address ) staticmethod Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 876 877 878 879 880 881 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) Program Bases: GhidraWrapper A static class that represents the current program Source code in ghidralib.py 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 class Program ( GhidraWrapper ): \"\"\"A static class that represents the current program\"\"\" @staticmethod def create_data ( address , datatype ): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType ( datatype ) try : createData ( resolve ( address ), unwrap ( typeobj )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( typeobj )) @staticmethod def location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return currentLocation . getAddress () . getOffset () @staticmethod def call_graph (): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" g = Graph . create () for func in Function . all (): g . vertex ( func , func . name ) for func in Function . all (): for out in func . called : if out . is_external : continue g . edge ( func , out ) return g @staticmethod def control_flow (): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" g = Graph . create () for block in BasicBlock . all (): g . vertex ( block , str ( block . address )) for block in BasicBlock . all (): for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g @staticmethod def basicblocks (): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock . all () @staticmethod def functions (): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function . all () @staticmethod def instructions (): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction . all () @staticmethod def body (): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program . current () . getNamespaceManager () . getGlobalNamespace () . getBody () return AddressSet ( body ) @staticmethod def current (): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram () basicblocks () staticmethod Get all the basic blocks defined in the program. Source code in ghidralib.py 3062 3063 3064 3065 @staticmethod def basicblocks (): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock . all () body () staticmethod Get the set of all addresses of the program. Source code in ghidralib.py 3077 3078 3079 3080 3081 @staticmethod def body (): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program . current () . getNamespaceManager () . getGlobalNamespace () . getBody () return AddressSet ( body ) call_graph () staticmethod Get the call graph for this program. Source code in ghidralib.py 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 @staticmethod def call_graph (): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" g = Graph . create () for func in Function . all (): g . vertex ( func , func . name ) for func in Function . all (): for out in func . called : if out . is_external : continue g . edge ( func , out ) return g control_flow () staticmethod Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it. Source code in ghidralib.py 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 @staticmethod def control_flow (): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" g = Graph . create () for block in BasicBlock . all (): g . vertex ( block , str ( block . address )) for block in BasicBlock . all (): for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g create_data ( address , datatype ) staticmethod Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 @staticmethod def create_data ( address , datatype ): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType ( datatype ) try : createData ( resolve ( address ), unwrap ( typeobj )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( typeobj )) current () staticmethod Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool). Source code in ghidralib.py 3083 3084 3085 3086 3087 3088 3089 3090 @staticmethod def current (): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram () functions () staticmethod Get all the functions defined in the program. Source code in ghidralib.py 3067 3068 3069 3070 @staticmethod def functions (): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function . all () instructions () staticmethod Get all the instructions defined in the program. Source code in ghidralib.py 3072 3073 3074 3075 @staticmethod def instructions (): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction . all () location () staticmethod Get the current location in the program. >>> current_location() 0x1000 Returns: \u2013 the current location in the program Source code in ghidralib.py 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 @staticmethod def location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return currentLocation . getAddress () . getOffset () RefType Bases: GhidraWrapper Source code in ghidralib.py 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () class-attribute instance-attribute CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () class-attribute instance-attribute CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute FALL_THROUGH = _reftype_placeholder () class-attribute instance-attribute FLOW = _reftype_placeholder () class-attribute instance-attribute INDIRECTION = _reftype_placeholder () class-attribute instance-attribute INVALID = _reftype_placeholder () class-attribute instance-attribute JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute JUMP_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute TERMINATOR = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute has_fall property writable is_call property writable is_computed property writable is_conditional property writable is_data property is_flow property is_jump property writable is_override property is_read property is_terminal property is_unconditional property is_write property Reference Bases: GhidraWrapper Source code in ghidralib.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self . raw . getToAddress () . getOffset () @property def source ( self ): # type: () -> SourceType return SourceType ( self . raw . getSource ()) from_address property Return the address of the source of the reference. is_call property Return True if the reference is a call. is_jump property Return True if the reference is a jump. reftype property Return the type of reference. source property to_address property Return the address of the target of the reference. Register Bases: GhidraWrapper Source code in ghidralib.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 class Register ( GhidraWrapper ): @staticmethod def get ( raw_or_name ): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance ( raw_or_name , Str ): raw_or_name = Program . current () . getLanguage () . getRegister ( raw_or_name ) if raw_or_name is None : return None return Register ( raw_or_name ) @property def name ( self ): \"\"\"Return the name of this register\"\"\" return self . raw . getName () name property Return the name of this register get ( raw_or_name ) staticmethod Get a register by name Source code in ghidralib.py 629 630 631 632 633 634 635 636 @staticmethod def get ( raw_or_name ): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance ( raw_or_name , Str ): raw_or_name = Program . current () . getLanguage () . getRegister ( raw_or_name ) if raw_or_name is None : return None return Register ( raw_or_name ) Symbol Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 class Symbol ( GhidraWrapper ): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = Program . current () . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = ( Program . current () . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) ) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program . current () . getSymbolTable () . getAllSymbols ( True ) symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) @staticmethod def remove ( address , name ): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol ( resolve ( address ), name ) @property def address ( self ): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferences ()] xrefs_to = xrefs @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program . create_data ( self . address , datatype ) def delete ( self ): # type: () -> None \"\"\"Delete this symbol.\"\"\" self . raw . delete () def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source ) address property Get the address of this symbol. name property Get the name of this symbol. name_with_namespace property Get the fully qualified name of this symbol. xref_addrs property Get the addresses of all references to this symbol. xrefs property Get a list of references to this symbol. xrefs_to = xrefs class-attribute instance-attribute all () staticmethod Get all symbols defined in the program. Source code in ghidralib.py 2421 2422 2423 2424 2425 2426 @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program . current () . getSymbolTable () . getAllSymbols ( True ) symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] create ( address , name , source = SourceType . USER_DEFINED ) staticmethod Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) delete () Delete this symbol. Source code in ghidralib.py 2479 2480 2481 def delete ( self ): # type: () -> None \"\"\"Delete this symbol.\"\"\" self . raw . delete () get ( raw_or_name ) staticmethod Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = Program . current () . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = ( Program . current () . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) ) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) remove ( address , name ) staticmethod Remove the symbol with the given name at the given address. Parameters: address \u2013 the address of the symbol to remove. name \u2013 the name of the symbol to remove. Source code in ghidralib.py 2440 2441 2442 2443 2444 2445 2446 @staticmethod def remove ( address , name ): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol ( resolve ( address ), name ) rename ( new_name , source = SourceType . USER_DEFINED ) Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source ) set_type ( datatype ) Set the data type of this symbol. Source code in ghidralib.py 2475 2476 2477 def set_type ( self , datatype ): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program . create_data ( self . address , datatype ) Variable Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 class Variable ( GhidraWrapper ): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name ( self ): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self . raw . getName () @name . setter def name ( self , name ): # type: (str) -> None \"\"\"Rename this variable\"\"\" self . rename ( name , SourceType . USER_DEFINED ) def rename ( self , name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self . raw . setName ( name , source ) @property def data_type ( self ): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @data_type . setter def data_type ( self , data_type , source = SourceType . USER_DEFINED ): # type: (DataType, SourceType) -> None \"\"\"Set the data type of this variable\"\"\" self . raw . setDataType ( data_type . raw , source ) @property def is_valid ( self ): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self . raw . isValid () @property def comment ( self ): # type: () -> str|None \"\"\" \"Get the comment for this variable\"\"\" return self . raw . getComment () @comment . setter def comment ( self , name ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . set_comment ( name ) def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) @property def is_auto ( self ): # type: () -> bool \"\"\"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.\"\"\" return self . raw . getVariableStorage () . isAutoStorage () @property def is_forced_indirect ( self ): # type: () -> bool \"\"\"Check if this variable was forced to be a pointer by calling convention\"\"\" return self . raw . getVariableStorage () . isForcedIndirect () @property def has_bad_storage ( self ): # type: () -> bool \"\"\"Check if this variable has bad storage (could not be resolved)\"\"\" return self . raw . getVariableStorage () . isBadStorage () @property def is_unassigned_storage ( self ): # type: () -> bool \"\"\"Check if this variable has no assigned storage (varnodes)\"\"\" return self . raw . getVariableStorage () . isUnassignedStorage () @property def is_void ( self ): # type: () -> bool \"\"\"Check if this variable is of type void\"\"\" return self . raw . getVariableStorage () . isVoidStorage () @property def stack_offfset ( self ): # type: () -> int \"\"\"Get the stack offset of this variable.\"\"\" return self . raw . getVariableStorage () . getStackOffset () @property def is_constant ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single constant-space varnode\"\"\" return self . raw . getVariableStorage () . isConstantStorage () @property def is_hash ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single hash-space varnode.\"\"\" return self . raw . getVariableStorage () . isHashStorage () @property def is_stack ( self ): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol \"\"\"Get the symbol for this variable\"\"\" return Symbol ( self . raw . getSymbol ()) @property def source ( self ): # type: () -> SourceType \"\"\"Get the source type of this variable\"\"\" return SourceType ( self . raw . getSource ()) @property def varnode ( self ): # type: () -> Varnode \"\"\"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.\"\"\" return Varnode ( self . raw . getFirstStorageVarnode ()) @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with this variable.\"\"\" storage = self . raw . getVariableStorage () return [ Varnode ( x ) for x in storage . getVarnodes ()] @property def is_register ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single register.\"\"\" return self . raw . isRegisterVariable () @property def register ( self ): # type: () -> str \"\"\"Get the register associated with this variable. Raises an exception if this variable is not a register variable.\"\"\" reg = self . raw . getRegister () if not reg : raise ValueError ( \"Variable is not a register variable\" ) return reg . getName () @property def function ( self ): # type: () -> Function \"\"\"Get the function associated with this variable.\"\"\" return Function ( self . raw . getFunction ()) comment property writable \"Get the comment for this variable data_type property writable Get the data type of this variable function property Get the function associated with this variable. has_bad_storage property Check if this variable has bad storage (could not be resolved) is_auto property Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters. is_compound property Check if this variable is a compound variable is_constant property Check if this variable consists of a single constant-space varnode is_forced_indirect property Check if this variable was forced to be a pointer by calling convention is_hash property Check if this variable consists of a single hash-space varnode. is_memory property Check if this variable is stored in memory is_register property Check if this variable consists of a single register. is_stack property Check if this variable is a stack variable is_unassigned_storage property Check if this variable has no assigned storage (varnodes) is_unique property Check if this variable is of type unique is_valid property Check if this variable is valid is_void property Check if this variable is of type void name property writable Get the name of this variable register property Get the register associated with this variable. Raises an exception if this variable is not a register variable. source property Get the source type of this variable stack_offfset property Get the stack offset of this variable. symbol property Get the symbol for this variable varnode property Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable. varnodes property Get all varnodes associated with this variable. rename ( name , source = SourceType . USER_DEFINED ) Rename this variable Source code in ghidralib.py 1690 1691 1692 1693 1694 def rename ( self , name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self . raw . setName ( name , source ) set_comment ( comment ) Set the comment for this variable Source code in ghidralib.py 1723 1724 1725 def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) Varnode Bases: GhidraWrapper Source code in ghidralib.py 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool \"\"\"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.\"\"\" return self . raw . isRegister () @property def is_named_register ( self ): # type: () -> bool \"\"\" \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.\"\"\" language = Program . current () . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return raw is not None @property def as_register ( self ): # type: () -> str \"\"\"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.\"\"\" language = Program . current () . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return raw . getName () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () @property def is_stack ( self ): # type: () -> bool spaceid = self . raw . getSpace () spacetype = AddressSpace . ID_TYPE_MASK & spaceid return spacetype == AddressSpace . TYPE_STACK def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" ) @property def is_unaffected ( self ): # type: () -> bool return self . raw . isUnaffected () @property def is_persistent ( self ): # type: () -> bool return self . raw . isPersistent () @property def is_addr_tied ( self ): # type: () -> bool return self . raw . isAddrTied () @property def is_input ( self ): # type: () -> bool return self . raw . isInput () @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def defining_pcodeop ( self ): # type: () -> PcodeOp \"\"\"Return a PcodeOp that defined this varnode\"\"\" return PcodeOp ( self . raw . getDef ()) @property def descendants ( self ): # type: () -> list[PcodeOp] \"\"\"Return a list of all descendants of this varnode\"\"\" if self . raw . getDescendants () is None : return [] return [ PcodeOp ( x ) for x in self . raw . getDescendants ()] as_register property Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure. defining_pcodeop property Return a PcodeOp that defined this varnode descendants property Return a list of all descendants of this varnode free property has_value property high property is_addr_tied property is_address property is_constant property Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value. is_free property is_hash property is_input property is_named_register property \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name. is_persistent property is_register property Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead. is_stack property is_unaffected property is_unique property offset property simple property Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position. size property symbol property value property Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value. rename ( new_name ) Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 727 728 729 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) assemble_at ( address , instructions ) Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Parameters: address \u2013 the address where to write the instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 def assemble_at ( address , instructions ): # type: (Addr, str|list[str]) -> None \"\"\"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". :param address: the address where to write the instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. address = resolve ( address ) asm = Assemblers . getAssembler ( Program . current ()) asm . assemble ( address , instructions ) assemble_to_bytes ( address , instructions ) Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is required, because instruction bytes may depend on the location. Parameters: address \u2013 the address to use as a base for instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 def assemble_to_bytes ( address , instructions ): # type: (Addr, str|list[str]) -> str \"\"\"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is required, because instruction bytes may depend on the location. :param address: the address to use as a base for instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr_obj = resolve ( address ) asm = Assemblers . getAssembler ( Program . current ()) if isinstance ( instructions , Str ): return to_bytestring ( asm . assembleLine ( addr_obj , instructions )) result = \"\" for instr in instructions : result += to_bytestring ( asm . assembleLine ( addr_obj . add ( len ( result )), instr )) return result can_resolve ( addr ) Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py 247 248 249 250 251 252 def can_resolve ( addr ): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance ( addr , ( GenericAddress , int , long , unicode , str )) collect_iterator ( iterator ) Collect a Java iterator to a Python list. Source code in ghidralib.py 262 263 264 265 266 267 def collect_iterator ( iterator ): \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result disassemble_at ( address , max_bytes = None , max_instr = None ) Disassemble the bytes from the program memory at the given address. If neither max_bytes nor max_instr are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. Parameters: address \u2013 the address where to start disassembling max_bytes \u2013 maximum number of bytes to disassemble (None for no limit) max_instr \u2013 maximum number of instructions to disassemble (None for no limit) Returns: \u2013 a list of Instruction objects Source code in ghidralib.py 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 def disassemble_at ( address , max_bytes = None , max_instr = None ): # type: (Addr, int|None, int|None) -> list[Instruction] \"\"\"Disassemble the bytes from the program memory at the given address. If neither `max_bytes` nor `max_instr` are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. :param address: the address where to start disassembling :param max_bytes: maximum number of bytes to disassemble (None for no limit) :param max_instr: maximum number of instructions to disassemble (None for no limit) :return: a list of Instruction objects\"\"\" address = resolve ( address ) if max_instr is None : _max_instr = 1 if max_bytes is None else max_bytes else : _max_instr = max_instr if max_bytes is None : to_block_end = _get_memory_block ( address ) . getEnd () . subtract ( address ) # Hacky and inefficient, but good enough for now (and correct) _max_bytes = min ( to_block_end , _max_instr * 16 ) else : _max_bytes = max_bytes data = read_bytes ( address , _max_bytes ) return disassemble_bytes ( data , address , _max_instr ) disassemble_bytes ( data , addr = 0 , max_instr = None ) Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. Parameters: data \u2013 the bytes to disassemble addr \u2013 the (virtual) address of the first instruction max_instr \u2013 the maximum number of instructions to disassemble, or to disassemble until the end of the data Returns: \u2013 a list of Instruction objects Source code in ghidralib.py 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 def disassemble_bytes ( data , addr = 0 , max_instr = None ): # type: (str, Addr, int|None) -> list[Instruction] \"\"\"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. :param data: the bytes to disassemble :param addr: the (virtual) address of the first instruction :param max_instr: the maximum number of instructions to disassemble, or to disassemble until the end of the data :return: a list of Instruction objects\"\"\" dis = PseudoDisassembler ( Program . current ()) offset = 0 result = [] address = resolve ( addr ) if max_instr is None : max_instr = 100000000 for _ in range ( 0 , max_instr ): try : arr = data [ offset : offset + 16 ] rawinstr = dis . disassemble ( address . add ( offset ), arr ) instr = Instruction ( rawinstr ) if offset + instr . length > len ( data ): # Don't append the instruction if it would go past the end of the data break result . append ( instr ) offset += instr . length if offset + instr . length > len ( data ): # Check if we're done break except : break return result enhex ( s ) Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 def enhex ( s ): # type: (str | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if not isinstance ( s , Str ): s = \"\" . join ( chr ( c ) for c in s ) return s . encode ( \"hex\" ) # type: ignore <- py2 from_bytes ( b ) Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py 3324 3325 3326 3327 3328 3329 3330 3331 3332 def from_bytes ( b ): # type: (str | list[int]) -> int \"\"\"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 :param b: byte stream to decode.\"\"\" b = to_bytestring ( b ) return sum ( ord ( v ) << ( i * 8 ) for i , v in enumerate ( b )) get_string ( address ) Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 def get_string ( address ): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None get_unique_string ( obj ) Get a unique string for a given object. This function is used to convert objects to strings for the graph. The only requirement is that the returned string is unique for each object. Function will just return str(obj) for primitives, and for the rest it will try to return str(obj.address). Parameters: obj \u2013 the object to convert. Source code in ghidralib.py 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 def get_unique_string ( obj ): # type: (object) -> str \"\"\"Get a unique string for a given object. This function is used to convert objects to strings for the graph. The only requirement is that the returned string is unique for each object. Function will just return str(obj) for primitives, and for the rest it will try to return str(obj.address). :param obj: the object to convert.\"\"\" if isinstance ( obj , Str ): return obj elif isinstance ( obj , ( int , long )): return str ( obj ) elif hasattr ( obj , \"address\" ): # So you can define your own way to convert an object to a string. return str ( obj . address ) # type: ignore else : raise TypeError ( \"Cannot convert object {} to string\" . format ( obj )) read_bytes ( address , length ) Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 def read_bytes ( address , length ): # type: (Addr, int) -> str \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length )) read_cstring ( address ) Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 def read_cstring ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string read_u16 ( address ) Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3282 3283 3284 3285 3286 3287 3288 3289 def read_u16 ( address ): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 2 )) read_u32 ( address ) Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3292 3293 3294 3295 3296 3297 3298 3299 def read_u32 ( address ): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 4 )) read_u64 ( address ) Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3302 3303 3304 3305 3306 3307 3308 3309 def read_u64 ( address ): # type: (Addr) -> int \"\"\"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 8 )) read_u8 ( address ) Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3272 3273 3274 3275 3276 3277 3278 3279 def read_u8 ( address ): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 1 )) read_unicode ( address ) Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 def read_unicode ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string resolve ( addr ) Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def resolve ( addr ): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance ( addr , unicode ): # Why, Ghidra? addr = addr . encode () if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) raise TypeError ( \"Address must be a ghidra Address, int, or str\" ) resolve_to_int ( addr ) Convert an addressable value to an integer representation. Source code in ghidralib.py 242 243 244 def resolve_to_int ( addr ): # type: (Addr) -> int \"\"\"Convert an addressable value to an integer representation.\"\"\" return resolve ( addr ) . getOffset () to_bytes ( value , length ) Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\x01\\x02' Parameters: value \u2013 integer to encode. length \u2013 number of bytes of the result. Source code in ghidralib.py 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 def to_bytes ( value , length ): # type: (int, int) -> str \"\"\"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\\\x01\\\\x02' :param value: integer to encode. :param length: number of bytes of the result.\"\"\" out = \"\" for i in range ( length ): out += chr ( value & 0xFF ) value >>= 8 return out to_bytestring ( val ) Ensure the passed value is a bytestring. This is used to convert java byte arrays to a proper python bytestring. Source code in ghidralib.py 3093 3094 3095 3096 3097 3098 3099 def to_bytestring ( val ): # type: (str | list[int]) -> str \"\"\"Ensure the passed value is a bytestring. This is used to convert java byte arrays to a proper python bytestring.\"\"\" if not isinstance ( val , Str ): return \"\" . join ( chr ( i % 256 ) for i in val ) return val try_resolve ( addr ) Convert an arbitrary addressable value to a Ghidra Address object. See resolve documentation for more details. Source code in ghidralib.py 232 233 234 235 236 237 238 239 def try_resolve ( addr ): # type: (Addr) -> GenericAddress | None \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. See `resolve` documentation for more details.\"\"\" try : return resolve ( addr ) except : return None unhex ( s ) Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py 3350 3351 3352 3353 3354 3355 3356 3357 def unhex ( s ): # type: (str) -> str \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return s . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) . decode ( \"hex\" ) # type: ignore <- py2 unwrap ( wrapper_or_java_type ) If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py 255 256 257 258 259 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type xor ( a , b ) XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 def xor ( a , b ): # type: (str, str) -> str \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\\\x01\\\\x02\", \"\\\\x03\\\\x04\") '\\\\x02\\\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"API reference"},{"location":"reference/#api-reference","text":"","title":"API reference"},{"location":"reference/#ghidralib","text":"This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/.","title":"ghidralib"},{"location":"reference/#ghidralib.Addr","text":"","title":"Addr"},{"location":"reference/#ghidralib.DataT","text":"","title":"DataT"},{"location":"reference/#ghidralib.HIGHLIGHT_COLOR","text":"","title":"HIGHLIGHT_COLOR"},{"location":"reference/#ghidralib.Reg","text":"","title":"Reg"},{"location":"reference/#ghidralib.Str","text":"","title":"Str"},{"location":"reference/#ghidralib.T","text":"","title":"T"},{"location":"reference/#ghidralib.long","text":"","title":"long"},{"location":"reference/#ghidralib.unicode","text":"","title":"unicode"},{"location":"reference/#ghidralib.AddressRange","text":"Bases: GhidraWrapper Wraps a Ghidra AddressRange object. Source code in ghidralib.py 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 class AddressRange ( GhidraWrapper ): \"\"\"Wraps a Ghidra AddressRange object.\"\"\" @property def addresses ( self ): # type: () -> list[int] \"\"\"Return the addresses in this range.\"\"\" return [ a . getOffset () for a in self . raw . getAddresses ( True )] def __iter__ ( self ): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self . addresses . __iter__ () @property def start ( self ): # type: () -> int \"\"\"Get the first address in this range.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end ( self ): # type: () -> int \"\"\"Get the last address in this range.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def length ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . raw . getLength () def __len__ ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . length def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . raw . contains ( resolve ( addr )) def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . contains ( addr ) @property def is_empty ( self ): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self . raw . isEmpty () def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty def __and__ ( self , other ): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange ( self . raw . intersect ( other . raw ))","title":"AddressRange"},{"location":"reference/#ghidralib.AddressRange.addresses","text":"Return the addresses in this range.","title":"addresses"},{"location":"reference/#ghidralib.AddressRange.end","text":"Get the last address in this range.","title":"end"},{"location":"reference/#ghidralib.AddressRange.is_empty","text":"Return True if this range is empty.","title":"is_empty"},{"location":"reference/#ghidralib.AddressRange.length","text":"Get the length of this range.","title":"length"},{"location":"reference/#ghidralib.AddressRange.start","text":"Get the first address in this range.","title":"start"},{"location":"reference/#ghidralib.AddressRange.__and__","text":"Return the intersection of this range and the given range. Source code in ghidralib.py 1485 1486 1487 def __and__ ( self , other ): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange ( self . raw . intersect ( other . raw ))","title":"__and__"},{"location":"reference/#ghidralib.AddressRange.__contains__","text":"Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py 1471 1472 1473 1474 def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . contains ( addr )","title":"__contains__"},{"location":"reference/#ghidralib.AddressRange.__iter__","text":"Iterate over the addresses in this range. Source code in ghidralib.py 1442 1443 1444 def __iter__ ( self ): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self . addresses . __iter__ ()","title":"__iter__"},{"location":"reference/#ghidralib.AddressRange.__len__","text":"Get the length of this range. Source code in ghidralib.py 1461 1462 1463 def __len__ ( self ): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self . length","title":"__len__"},{"location":"reference/#ghidralib.AddressRange.__nonzero__","text":"Return True if this range is not empty. Source code in ghidralib.py 1481 1482 1483 def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty","title":"__nonzero__"},{"location":"reference/#ghidralib.AddressRange.contains","text":"Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py 1465 1466 1467 1468 1469 def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self . raw . contains ( resolve ( addr ))","title":"contains"},{"location":"reference/#ghidralib.AddressSet","text":"Bases: GhidraWrapper Wraps a Ghidra AddressSetView object. Source code in ghidralib.py 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 class AddressSet ( GhidraWrapper ): \"\"\"Wraps a Ghidra AddressSetView object.\"\"\" @staticmethod def empty (): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet ( GhAddressSet ()) @staticmethod def create ( start , length ): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve ( start ) return AddressSet ( GhAddressSet ( addr , addr . add ( length - 1 ))) @property def addresses ( self ): # type: () -> list[int] \"\"\"Return the addresses in this set.\"\"\" return [ a . getOffset () for a in self . raw . getAddresses ( True )] @property def ranges ( self ): # type: () -> list[AddressRange] return [ AddressRange ( r ) for r in self . raw . iterator ( True )] def __iter__ ( self ): # type: () -> Iterator[int] return self . addresses . __iter__ () def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . raw . contains ( resolve ( addr )) def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . contains ( addr ) @property def is_empty ( self ): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self . raw . isEmpty () def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty def __and__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet ( self . raw . intersect ( other . raw )) def __sub__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet ( self . raw . subtract ( other . raw )) def __xor__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet ( self . raw . xor ( other . raw )) def __or__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet ( self . raw . union ( other . raw )) def __get_highlighter ( self ): # type: () -> Any tool = state . getTool () service = tool . getService ( ColorizingService ) if service is None : raise RuntimeError ( \"Cannot highlight without the ColorizingService\" ) return service def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None service = self . __get_highlighter () service . setBackgroundColor ( self . raw , color ) def unhighlight ( self ): # type: (Color) -> None service = self . __get_highlighter () service . clearBackgroundColor ( self . raw )","title":"AddressSet"},{"location":"reference/#ghidralib.AddressSet.addresses","text":"Return the addresses in this set.","title":"addresses"},{"location":"reference/#ghidralib.AddressSet.is_empty","text":"Return True if this range is empty.","title":"is_empty"},{"location":"reference/#ghidralib.AddressSet.ranges","text":"","title":"ranges"},{"location":"reference/#ghidralib.AddressSet.__and__","text":"Return the intersection of this set and the given set. Source code in ghidralib.py 1533 1534 1535 def __and__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet ( self . raw . intersect ( other . raw ))","title":"__and__"},{"location":"reference/#ghidralib.AddressSet.__contains__","text":"Return True if the given address is in this range. Source code in ghidralib.py 1520 1521 1522 def __contains__ ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . contains ( addr )","title":"__contains__"},{"location":"reference/#ghidralib.AddressSet.__get_highlighter","text":"Source code in ghidralib.py 1549 1550 1551 1552 1553 1554 def __get_highlighter ( self ): # type: () -> Any tool = state . getTool () service = tool . getService ( ColorizingService ) if service is None : raise RuntimeError ( \"Cannot highlight without the ColorizingService\" ) return service","title":"__get_highlighter"},{"location":"reference/#ghidralib.AddressSet.__iter__","text":"Source code in ghidralib.py 1513 1514 def __iter__ ( self ): # type: () -> Iterator[int] return self . addresses . __iter__ ()","title":"__iter__"},{"location":"reference/#ghidralib.AddressSet.__nonzero__","text":"Return True if this range is not empty. Source code in ghidralib.py 1529 1530 1531 def __nonzero__ ( self ): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self . is_empty","title":"__nonzero__"},{"location":"reference/#ghidralib.AddressSet.__or__","text":"Computes the union of this set and the given set. Source code in ghidralib.py 1545 1546 1547 def __or__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet ( self . raw . union ( other . raw ))","title":"__or__"},{"location":"reference/#ghidralib.AddressSet.__sub__","text":"Subtract the given set from this set. Source code in ghidralib.py 1537 1538 1539 def __sub__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet ( self . raw . subtract ( other . raw ))","title":"__sub__"},{"location":"reference/#ghidralib.AddressSet.__xor__","text":"Computes the symmetric difference of this set and the given set. Source code in ghidralib.py 1541 1542 1543 def __xor__ ( self , other ): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet ( self . raw . xor ( other . raw ))","title":"__xor__"},{"location":"reference/#ghidralib.AddressSet.contains","text":"Return True if the given address is in this range. Source code in ghidralib.py 1516 1517 1518 def contains ( self , addr ): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self . raw . contains ( resolve ( addr ))","title":"contains"},{"location":"reference/#ghidralib.AddressSet.create","text":"Create a new AddressSet with given address and length. Source code in ghidralib.py 1498 1499 1500 1501 1502 @staticmethod def create ( start , length ): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve ( start ) return AddressSet ( GhAddressSet ( addr , addr . add ( length - 1 )))","title":"create"},{"location":"reference/#ghidralib.AddressSet.empty","text":"Create a new empty address set Source code in ghidralib.py 1493 1494 1495 1496 @staticmethod def empty (): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet ( GhAddressSet ())","title":"empty"},{"location":"reference/#ghidralib.AddressSet.highlight","text":"Source code in ghidralib.py 1556 1557 1558 def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None service = self . __get_highlighter () service . setBackgroundColor ( self . raw , color )","title":"highlight"},{"location":"reference/#ghidralib.AddressSet.unhighlight","text":"Source code in ghidralib.py 1560 1561 1562 def unhighlight ( self ): # type: (Color) -> None service = self . __get_highlighter () service . clearBackgroundColor ( self . raw )","title":"unhighlight"},{"location":"reference/#ghidralib.BasicBlock","text":"Bases: AddressSet , BodyTrait Wraps a Ghidra CodeBlock object Source code in ghidralib.py 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 class BasicBlock ( AddressSet , BodyTrait ): \"\"\"Wraps a Ghidra CodeBlock object\"\"\" @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock|None \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if raw_or_address is None : return None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( Program . current ()) addr = try_resolve ( raw_or_address ) if addr is None : return None raw = block_model . getFirstCodeBlockContaining ( addr , TaskMonitor . DUMMY ) if raw is None : return None else : raw = raw_or_address return BasicBlock ( raw ) @staticmethod def all (): # type: () -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = SimpleBlockModel ( Program . current ()) return [ BasicBlock ( b ) for b in block_model . getCodeBlocks ( TaskMonitor . DUMMY )] @property def name ( self ): # type: () -> str \"\"\"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.\"\"\" return self . raw . getName () @property def address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . start_address @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ] @property def body ( self ): # type: () -> AddressSet \"\"\"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.\"\"\" return AddressSet ( self . raw ) @property def flow_type ( self ): # type: () -> FlowType \"\"\"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.\"\"\" return FlowType ( self . raw . getFlowType ()) def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance ( other , BasicBlock ): return False # This is not fully correct, but more correct than the default. return self . address == other . address","title":"BasicBlock"},{"location":"reference/#ghidralib.BasicBlock.address","text":"Get the address of the first instruction in this basic block.","title":"address"},{"location":"reference/#ghidralib.BasicBlock.body","text":"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.","title":"body"},{"location":"reference/#ghidralib.BasicBlock.destinations","text":"Get a list of basic blocks that this basic block jumps to","title":"destinations"},{"location":"reference/#ghidralib.BasicBlock.end_address","text":"Get the address of the last instruction in this basic block.","title":"end_address"},{"location":"reference/#ghidralib.BasicBlock.flow_type","text":"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.","title":"flow_type"},{"location":"reference/#ghidralib.BasicBlock.instructions","text":"Get a list of instructions in this basic block.","title":"instructions"},{"location":"reference/#ghidralib.BasicBlock.name","text":"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.","title":"name"},{"location":"reference/#ghidralib.BasicBlock.pcode","text":"Get a list of Pcode operations that this basic block was parsed to","title":"pcode"},{"location":"reference/#ghidralib.BasicBlock.sources","text":"Get a list of basic blocks that jump to this basic block","title":"sources"},{"location":"reference/#ghidralib.BasicBlock.start_address","text":"Get the address of the first instruction in this basic block.","title":"start_address"},{"location":"reference/#ghidralib.BasicBlock.__eq__","text":"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this Source code in ghidralib.py 1667 1668 1669 1670 1671 1672 1673 1674 def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance ( other , BasicBlock ): return False # This is not fully correct, but more correct than the default. return self . address == other . address","title":"__eq__"},{"location":"reference/#ghidralib.BasicBlock.all","text":"Get a list of all basic blocks in the program. Source code in ghidralib.py 1592 1593 1594 1595 1596 @staticmethod def all (): # type: () -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = SimpleBlockModel ( Program . current ()) return [ BasicBlock ( b ) for b in block_model . getCodeBlocks ( TaskMonitor . DUMMY )]","title":"all"},{"location":"reference/#ghidralib.BasicBlock.get","text":"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock|None \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if raw_or_address is None : return None if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( Program . current ()) addr = try_resolve ( raw_or_address ) if addr is None : return None raw = block_model . getFirstCodeBlockContaining ( addr , TaskMonitor . DUMMY ) if raw is None : return None else : raw = raw_or_address return BasicBlock ( raw )","title":"get"},{"location":"reference/#ghidralib.BlockGraph","text":"Bases: PcodeBlock Source code in ghidralib.py 952 953 954 955 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())]","title":"BlockGraph"},{"location":"reference/#ghidralib.BlockGraph.blocks","text":"","title":"blocks"},{"location":"reference/#ghidralib.BodyTrait","text":"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting. Source code in ghidralib.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 class BodyTrait : \"\"\"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting.\"\"\" @property @abstractmethod def body ( self ): # type: () -> AddressSet \"\"\"The body of this object\"\"\" def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self . body . highlight ( color ) def unhighlight ( self ): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self . body . unhighlight ()","title":"BodyTrait"},{"location":"reference/#ghidralib.BodyTrait.body","text":"The body of this object","title":"body"},{"location":"reference/#ghidralib.BodyTrait.highlight","text":"Highlight this instruction in the listing. Source code in ghidralib.py 509 510 511 def highlight ( self , color = HIGHLIGHT_COLOR ): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self . body . highlight ( color )","title":"highlight"},{"location":"reference/#ghidralib.BodyTrait.unhighlight","text":"Clear the highlight from this instruction. Source code in ghidralib.py 513 514 515 def unhighlight ( self ): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self . body . unhighlight ()","title":"unhighlight"},{"location":"reference/#ghidralib.ClangTokenGroup","text":"Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 class ClangTokenGroup ( GhidraWrapper ): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup ( self , token ): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup ( token . Parent ()) for token in list ( token . iterator ()): if isinstance ( token , ( ClangCommentToken , ClangBreak )): continue if isinstance ( token , ClangSyntaxToken ): if not token . getText () or token . getText () . isspace (): continue if isinstance ( token , GhClangTokenGroup ): token = self . _cleanup ( token ) new . AddTokenGroup ( token ) return new @property def cleaned ( self ): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup ( self . _cleanup ( self . raw )) def _dump ( self , token , indent = 0 ): # type: (JavaObject, int) -> None if isinstance ( token , GhClangTokenGroup ): print ( \" {} [group]\" . format ( indent * \" \" , token . __class__ . __name__ )) for child in token . iterator (): self . _dump ( child , indent + 1 ) else : print ( \" {}{} ( {} )\" . format ( indent * \" \" , token , token . __class__ . __name__ )) def dump ( self ): # type: () -> None self . _dump ( self . raw )","title":"ClangTokenGroup"},{"location":"reference/#ghidralib.ClangTokenGroup.cleaned","text":"Remove all whitespace and comments from this token group, recursively.","title":"cleaned"},{"location":"reference/#ghidralib.ClangTokenGroup.dump","text":"Source code in ghidralib.py 1992 1993 def dump ( self ): # type: () -> None self . _dump ( self . raw )","title":"dump"},{"location":"reference/#ghidralib.DataType","text":"Bases: GhidraWrapper Source code in ghidralib.py 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 class DataType ( GhidraWrapper ): @staticmethod def get ( name_or_raw ): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance ( name_or_raw , Str ): return DataType ( name_or_raw ) for datatype in DataType . all (): if datatype . name == name_or_raw : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( Program . current () . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' . \"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) def length ( self ): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self . raw . getLength () __len__ = length @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program . current () . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"DataType"},{"location":"reference/#ghidralib.DataType.__len__","text":"","title":"__len__"},{"location":"reference/#ghidralib.DataType.name","text":"Get a name of this data type >>> DataType('int').name 'int' .","title":"name"},{"location":"reference/#ghidralib.DataType.all","text":"Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( Program . current () . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes","title":"all"},{"location":"reference/#ghidralib.DataType.from_c","text":"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program . current () . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"from_c"},{"location":"reference/#ghidralib.DataType.get","text":"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name_or_raw \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 @staticmethod def get ( name_or_raw ): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance ( name_or_raw , Str ): return DataType ( name_or_raw ) for datatype in DataType . all (): if datatype . name == name_or_raw : return DataType ( datatype ) return None","title":"get"},{"location":"reference/#ghidralib.DataType.get_name","text":"If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py 2545 2546 2547 2548 2549 def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value )","title":"get_name"},{"location":"reference/#ghidralib.DataType.length","text":"Get the length of this data type in bytes >>> DataType('int').length() 4 . Source code in ghidralib.py 2551 2552 2553 2554 2555 2556 2557 2558 def length ( self ): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self . raw . getLength ()","title":"length"},{"location":"reference/#ghidralib.Emulator","text":"Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 class Emulator ( GhidraWrapper ): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( Program . current ()) GhidraWrapper . __init__ ( self , raw ) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr ( 0 ) . getAddressSpace () . getMaxAddress () . getOffset () stack_off = ( max_pointer >> 1 ) - 0x8000 self . raw . writeRegister ( self . raw . getStackPointerRegister (), stack_off ) # TODO: add a simple allocation manager @property def pc ( self ): # type: () -> int \"\"\"Get the program counter of the emulated program.\"\"\" return self . raw . getExecutionAddress () . getOffset () def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , resolve ( address ) . getOffset ()) def __getitem__ ( self , reg ): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self . read_register ( reg ) def __setitem__ ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self . write_register ( reg , value ) def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) def read_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( resolve ( address ), length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_u8 ( self , address ): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 1 )) def read_u16 ( self , address ): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 2 )) def read_u32 ( self , address ): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 4 )) def read_u64 ( self , address ): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 8 )) def read_cstring ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string def read_unicode ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . read_bytes ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . read_bytes ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_stack : return self . raw . readStackValue ( varnode . offset , varnode . size , False ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . read_register ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) def write_bytes ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( resolve ( address ), value ) def write_u8 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 8 , \"value out of range\" self . write_bytes ( address , chr ( value )) def write_u16 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 16 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 2 )) def write_u32 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 32 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 4 )) def write_u64 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 64 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 8 )) def write_varnode ( self , varnode , value ): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : raise ValueError ( \"Can't set value of a constant varnodes\" ) elif varnode . is_address : self . write_bytes ( varnode . offset , to_bytes ( value , varnode . size )) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) self . write_bytes ( offset , to_bytes ( value , varnode . size )) elif varnode . is_stack : self . raw . writeStackValue ( varnode . offset , varnode . size , value ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) self . raw . writeRegister ( reg , value ) else : raise RuntimeError ( \"Unsupported varnode type\" ) def emulate ( self , start , ends ): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self . set_pc ( start ) if not isinstance ( ends , ( list , tuple )): ends = [ ends ] for end in ends : end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( monitor ) for end in ends : end = resolve ( end ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def emulate_while ( self , start , condition ): # type: (Addr, Callable[[Emulator], bool]) -> None \"\"\"Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. :param start: the start address to emulate :param condition: a function that takes an Emulator instance as a parameter, and decides if emulation should be continued\"\"\" self . set_pc ( start ) emu = self . raw . getEmulator () emu . setHalt ( False ) while not emu . getHalt () and condition ( self ): emu . executeInstruction ( True , monitor ) if self . raw . getLastError () is not None : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def trace ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[Instruction], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed instruction :param maxsteps: the maximum number of steps to execute\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end and maxsteps > 0 : success = self . raw . step ( monitor ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) callback ( Instruction ( current )) current = self . raw . getExecutionAddress () maxsteps -= 1 def trace_pcode ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[PcodeOp], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed pcode op\"\"\" def instr_callback ( instruction ): # type: (Instruction) -> None for op in instruction . pcode : callback ( op ) self . trace ( start , end , instr_callback , maxsteps ) def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] \"\"\"Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. :param start: the start address to propagate from :param end: the end address to propagate to\"\"\" known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"Emulator"},{"location":"reference/#ghidralib.Emulator.pc","text":"Get the program counter of the emulated program.","title":"pc"},{"location":"reference/#ghidralib.Emulator.__getitem__","text":"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 Parameters: reg \u2013 the register or address to read from Source code in ghidralib.py 2621 2622 2623 2624 2625 2626 2627 2628 2629 def __getitem__ ( self , reg ): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self . read_register ( reg )","title":"__getitem__"},{"location":"reference/#ghidralib.Emulator.__init__","text":"Create a new Emulator object. Source code in ghidralib.py 2599 2600 2601 2602 2603 2604 2605 2606 2607 def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( Program . current ()) GhidraWrapper . __init__ ( self , raw ) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr ( 0 ) . getAddressSpace () . getMaxAddress () . getOffset () stack_off = ( max_pointer >> 1 ) - 0x8000 self . raw . writeRegister ( self . raw . getStackPointerRegister (), stack_off )","title":"__init__"},{"location":"reference/#ghidralib.Emulator.__setitem__","text":"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 def __setitem__ ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self . write_register ( reg , value )","title":"__setitem__"},{"location":"reference/#ghidralib.Emulator.emulate","text":"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Parameters: start \u2013 the start address to emulate ends \u2013 one or many end address Source code in ghidralib.py 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 def emulate ( self , start , ends ): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self . set_pc ( start ) if not isinstance ( ends , ( list , tuple )): ends = [ ends ] for end in ends : end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( monitor ) for end in ends : end = resolve ( end ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err ))","title":"emulate"},{"location":"reference/#ghidralib.Emulator.emulate_while","text":"Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. Parameters: start \u2013 the start address to emulate condition \u2013 a function that takes an Emulator instance as a parameter, and decides if emulation should be continued Source code in ghidralib.py 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 def emulate_while ( self , start , condition ): # type: (Addr, Callable[[Emulator], bool]) -> None \"\"\"Emulate from start as long as condition is met and emulator does't halt. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.emulate_while(0x1000, lambda e: e.pc != 0x1005) >>> emulator.read_bytes(0x1000, 1) '0' Note: This is slower than emulate(), because the emulation loop is implemented in Python. :param start: the start address to emulate :param condition: a function that takes an Emulator instance as a parameter, and decides if emulation should be continued\"\"\" self . set_pc ( start ) emu = self . raw . getEmulator () emu . setHalt ( False ) while not emu . getHalt () and condition ( self ): emu . executeInstruction ( True , monitor ) if self . raw . getLastError () is not None : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err ))","title":"emulate_while"},{"location":"reference/#ghidralib.Emulator.propagate_varnodes","text":"Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. Parameters: start \u2013 the start address to propagate from end \u2013 the end address to propagate to Source code in ghidralib.py 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] \"\"\"Propagate a known varnote state from start to end address. This is probably not the best way to do it - there is a large chance it'll be reworked to something better in the future. :param start: the start address to propagate from :param end: the end address to propagate to\"\"\" known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"propagate_varnodes"},{"location":"reference/#ghidralib.Emulator.read_bytes","text":"Read length bytes at address from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 def read_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( resolve ( address ), length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist )","title":"read_bytes"},{"location":"reference/#ghidralib.Emulator.read_cstring","text":"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 def read_cstring ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string","title":"read_cstring"},{"location":"reference/#ghidralib.Emulator.read_register","text":"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py 2642 2643 2644 2645 2646 2647 2648 2649 2650 def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg )","title":"read_register"},{"location":"reference/#ghidralib.Emulator.read_u16","text":"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2674 2675 2676 2677 2678 2679 2680 2681 2682 def read_u16 ( self , address ): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 2 ))","title":"read_u16"},{"location":"reference/#ghidralib.Emulator.read_u32","text":"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2684 2685 2686 2687 2688 2689 2690 2691 2692 def read_u32 ( self , address ): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 4 ))","title":"read_u32"},{"location":"reference/#ghidralib.Emulator.read_u64","text":"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2694 2695 2696 2697 2698 2699 2700 2701 2702 def read_u64 ( self , address ): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 8 ))","title":"read_u64"},{"location":"reference/#ghidralib.Emulator.read_u8","text":"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to read from Source code in ghidralib.py 2664 2665 2666 2667 2668 2669 2670 2671 2672 def read_u8 ( self , address ): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes ( self . read_bytes ( address , 1 ))","title":"read_u8"},{"location":"reference/#ghidralib.Emulator.read_unicode","text":"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 def read_unicode ( self , address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string","title":"read_unicode"},{"location":"reference/#ghidralib.Emulator.read_varnode","text":"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . read_bytes ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . read_bytes ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_stack : return self . raw . readStackValue ( varnode . offset , varnode . size , False ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . read_register ( reg ) raise RuntimeError ( \"Unsupported varnode type\" )","title":"read_varnode"},{"location":"reference/#ghidralib.Emulator.set_pc","text":"Set the program counter of the emulated program. Source code in ghidralib.py 2616 2617 2618 2619 def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , resolve ( address ) . getOffset ())","title":"set_pc"},{"location":"reference/#ghidralib.Emulator.trace","text":"Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed instruction maxsteps \u2013 the maximum number of steps to execute Source code in ghidralib.py 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 def trace ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[Instruction], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed Instruction. >>> emu = Emulator() >>> def pr(x): print(x) >>> emu.trace(Function(\"main\").entrypoint, 0, pr, 3) SUB ESP,0x2d4 PUSH EBX PUSH EBP :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed instruction :param maxsteps: the maximum number of steps to execute\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end and maxsteps > 0 : success = self . raw . step ( monitor ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) callback ( Instruction ( current )) current = self . raw . getExecutionAddress () maxsteps -= 1","title":"trace"},{"location":"reference/#ghidralib.Emulator.trace_pcode","text":"Emulate from start to end address, with callback for each executed PcodeOp. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed pcode op Source code in ghidralib.py 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 def trace_pcode ( self , start , end , callback , maxsteps = 2 ** 48 ): # type: (Addr, Addr, Callable[[PcodeOp], None], int) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed pcode op\"\"\" def instr_callback ( instruction ): # type: (Instruction) -> None for op in instruction . pcode : callback ( op ) self . trace ( start , end , instr_callback , maxsteps )","title":"trace_pcode"},{"location":"reference/#ghidralib.Emulator.write_bytes","text":"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 def write_bytes ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( resolve ( address ), value )","title":"write_bytes"},{"location":"reference/#ghidralib.Emulator.write_register","text":"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value )","title":"write_register"},{"location":"reference/#ghidralib.Emulator.write_u16","text":"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 def write_u16 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 16 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 2 ))","title":"write_u16"},{"location":"reference/#ghidralib.Emulator.write_u32","text":"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 def write_u32 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 32 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 4 ))","title":"write_u32"},{"location":"reference/#ghidralib.Emulator.write_u64","text":"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 def write_u64 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 64 , \"value out of range\" self . write_bytes ( address , to_bytes ( value , 8 ))","title":"write_u64"},{"location":"reference/#ghidralib.Emulator.write_u8","text":"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 def write_u8 ( self , address , value ): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2 ** 8 , \"value out of range\" self . write_bytes ( address , chr ( value ))","title":"write_u8"},{"location":"reference/#ghidralib.Emulator.write_varnode","text":"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 def write_varnode ( self , varnode , value ): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate_while(fnc.entrypoint, lambda e: e.pc in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode ( varnode ) if varnode . is_constant : raise ValueError ( \"Can't set value of a constant varnodes\" ) elif varnode . is_address : self . write_bytes ( varnode . offset , to_bytes ( value , varnode . size )) elif varnode . is_unique : space = Program . current () . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) self . write_bytes ( offset , to_bytes ( value , varnode . size )) elif varnode . is_stack : self . raw . writeStackValue ( varnode . offset , varnode . size , value ) elif varnode . is_register : language = Program . current () . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) self . raw . writeRegister ( reg , value ) else : raise RuntimeError ( \"Unsupported varnode type\" )","title":"write_varnode"},{"location":"reference/#ghidralib.FlowType","text":"Bases: GhidraWrapper Wraps a Ghidra FlowType object Source code in ghidralib.py 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 class FlowType ( GhidraWrapper ): \"\"\"Wraps a Ghidra FlowType object\"\"\" @property def is_call ( self ): # type: () -> bool \"\"\"Return True if this flow is a call.\"\"\" return self . raw . isCall () @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if this flow is a jump.\"\"\" return self . raw . isJump () @property def is_computed ( self ): # type: () -> bool \"\"\"Return True if this flow is a computed jump.\"\"\" return self . raw . isComputed () @property def is_conditional ( self ): # type: () -> bool \"\"\"Return True if this flow is a conditional jump.\"\"\" return self . raw . isConditional () @property def is_unconditional ( self ): # type: () -> bool \"\"\"Return True if this flow is an unconditional jump.\"\"\" return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool \"\"\"Return True if this flow is a terminator.\"\"\" return self . raw . isTerminator () @property def has_fallthrough ( self ): # type: () -> bool \"\"\"Return True if this flow has a fallthrough.\"\"\" return self . raw . hasFallThrough () @property def is_override ( self ): # type: () -> bool \"\"\"Return True if this flow is an override.\"\"\" return self . raw . isOverride ()","title":"FlowType"},{"location":"reference/#ghidralib.FlowType.has_fallthrough","text":"Return True if this flow has a fallthrough.","title":"has_fallthrough"},{"location":"reference/#ghidralib.FlowType.is_call","text":"Return True if this flow is a call.","title":"is_call"},{"location":"reference/#ghidralib.FlowType.is_computed","text":"Return True if this flow is a computed jump.","title":"is_computed"},{"location":"reference/#ghidralib.FlowType.is_conditional","text":"Return True if this flow is a conditional jump.","title":"is_conditional"},{"location":"reference/#ghidralib.FlowType.is_jump","text":"Return True if this flow is a jump.","title":"is_jump"},{"location":"reference/#ghidralib.FlowType.is_override","text":"Return True if this flow is an override.","title":"is_override"},{"location":"reference/#ghidralib.FlowType.is_terminal","text":"Return True if this flow is a terminator.","title":"is_terminal"},{"location":"reference/#ghidralib.FlowType.is_unconditional","text":"Return True if this flow is an unconditional jump.","title":"is_unconditional"},{"location":"reference/#ghidralib.Function","text":"Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Function object. Source code in ghidralib.py 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 class Function ( GhidraWrapper , BodyTrait ): \"\"\"Wraps a Ghidra Function object.\"\"\" UNDERLYING_CLASS = GhFunction @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance ( addr , GhFunction ): return Function ( addr ) if isinstance ( addr , Function ): return Function ( addr . raw ) addr = try_resolve ( addr ) if addr is None : return None raw = Program . current () . getListing () . getFunctionContaining ( addr ) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program . current () . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self . entrypoint @property def name ( self ): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self . raw . getName () @property def comment ( self ): # type: () -> str|None \"\"\"Get the comment of this function, if any.\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str|None \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] \"\"\"Get the parameters of this function.\"\"\" return [ Parameter ( raw ) for raw in self . raw . getParameters ()] def add_named_parameter ( self , datatype , name ): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self . raw . hasCustomVariableStorage (): raise ValueError ( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , 0 , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) def add_register_parameter ( self , datatype , register , name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self . raw . hasCustomVariableStorage (): self . raw . setCustomVariableStorage ( True ) reg = Register ( register ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , reg . raw , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED ) @property def local_variables ( self ): # type: () -> list[Variable] \"\"\"Get the local variables of this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with a variable in this function.\"\"\" varnodes = [] for var in self . variables : varnodes . extend ( var . varnodes ) return varnodes @property def high_variables ( self ): # type: () -> list[HighVariable] \"\"\"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . high_function . variables @property def stack ( self ): # type: () -> list[Variable] \"\"\"Get the defined stack variables (both parameters and locals).\"\"\" raw_vars = self . raw . getStackFrame () . getStackVariables () return [ Variable ( raw ) for raw in raw_vars ] def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = Program . current () . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] xrefs_to = xrefs @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str|None \"\"\"Get the fixup of this function.\"\"\" return self . raw . getCallFixup () @fixup . setter def fixup ( self , fixup ): # type: (str|None) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self . raw . setCallFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] \"\"\"Get all function calls to this function.\"\"\" calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel ( Program . current ()) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface () decompiler . openProgram ( Program . current ()) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () @property def clang_tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ()) @property def high_function ( self ): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . pcode_tree @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self . basicblocks : result . extend ( block . pcode ) return result @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_pcode () @property def high_basicblocks ( self ): # type: () -> list[PcodeBlock] \"\"\"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . high_function . basicblocks def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address ) @property def high_symbols ( self ): # type: () -> list[HighSymbol] \"\"\"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . symbols @property def primary_symbols ( self ): # type: () -> list[Symbol] \"\"\"Get the primary symbols for this function.\"\"\" symtable = Program . current () . getSymbolTable () syms = symtable . getPrimarySymbolIterator ( self . raw . getBody (), True ) return [ Symbol ( s ) for s in syms ] @property def symbols ( self ): # type: () -> list[Symbol] \"\"\"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.\"\"\" body = self . raw . getBody () symbols = [] symtable = Program . current () . getSymbolTable () for rng in body : for addr in rng : symbols . extend ( symtable . getSymbols ( addr )) return [ Symbol ( raw ) for raw in symbols ] @property def body ( self ): # type: () -> AddressSet \"\"\"Get the set of addresses of this function.\"\"\" return AddressSet ( self . raw . getBody ()) @property def control_flow ( self ): # type: () -> Graph[BasicBlock] \"\"\"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.\"\"\" g = Graph . create () for block in self . basicblocks : g . vertex ( block ) for block in self . basicblocks : for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g def emulate ( self , * args , ** kwargs ): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs : # Jython doesn't support keyword arguments after args, apparently emulator = kwargs [ \"emulator\" ] else : emulator = Emulator () if len ( args ) != len ( self . raw . getParameters ()): raise ValueError ( \"Wrong number of arguments for {} - got {} expected {} \" . format ( self . name , len ( args ), len ( self . raw . getParameters ()) ) ) for param , value in zip ( self . parameters , args ): emulator . write_varnode ( param . varnode , value ) emulator . emulate_while ( self . entrypoint , lambda e : e . pc in self . body ) return emulator","title":"Function"},{"location":"reference/#ghidralib.Function.UNDERLYING_CLASS","text":"","title":"UNDERLYING_CLASS"},{"location":"reference/#ghidralib.Function.address","text":"Get the address of this function.","title":"address"},{"location":"reference/#ghidralib.Function.basicblocks","text":"Get the basic blocks of this function.","title":"basicblocks"},{"location":"reference/#ghidralib.Function.body","text":"Get the set of addresses of this function.","title":"body"},{"location":"reference/#ghidralib.Function.called","text":"Get all functions that are called by this function.","title":"called"},{"location":"reference/#ghidralib.Function.callers","text":"Get all functions that call this function.","title":"callers"},{"location":"reference/#ghidralib.Function.calls","text":"Get all function calls to this function.","title":"calls"},{"location":"reference/#ghidralib.Function.clang_tokens","text":"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.","title":"clang_tokens"},{"location":"reference/#ghidralib.Function.comment","text":"Get the comment of this function, if any.","title":"comment"},{"location":"reference/#ghidralib.Function.control_flow","text":"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.","title":"control_flow"},{"location":"reference/#ghidralib.Function.entrypoint","text":"Get the entrypoint of this function.","title":"entrypoint"},{"location":"reference/#ghidralib.Function.fixup","text":"Get the fixup of this function.","title":"fixup"},{"location":"reference/#ghidralib.Function.high_basicblocks","text":"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_basicblocks"},{"location":"reference/#ghidralib.Function.high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_function"},{"location":"reference/#ghidralib.Function.high_pcode","text":"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_pcode"},{"location":"reference/#ghidralib.Function.high_symbols","text":"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_symbols"},{"location":"reference/#ghidralib.Function.high_variables","text":"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_variables"},{"location":"reference/#ghidralib.Function.instructions","text":"Get the assembler instructions for this function.","title":"instructions"},{"location":"reference/#ghidralib.Function.is_external","text":"Return True if this function is external.","title":"is_external"},{"location":"reference/#ghidralib.Function.is_thunk","text":"Return True if this function is a thunk.","title":"is_thunk"},{"location":"reference/#ghidralib.Function.local_variables","text":"Get the local variables of this function.","title":"local_variables"},{"location":"reference/#ghidralib.Function.name","text":"Get the name of this function.","title":"name"},{"location":"reference/#ghidralib.Function.parameters","text":"Get the parameters of this function.","title":"parameters"},{"location":"reference/#ghidralib.Function.pcode","text":"Get the (low-level) Pcode for this function.","title":"pcode"},{"location":"reference/#ghidralib.Function.pcode_tree","text":"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.","title":"pcode_tree"},{"location":"reference/#ghidralib.Function.primary_symbols","text":"Get the primary symbols for this function.","title":"primary_symbols"},{"location":"reference/#ghidralib.Function.repeatable_comment","text":"Get the repeatable comment of this function, if any.","title":"repeatable_comment"},{"location":"reference/#ghidralib.Function.return_type","text":"Get the return type of this function.","title":"return_type"},{"location":"reference/#ghidralib.Function.return_variable","text":"Get the variable representing a return value of this function.","title":"return_variable"},{"location":"reference/#ghidralib.Function.stack","text":"Get the defined stack variables (both parameters and locals).","title":"stack"},{"location":"reference/#ghidralib.Function.symbols","text":"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.","title":"symbols"},{"location":"reference/#ghidralib.Function.variables","text":"Get all variables defined in this function.","title":"variables"},{"location":"reference/#ghidralib.Function.varnodes","text":"Get all varnodes associated with a variable in this function.","title":"varnodes"},{"location":"reference/#ghidralib.Function.xref_addrs","text":"Get the source addresses of references to this function.","title":"xref_addrs"},{"location":"reference/#ghidralib.Function.xrefs","text":"Get the references to this function.","title":"xrefs"},{"location":"reference/#ghidralib.Function.xrefs_to","text":"","title":"xrefs_to"},{"location":"reference/#ghidralib.Function.add_named_parameter","text":"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented Source code in ghidralib.py 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 def add_named_parameter ( self , datatype , name ): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self . raw . hasCustomVariableStorage (): raise ValueError ( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , 0 , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED )","title":"add_named_parameter"},{"location":"reference/#ghidralib.Function.add_register_parameter","text":"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore Source code in ghidralib.py 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 def add_register_parameter ( self , datatype , register , name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self . raw . hasCustomVariableStorage (): self . raw . setCustomVariableStorage ( True ) reg = Register ( register ) data = DataType ( datatype ) param = ParameterImpl ( name , data . raw , reg . raw , Program . current ()) self . raw . addParameter ( param , SourceType . USER_DEFINED )","title":"add_register_parameter"},{"location":"reference/#ghidralib.Function.all","text":"Return all functions in the current program. Source code in ghidralib.py 2017 2018 2019 2020 2021 @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program . current () . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ]","title":"all"},{"location":"reference/#ghidralib.Function.create","text":"Create a new function at the given address with the given name. Source code in ghidralib.py 2023 2024 2025 2026 2027 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func )","title":"create"},{"location":"reference/#ghidralib.Function.decompile","text":"Get decompiled C code for the function as string. Source code in ghidralib.py 2226 2227 2228 2229 def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC ()","title":"decompile"},{"location":"reference/#ghidralib.Function.emulate","text":"Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 def emulate ( self , * args , ** kwargs ): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with the given arguments. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(0x004061EC) >>> emu = fnc.emulate(-0x80000000) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs : # Jython doesn't support keyword arguments after args, apparently emulator = kwargs [ \"emulator\" ] else : emulator = Emulator () if len ( args ) != len ( self . raw . getParameters ()): raise ValueError ( \"Wrong number of arguments for {} - got {} expected {} \" . format ( self . name , len ( args ), len ( self . raw . getParameters ()) ) ) for param , value in zip ( self . parameters , args ): emulator . write_varnode ( param . varnode , value ) emulator . emulate_while ( self . entrypoint , lambda e : e . pc in self . body ) return emulator","title":"emulate"},{"location":"reference/#ghidralib.Function.get","text":"Return a function at the given address, or None if no function exists there. Source code in ghidralib.py 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance ( addr , GhFunction ): return Function ( addr ) if isinstance ( addr , Function ): return Function ( addr . raw ) addr = try_resolve ( addr ) if addr is None : return None raw = Program . current () . getListing () . getFunctionContaining ( addr ) if raw is None : return None return Function ( raw ) # type: ignore","title":"get"},{"location":"reference/#ghidralib.Function.get_high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 2246 2247 2248 2249 2250 2251 2252 2253 2254 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ())","title":"get_high_function"},{"location":"reference/#ghidralib.Function.get_high_pcode","text":"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 2256 2257 2258 2259 2260 2261 2262 2263 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode","title":"get_high_pcode"},{"location":"reference/#ghidralib.Function.get_high_pcode_at","text":"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py 2294 2295 2296 2297 2298 2299 2300 2301 2302 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.Function.rename","text":"Change the name of this function. Source code in ghidralib.py 2148 2149 2150 def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED )","title":"rename"},{"location":"reference/#ghidralib.Function.set_comment","text":"Set the comment of this function. Source code in ghidralib.py 2059 2060 2061 def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment )","title":"set_comment"},{"location":"reference/#ghidralib.Function.set_repeatable_comment","text":"Set the repeatable comment of this function. Source code in ghidralib.py 2078 2079 2080 def set_repeatable_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment )","title":"set_repeatable_comment"},{"location":"reference/#ghidralib.FunctionCall","text":"Bases: BodyTrait Represents an abstract function call. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 class FunctionCall ( BodyTrait ): \"\"\"Represents an abstract function call. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . called_function = function self . address = resolve ( address ) @property def caller ( self ): # type: () -> Function|None \"\"\"Get the function where this function call takes place.\"\"\" return Function . get ( self . address ) calling_function = caller @property def instruction ( self ): # type: () -> Instruction return Instruction ( self . address ) @property def callee ( self ): # type: () -> Function \"\"\"Get the function being called.\"\"\" return self . called_function def infer_context ( self ): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. \"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu @property def high_pcodeop ( self ): # type: () -> PcodeOp|None \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) @property def high_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" op = self . high_pcodeop if not op : return [] return op . inputs [ 1 :] # skip function addr def infer_args ( self ): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" basicblock = BasicBlock ( self . address ) state = {} # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . high_varnodes : varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args @property def body ( self ): return self . instruction . body","title":"FunctionCall"},{"location":"reference/#ghidralib.FunctionCall.address","text":"","title":"address"},{"location":"reference/#ghidralib.FunctionCall.body","text":"","title":"body"},{"location":"reference/#ghidralib.FunctionCall.called_function","text":"","title":"called_function"},{"location":"reference/#ghidralib.FunctionCall.callee","text":"Get the function being called.","title":"callee"},{"location":"reference/#ghidralib.FunctionCall.caller","text":"Get the function where this function call takes place.","title":"caller"},{"location":"reference/#ghidralib.FunctionCall.calling_function","text":"","title":"calling_function"},{"location":"reference/#ghidralib.FunctionCall.high_pcodeop","text":"Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_pcodeop"},{"location":"reference/#ghidralib.FunctionCall.high_varnodes","text":"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_varnodes"},{"location":"reference/#ghidralib.FunctionCall.instruction","text":"","title":"instruction"},{"location":"reference/#ghidralib.FunctionCall.__init__","text":"Source code in ghidralib.py 1853 1854 1855 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . called_function = function self . address = resolve ( address )","title":"__init__"},{"location":"reference/#ghidralib.FunctionCall.infer_args","text":"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 def infer_args ( self ): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" basicblock = BasicBlock ( self . address ) state = {} # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . high_varnodes : varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"infer_args"},{"location":"reference/#ghidralib.FunctionCall.infer_context","text":"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. Source code in ghidralib.py 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 def infer_context ( self ): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well in case the assembly looks like, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax them is as simple as call.infer_context()[\"eax\"]. This will NOT work well, if the parameters are initialized much earlier. In this case consider using (much slower) infer_args() instead. \"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu","title":"infer_context"},{"location":"reference/#ghidralib.GenericT","text":"Source code in ghidralib.py 275 276 class GenericT : pass","title":"GenericT"},{"location":"reference/#ghidralib.GhidraWrapper","text":"Bases: object The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 class GhidraWrapper ( object ): \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__ ( self , raw ): # type: (JavaObject|int|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str , unicode , GenericAddress )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) # TODO - remove the conditional checks and implement this everywhere if hasattr ( self , \"UNDERLYING_CLASS\" ): wrapped_type = getattr ( self , \"UNDERLYING_CLASS\" ) if not isinstance ( raw , wrapped_type ): raise RuntimeError ( \"You are trying to wrap {} as {} \" . format ( raw . __class__ . __name__ , self . __class__ . __name__ ) ) self . raw = _as_javaobject ( raw ) # type: JavaObject def __str__ ( self ): # type: () -> str return self . raw . __str__ () def __repr__ ( self ): # type: () -> str return self . raw . __repr__ () def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"GhidraWrapper"},{"location":"reference/#ghidralib.GhidraWrapper.raw","text":"","title":"raw"},{"location":"reference/#ghidralib.GhidraWrapper.__eq__","text":"Source code in ghidralib.py 164 165 166 167 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"__eq__"},{"location":"reference/#ghidralib.GhidraWrapper.__hash__","text":"Source code in ghidralib.py 161 162 def __hash__ ( self ): # type: () -> int return self . raw . hashCode ()","title":"__hash__"},{"location":"reference/#ghidralib.GhidraWrapper.__init__","text":"Source code in ghidralib.py 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , raw ): # type: (JavaObject|int|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str , unicode , GenericAddress )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) # TODO - remove the conditional checks and implement this everywhere if hasattr ( self , \"UNDERLYING_CLASS\" ): wrapped_type = getattr ( self , \"UNDERLYING_CLASS\" ) if not isinstance ( raw , wrapped_type ): raise RuntimeError ( \"You are trying to wrap {} as {} \" . format ( raw . __class__ . __name__ , self . __class__ . __name__ ) ) self . raw = _as_javaobject ( raw ) # type: JavaObject","title":"__init__"},{"location":"reference/#ghidralib.GhidraWrapper.__repr__","text":"Source code in ghidralib.py 154 155 def __repr__ ( self ): # type: () -> str return self . raw . __repr__ ()","title":"__repr__"},{"location":"reference/#ghidralib.GhidraWrapper.__str__","text":"Source code in ghidralib.py 151 152 def __str__ ( self ): # type: () -> str return self . raw . __str__ ()","title":"__str__"},{"location":"reference/#ghidralib.GhidraWrapper.__tojava__","text":"Make it possible to pass this object to Java methods Source code in ghidralib.py 157 158 159 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw","title":"__tojava__"},{"location":"reference/#ghidralib.Graph","text":"Bases: GenericT , GhidraWrapper Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see get_unique_string() method. Source code in ghidralib.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 class Graph ( GenericT , GhidraWrapper ): \"\"\"Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see get_unique_string() method.\"\"\" def __init__ ( self , raw ): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper . __init__ ( self , raw ) self . data = {} @staticmethod def create ( name = None , description = None ): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType ( name , description , [], []) return Graph ( AttributedGraph ( name , graphtype , description )) def __contains__ ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = get_unique_string ( vtx ) vobj = self . raw . getVertex ( vid ) return self . raw . containsVertex ( vobj ) def has_vertex ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self def vertex ( self , vtx , name = None ): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = get_unique_string ( vtx ) name = name or vid self . raw . addVertex ( vid , name ) self . data [ vid ] = vtx return vtx def edge ( self , src , dst ): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = get_unique_string ( src ) dstid = get_unique_string ( dst ) srcobj = self . raw . getVertex ( srcid ) dstobj = self . raw . getVertex ( dstid ) self . raw . addEdge ( srcobj , dstobj ) @property def vertices ( self ): # type: () -> list[T] \"\"\"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.\"\"\" return [ self . __resolve ( vid . getId ()) for vid in self . raw . vertexSet ()] @property def vertex_count ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph.\"\"\" return self . raw . vertexSet () . size () def __len__ ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self . vertex_count @property def edges ( self ): # type: () -> list[T] \"\"\"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.\"\"\" result = [] for e in self . raw . edgeSet (): frm = self . raw . getEdgeSource ( e ) to = self . raw . getEdgeTarget ( e ) frmobj = self . data . get ( frm , frm ) toobj = self . data . get ( to , frm ) result . append (( frmobj , toobj )) return result @property def edge_count ( self ): # type: () -> int \"\"\"Return the number of edges in this graph.\"\"\" return self . raw . edgeSet () . size () @property def name ( self ): # type: () -> str \"\"\"Return the name of this graph.\"\"\" return self . raw . getName () @property def description ( self ): # type: () -> str \"\"\"Return the description of this graph.\"\"\" return self . raw . getDescription () def show ( self ): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self . raw . getGraphType () description = graphtype . getDescription () options = GraphDisplayOptions ( graphtype ) broker = state . tool . getService ( GraphDisplayBroker ) display = broker . getDefaultGraphDisplay ( False , monitor ) display . setGraph ( self . raw , options , description , False , monitor ) def __resolve ( self , vid ): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self . data : return self . data [ vid ] else : return vid # type: ignore graph created outside of ghidralib? def dfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop () if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents def toposort ( self , origin ): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. :returns: a list of vertex IDs in topological order.\"\"\" visited = set () result = [] def dfs ( vid ): visited . add ( vid ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): target = self . raw . getEdgeTarget ( edge ) if target . getId () not in visited : dfs ( target . getId ()) result . append ( self . __resolve ( vid )) dfs ( get_unique_string ( origin )) for vid in self . raw . vertexSet (): if vid . getId () not in visited : dfs ( vid . getId ()) return result def bfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop ( 0 ) if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents","title":"Graph"},{"location":"reference/#ghidralib.Graph.data","text":"","title":"data"},{"location":"reference/#ghidralib.Graph.description","text":"Return the description of this graph.","title":"description"},{"location":"reference/#ghidralib.Graph.edge_count","text":"Return the number of edges in this graph.","title":"edge_count"},{"location":"reference/#ghidralib.Graph.edges","text":"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.","title":"edges"},{"location":"reference/#ghidralib.Graph.name","text":"Return the name of this graph.","title":"name"},{"location":"reference/#ghidralib.Graph.vertex_count","text":"Return the number of vertices in this graph.","title":"vertex_count"},{"location":"reference/#ghidralib.Graph.vertices","text":"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.","title":"vertices"},{"location":"reference/#ghidralib.Graph.__contains__","text":"Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py 310 311 312 313 314 315 316 def __contains__ ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = get_unique_string ( vtx ) vobj = self . raw . getVertex ( vid ) return self . raw . containsVertex ( vobj )","title":"__contains__"},{"location":"reference/#ghidralib.Graph.__init__","text":"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. Parameters: raw \u2013 The AttributedGraph object to wrap. Source code in ghidralib.py 286 287 288 289 290 291 292 293 294 def __init__ ( self , raw ): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper . __init__ ( self , raw ) self . data = {}","title":"__init__"},{"location":"reference/#ghidralib.Graph.__len__","text":"Return the number of vertices in this graph. To get the number of edges, use edge_count. Source code in ghidralib.py 362 363 364 365 366 def __len__ ( self ): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self . vertex_count","title":"__len__"},{"location":"reference/#ghidralib.Graph.__resolve","text":"Resolve a vertex ID to a vertex object. Parameters: vid \u2013 The ID of the vertex to resolve. Source code in ghidralib.py 408 409 410 411 412 413 414 415 def __resolve ( self , vid ): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self . data : return self . data [ vid ] else : return vid # type: ignore graph created outside of ghidralib?","title":"__resolve"},{"location":"reference/#ghidralib.Graph.bfs","text":"Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Source code in ghidralib.py 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def bfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop ( 0 ) if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents","title":"bfs"},{"location":"reference/#ghidralib.Graph.create","text":"Create a new Graph. Parameters: name \u2013 The name of the graph. If None, a default name will be used. description \u2013 The description of the graph. If None, a default description will be used. Returns: \u2013 a new Graph object. Source code in ghidralib.py 296 297 298 299 300 301 302 303 304 305 306 307 308 @staticmethod def create ( name = None , description = None ): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType ( name , description , [], []) return Graph ( AttributedGraph ( name , graphtype , description ))","title":"create"},{"location":"reference/#ghidralib.Graph.dfs","text":"Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Returns: \u2013 A dictionary of parent vertices for each visited vertex. Source code in ghidralib.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def dfs ( self , origin , callback = lambda _ : None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [( None , get_unique_string ( origin ))] visited = set () parents = { origin : None } # type: dict[T, T|None] while tovisit : parent , vid = tovisit . pop () if vid in visited : continue visited . add ( vid ) vobj = self . __resolve ( vid ) parents [ vobj ] = parent callback ( vobj ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): tovisit . append (( vobj , self . raw . getEdgeTarget ( edge ) . getId ())) return parents","title":"dfs"},{"location":"reference/#ghidralib.Graph.edge","text":"Create an edge between two vertices in this graph. Parameters: src \u2013 The source vertex ID. dst \u2013 The destination vertex ID. Source code in ghidralib.py 338 339 340 341 342 343 344 345 346 347 def edge ( self , src , dst ): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = get_unique_string ( src ) dstid = get_unique_string ( dst ) srcobj = self . raw . getVertex ( srcid ) dstobj = self . raw . getVertex ( dstid ) self . raw . addEdge ( srcobj , dstobj )","title":"edge"},{"location":"reference/#ghidralib.Graph.has_vertex","text":"Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py 318 319 320 321 322 def has_vertex ( self , vtx ): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self","title":"has_vertex"},{"location":"reference/#ghidralib.Graph.show","text":"Display this graph in the Ghidra GUI. Source code in ghidralib.py 398 399 400 401 402 403 404 405 406 def show ( self ): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self . raw . getGraphType () description = graphtype . getDescription () options = GraphDisplayOptions ( graphtype ) broker = state . tool . getService ( GraphDisplayBroker ) display = broker . getDefaultGraphDisplay ( False , monitor ) display . setGraph ( self . raw , options , description , False , monitor )","title":"show"},{"location":"reference/#ghidralib.Graph.toposort","text":"Perform a topological sort on this graph, starting from the given vertex. Parameters: origin \u2013 The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. Returns: \u2013 a list of vertex IDs in topological order. Source code in ghidralib.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def toposort ( self , origin ): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then A will be before B in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. :returns: a list of vertex IDs in topological order.\"\"\" visited = set () result = [] def dfs ( vid ): visited . add ( vid ) for edge in self . raw . edgesOf ( self . raw . getVertex ( vid )): target = self . raw . getEdgeTarget ( edge ) if target . getId () not in visited : dfs ( target . getId ()) result . append ( self . __resolve ( vid )) dfs ( get_unique_string ( origin )) for vid in self . raw . vertexSet (): if vid . getId () not in visited : dfs ( vid . getId ()) return result","title":"toposort"},{"location":"reference/#ghidralib.Graph.vertex","text":"Get or create a vertex in this graph. Parameters: vtx \u2013 The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. name \u2013 The name of the vertex. If not provided, the ID will be used as the name. Returns: \u2013 vtx parameter is returned Source code in ghidralib.py 324 325 326 327 328 329 330 331 332 333 334 335 336 def vertex ( self , vtx , name = None ): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = get_unique_string ( vtx ) name = name or vid self . raw . addVertex ( vid , name ) self . data [ vid ] = vtx return vtx","title":"vertex"},{"location":"reference/#ghidralib.HighFunction","text":"Bases: GhidraWrapper Source code in ghidralib.py 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 class HighFunction ( GhidraWrapper ): @staticmethod def get ( address ): # type: (JavaObject|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance ( address , GhHighFunction ): return HighFunction ( address ) func = Function . get ( address ) if func is None : return None return func . high_function @property def function ( self ): # type: () -> Function \"\"\"Get the underlying function of this high function.\"\"\" return Function ( self . raw . getFunction ()) def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basicblocks ( self ): # type: () -> list[PcodeBlock] \"\"\"Get a list of basic blocks in this high function.\"\"\" return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" edge_map = {} ingraph = GhBlockGraph () for block in self . basicblocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basicblocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( Program . current ()) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) @property def symbols ( self ): # type: () -> list[HighSymbol] \"\"\"Get high symbols used in this function (including parameters).\"\"\" sm = self . raw . getLocalSymbolMap () return [ HighSymbol ( symbol ) for symbol in sm . getSymbols ()] @property def variables ( self ): # type: () -> list[HighVariable] \"\"\"Get high variables defined in this function.\"\"\" result = [] for sym in self . symbols : var = sym . variable if var is not None : result . append ( var ) return result def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance ( other , HighFunction ): return False return self . function == other . function","title":"HighFunction"},{"location":"reference/#ghidralib.HighFunction.basicblocks","text":"Get a list of basic blocks in this high function.","title":"basicblocks"},{"location":"reference/#ghidralib.HighFunction.function","text":"Get the underlying function of this high function.","title":"function"},{"location":"reference/#ghidralib.HighFunction.pcode","text":"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.","title":"pcode"},{"location":"reference/#ghidralib.HighFunction.pcode_tree","text":"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.","title":"pcode_tree"},{"location":"reference/#ghidralib.HighFunction.symbols","text":"Get high symbols used in this function (including parameters).","title":"symbols"},{"location":"reference/#ghidralib.HighFunction.variables","text":"Get high variables defined in this function.","title":"variables"},{"location":"reference/#ghidralib.HighFunction.__eq__","text":"Compare two high functions. Fun fact - Ghidra doesn't know how to do this. Source code in ghidralib.py 1031 1032 1033 1034 1035 1036 1037 def __eq__ ( self , other ): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance ( other , HighFunction ): return False return self . function == other . function","title":"__eq__"},{"location":"reference/#ghidralib.HighFunction.get","text":"Get a HighFunction at a given address, or None if there is none. Source code in ghidralib.py 959 960 961 962 963 964 965 966 967 @staticmethod def get ( address ): # type: (JavaObject|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance ( address , GhHighFunction ): return HighFunction ( address ) func = Function . get ( address ) if func is None : return None return func . high_function","title":"get"},{"location":"reference/#ghidralib.HighFunction.get_pcode_at","text":"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address. Source code in ghidralib.py 974 975 976 977 978 979 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )]","title":"get_pcode_at"},{"location":"reference/#ghidralib.HighSymbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source ) @property def size ( self ): # type: () -> int \"\"\"Return the size of this symbol in bytes\"\"\" return self . raw . getSize () @property def data_type ( self ): # type: () -> DataType \"\"\"Return the data type of this symbol\"\"\" return DataType ( self . raw . getDataType ()) @property def variable ( self ): # type: () -> HighVariable|None \"\"\"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.\"\"\" raw = self . raw . getHighVariable () if raw is None : return None return HighVariable ( raw ) @property def name ( self ): # type: () -> str \"\"\"Return the name of this symbol\"\"\" return self . raw . getName () @property def symbol ( self ): # type: () -> Symbol|None \"\"\"Get the corresponding symbol, if it exists.\"\"\" raw = self . raw . getSymbol () if raw is None : return None return Symbol ( raw ) @property def is_this_pointer ( self ): # type: () -> bool \"\"\"Return True if this symbol is a \"this\" pointer for a class\"\"\" return self . raw . isThisPointer ()","title":"HighSymbol"},{"location":"reference/#ghidralib.HighSymbol.data_type","text":"Return the data type of this symbol","title":"data_type"},{"location":"reference/#ghidralib.HighSymbol.is_this_pointer","text":"Return True if this symbol is a \"this\" pointer for a class","title":"is_this_pointer"},{"location":"reference/#ghidralib.HighSymbol.name","text":"Return the name of this symbol","title":"name"},{"location":"reference/#ghidralib.HighSymbol.size","text":"Return the size of this symbol in bytes","title":"size"},{"location":"reference/#ghidralib.HighSymbol.symbol","text":"Get the corresponding symbol, if it exists.","title":"symbol"},{"location":"reference/#ghidralib.HighSymbol.variable","text":"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.","title":"variable"},{"location":"reference/#ghidralib.HighSymbol.rename","text":"Rename this high symbol. Parameters: new_name \u2013 The new name of the symbol source \u2013 The source of the symbol Source code in ghidralib.py 579 580 581 582 583 584 585 586 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source )","title":"rename"},{"location":"reference/#ghidralib.HighVariable","text":"Bases: GhidraWrapper Source code in ghidralib.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self . symbol . rename ( new_name ) @property def size ( self ): # type: () -> int \"\"\"Return the size of this variable in bytes\"\"\" return self . raw . getSize () @property def data_type ( self ): # type: () -> DataType \"\"\"Return the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @property def name ( self ): # type: () -> str \"\"\"Return the name of this variable\"\"\" return self . raw . getName () @property def varnode ( self ): # type: () -> Varnode \"\"\"Return the Varnode that represents this variable\"\"\" return Varnode ( self . raw . getRepresentative ()) @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Return all Varnodes that represent this variable at some point\"\"\" return [ Varnode ( vn ) for vn in self . raw . getInstances ()] @property def is_unaffected ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are is unaffected.\"\"\" return any ( vn . is_unaffected for vn in self . varnodes ) @property def is_persistent ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are persistent.\"\"\" return any ( vn . is_persistent for vn in self . varnodes ) @property def is_addr_tied ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are addr tied.\"\"\" return any ( vn . is_addr_tied for vn in self . varnodes ) @property def is_input ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are input.\"\"\" return any ( vn . is_input for vn in self . varnodes ) @property def is_free ( self ): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are free.\"\"\" return all ( vn . is_free for vn in self . varnodes )","title":"HighVariable"},{"location":"reference/#ghidralib.HighVariable.data_type","text":"Return the data type of this variable","title":"data_type"},{"location":"reference/#ghidralib.HighVariable.is_addr_tied","text":"Return True if ALL varnodes of this variable are addr tied.","title":"is_addr_tied"},{"location":"reference/#ghidralib.HighVariable.is_free","text":"Return True if ALL varnodes of this variable are free.","title":"is_free"},{"location":"reference/#ghidralib.HighVariable.is_input","text":"Return True if ALL varnodes of this variable are input.","title":"is_input"},{"location":"reference/#ghidralib.HighVariable.is_persistent","text":"Return True if ALL varnodes of this variable are persistent.","title":"is_persistent"},{"location":"reference/#ghidralib.HighVariable.is_unaffected","text":"Return True if ALL varnodes of this variable are is unaffected.","title":"is_unaffected"},{"location":"reference/#ghidralib.HighVariable.name","text":"Return the name of this variable","title":"name"},{"location":"reference/#ghidralib.HighVariable.size","text":"Return the size of this variable in bytes","title":"size"},{"location":"reference/#ghidralib.HighVariable.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.HighVariable.varnode","text":"Return the Varnode that represents this variable","title":"varnode"},{"location":"reference/#ghidralib.HighVariable.varnodes","text":"Return all Varnodes that represent this variable at some point","title":"varnodes"},{"location":"reference/#ghidralib.HighVariable.rename","text":"Rename this high variable. Source code in ghidralib.py 523 524 525 def rename ( self , new_name ): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self . symbol . rename ( new_name )","title":"rename"},{"location":"reference/#ghidralib.Instruction","text":"Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Instruction object Source code in ghidralib.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 class Instruction ( GhidraWrapper , BodyTrait ): \"\"\"Wraps a Ghidra Instruction object\"\"\" @staticmethod def get ( address ): # type: (Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve ( address ): raw = getInstructionAt ( resolve ( address )) else : raw = address if raw is None : return None return Instruction ( raw ) @staticmethod def all (): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program . current () . getListing () . getInstructions ( True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def mnemonic ( self ): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction ( self . raw . getPrevious ()) prev = previous @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] \"\"\"Get a list of references from this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] @property def to ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesTo ()] def to_bytes ( self ): # type: () -> str \"\"\"Get the bytes of this instruction.\"\"\" return to_bytestring ( self . raw . getBytes ()) @property def length ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . raw . getLength () def __len__ ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . length def operand ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , Str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out @property def address ( self ): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self . raw . getAddress () . getOffset () @property def operands ( self ): # type: () -> list[int|str] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.\"\"\" return [ self . operand ( i ) for i in range ( self . raw . getNumOperands ())] @property def flow_type ( self ): # type: () -> FlowType \"\"\"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return FlowType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type = SourceType . USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) @property def body ( self ): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet . create ( self . address , self . length ) @property def fallthrough_override ( self ): # type: () -> int|None \"\"\"Get the fallthrough address override, if any. Fallthrough override is the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere.\"\"\" fall = self . raw . getFallThrough () if not fall : return None return fall . getOffset () @fallthrough_override . setter def fallthrough_override ( self , value ): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. :param value: new fallthrough address\"\"\" self . raw . setFallThrough ( resolve ( value )) @fallthrough_override . deleter def fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction.\"\"\" self . raw . clearFallThroughOverride () def clear_fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" del self . fallthrough_override def write_jumptable ( self , targets ): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [ resolve ( addr ) for addr in targets ] for dest in targets : self . add_operand_reference ( 0 , dest , RefType . COMPUTED_JUMP ) func = Function . get ( self . address ) if func is None : raise RuntimeError ( \"Instruction is not part of a function\" ) targetlist = ArrayList ( dest for dest in targets ) jumpTab = JumpTable ( toAddr ( self . address ), targetlist , True ) jumpTab . writeOverride ( func ) CreateFunctionCmd . fixupFunctionBody ( Program . current (), func . raw , monitor )","title":"Instruction"},{"location":"reference/#ghidralib.Instruction.address","text":"Get the address of this instruction.","title":"address"},{"location":"reference/#ghidralib.Instruction.body","text":"Get the address range this instruction.","title":"body"},{"location":"reference/#ghidralib.Instruction.fallthrough_override","text":"Get the fallthrough address override, if any. Fallthrough override is the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere.","title":"fallthrough_override"},{"location":"reference/#ghidralib.Instruction.flow_type","text":"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP","title":"flow_type"},{"location":"reference/#ghidralib.Instruction.high_pcode","text":"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.","title":"high_pcode"},{"location":"reference/#ghidralib.Instruction.length","text":"Get the length of this instruction in bytes.","title":"length"},{"location":"reference/#ghidralib.Instruction.mnemonic","text":"Get the mnemonic of this instruction.","title":"mnemonic"},{"location":"reference/#ghidralib.Instruction.next","text":"Get the next instruction.","title":"next"},{"location":"reference/#ghidralib.Instruction.operands","text":"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.","title":"operands"},{"location":"reference/#ghidralib.Instruction.pcode","text":"Get a list of Pcode operations that this instruction was parsed to","title":"pcode"},{"location":"reference/#ghidralib.Instruction.prev","text":"","title":"prev"},{"location":"reference/#ghidralib.Instruction.previous","text":"Get the previous instruction.","title":"previous"},{"location":"reference/#ghidralib.Instruction.to","text":"Get a list of references to this instruction.","title":"to"},{"location":"reference/#ghidralib.Instruction.xrefs_from","text":"Get a list of references from this instruction.","title":"xrefs_from"},{"location":"reference/#ghidralib.Instruction.__len__","text":"Get the length of this instruction in bytes. Source code in ghidralib.py 1312 1313 1314 def __len__ ( self ): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self . length","title":"__len__"},{"location":"reference/#ghidralib.Instruction.add_operand_reference","text":"Add a reference to an operand of this instruction. Source code in ghidralib.py 1365 1366 1367 1368 1369 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type = SourceType . USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"add_operand_reference"},{"location":"reference/#ghidralib.Instruction.all","text":"Get all instruction defined in the current program. Source code in ghidralib.py 1258 1259 1260 1261 1262 @staticmethod def all (): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program . current () . getListing () . getInstructions ( True ) return [ Instruction ( raw ) for raw in raw_instructions ]","title":"all"},{"location":"reference/#ghidralib.Instruction.clear_fallthrough_override","text":"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override Source code in ghidralib.py 1402 1403 1404 1405 1406 def clear_fallthrough_override ( self ): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" del self . fallthrough_override","title":"clear_fallthrough_override"},{"location":"reference/#ghidralib.Instruction.get","text":"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func: disassemble_at instead. Parameters: address \u2013 The address of the instruction. Returns: \u2013 The instruction at the address, or None if not found. Source code in ghidralib.py 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 @staticmethod def get ( address ): # type: (Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve ( address ): raw = getInstructionAt ( resolve ( address )) else : raw = address if raw is None : return None return Instruction ( raw )","title":"get"},{"location":"reference/#ghidralib.Instruction.operand","text":"Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 def operand ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj )","title":"operand"},{"location":"reference/#ghidralib.Instruction.register","text":"Get the nth operand of this instruction as a register name. Source code in ghidralib.py 1337 1338 1339 1340 1341 1342 def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , Str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out","title":"register"},{"location":"reference/#ghidralib.Instruction.scalar","text":"Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 1330 1331 1332 1333 1334 1335 def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out","title":"scalar"},{"location":"reference/#ghidralib.Instruction.to_bytes","text":"Get the bytes of this instruction. Source code in ghidralib.py 1303 1304 1305 def to_bytes ( self ): # type: () -> str \"\"\"Get the bytes of this instruction.\"\"\" return to_bytestring ( self . raw . getBytes ())","title":"to_bytes"},{"location":"reference/#ghidralib.Instruction.write_jumptable","text":"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?). Source code in ghidralib.py 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 def write_jumptable ( self , targets ): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [ resolve ( addr ) for addr in targets ] for dest in targets : self . add_operand_reference ( 0 , dest , RefType . COMPUTED_JUMP ) func = Function . get ( self . address ) if func is None : raise RuntimeError ( \"Instruction is not part of a function\" ) targetlist = ArrayList ( dest for dest in targets ) jumpTab = JumpTable ( toAddr ( self . address ), targetlist , True ) jumpTab . writeOverride ( func ) CreateFunctionCmd . fixupFunctionBody ( Program . current (), func . raw , monitor )","title":"write_jumptable"},{"location":"reference/#ghidralib.JavaObject","text":"A fake class, used for static type hints. Source code in ghidralib.py 86 87 88 89 90 91 class JavaObject : \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"JavaObject"},{"location":"reference/#ghidralib.JavaObject.__getattribute__","text":"This attribute exists to make mypy happy. Source code in ghidralib.py 89 90 91 def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"__getattribute__"},{"location":"reference/#ghidralib.Parameter","text":"Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 class Parameter ( Variable ): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal ( self ): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType ( self . raw . getFormalDataType ())","title":"Parameter"},{"location":"reference/#ghidralib.Parameter.formal_data_type","text":"Returns the formal data type of this parameter.","title":"formal_data_type"},{"location":"reference/#ghidralib.Parameter.ordinal","text":"Returns the ordinal of this parameter.","title":"ordinal"},{"location":"reference/#ghidralib.PcodeBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def has_children ( self ): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ]","title":"PcodeBlock"},{"location":"reference/#ghidralib.PcodeBlock.has_children","text":"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.","title":"has_children"},{"location":"reference/#ghidralib.PcodeBlock.incoming_edges","text":"","title":"incoming_edges"},{"location":"reference/#ghidralib.PcodeBlock.outgoing_edges","text":"","title":"outgoing_edges"},{"location":"reference/#ghidralib.PcodeBlock.pcode","text":"","title":"pcode"},{"location":"reference/#ghidralib.PcodeOp","text":"Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ())","title":"PcodeOp"},{"location":"reference/#ghidralib.PcodeOp.BOOL_AND","text":"","title":"BOOL_AND"},{"location":"reference/#ghidralib.PcodeOp.BOOL_NEGATE","text":"","title":"BOOL_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.BOOL_OR","text":"","title":"BOOL_OR"},{"location":"reference/#ghidralib.PcodeOp.BOOL_XOR","text":"","title":"BOOL_XOR"},{"location":"reference/#ghidralib.PcodeOp.BRANCH","text":"","title":"BRANCH"},{"location":"reference/#ghidralib.PcodeOp.BRANCHIND","text":"","title":"BRANCHIND"},{"location":"reference/#ghidralib.PcodeOp.CALL","text":"","title":"CALL"},{"location":"reference/#ghidralib.PcodeOp.CALLIND","text":"","title":"CALLIND"},{"location":"reference/#ghidralib.PcodeOp.CALLOTHER","text":"","title":"CALLOTHER"},{"location":"reference/#ghidralib.PcodeOp.CAST","text":"","title":"CAST"},{"location":"reference/#ghidralib.PcodeOp.CBRANCH","text":"","title":"CBRANCH"},{"location":"reference/#ghidralib.PcodeOp.COPY","text":"","title":"COPY"},{"location":"reference/#ghidralib.PcodeOp.CPOOLREF","text":"","title":"CPOOLREF"},{"location":"reference/#ghidralib.PcodeOp.EXTRACT","text":"","title":"EXTRACT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ABS","text":"","title":"FLOAT_ABS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ADD","text":"","title":"FLOAT_ADD"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_CEIL","text":"","title":"FLOAT_CEIL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_DIV","text":"","title":"FLOAT_DIV"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_EQUAL","text":"","title":"FLOAT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT","text":"","title":"FLOAT_FLOAT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOOR","text":"","title":"FLOAT_FLOOR"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_INT2FLOAT","text":"","title":"FLOAT_INT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESS","text":"","title":"FLOAT_LESS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESSEQUAL","text":"","title":"FLOAT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_MULT","text":"","title":"FLOAT_MULT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NAN","text":"","title":"FLOAT_NAN"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NEG","text":"","title":"FLOAT_NEG"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NOTEQUAL","text":"","title":"FLOAT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ROUND","text":"","title":"FLOAT_ROUND"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SQRT","text":"","title":"FLOAT_SQRT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SUB","text":"","title":"FLOAT_SUB"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_TRUNC","text":"","title":"FLOAT_TRUNC"},{"location":"reference/#ghidralib.PcodeOp.INDIRECT","text":"","title":"INDIRECT"},{"location":"reference/#ghidralib.PcodeOp.INSERT","text":"","title":"INSERT"},{"location":"reference/#ghidralib.PcodeOp.INT_2COMP","text":"","title":"INT_2COMP"},{"location":"reference/#ghidralib.PcodeOp.INT_ADD","text":"","title":"INT_ADD"},{"location":"reference/#ghidralib.PcodeOp.INT_AND","text":"","title":"INT_AND"},{"location":"reference/#ghidralib.PcodeOp.INT_CARRY","text":"","title":"INT_CARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_DIV","text":"","title":"INT_DIV"},{"location":"reference/#ghidralib.PcodeOp.INT_EQUAL","text":"","title":"INT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_LEFT","text":"","title":"INT_LEFT"},{"location":"reference/#ghidralib.PcodeOp.INT_LESS","text":"","title":"INT_LESS"},{"location":"reference/#ghidralib.PcodeOp.INT_LESSEQUAL","text":"","title":"INT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_MULT","text":"","title":"INT_MULT"},{"location":"reference/#ghidralib.PcodeOp.INT_NEGATE","text":"","title":"INT_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.INT_NOTEQUAL","text":"","title":"INT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_OR","text":"","title":"INT_OR"},{"location":"reference/#ghidralib.PcodeOp.INT_REM","text":"","title":"INT_REM"},{"location":"reference/#ghidralib.PcodeOp.INT_RIGHT","text":"","title":"INT_RIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SBORROW","text":"","title":"INT_SBORROW"},{"location":"reference/#ghidralib.PcodeOp.INT_SCARRY","text":"","title":"INT_SCARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_SDIV","text":"","title":"INT_SDIV"},{"location":"reference/#ghidralib.PcodeOp.INT_SEXT","text":"","title":"INT_SEXT"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESS","text":"","title":"INT_SLESS"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESSEQUAL","text":"","title":"INT_SLESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_SREM","text":"","title":"INT_SREM"},{"location":"reference/#ghidralib.PcodeOp.INT_SRIGHT","text":"","title":"INT_SRIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SUB","text":"","title":"INT_SUB"},{"location":"reference/#ghidralib.PcodeOp.INT_XOR","text":"","title":"INT_XOR"},{"location":"reference/#ghidralib.PcodeOp.INT_ZEXT","text":"","title":"INT_ZEXT"},{"location":"reference/#ghidralib.PcodeOp.LOAD","text":"","title":"LOAD"},{"location":"reference/#ghidralib.PcodeOp.LZCOUNT","text":"","title":"LZCOUNT"},{"location":"reference/#ghidralib.PcodeOp.MULTIEQUAL","text":"","title":"MULTIEQUAL"},{"location":"reference/#ghidralib.PcodeOp.NEW","text":"","title":"NEW"},{"location":"reference/#ghidralib.PcodeOp.PCODE_MAX","text":"","title":"PCODE_MAX"},{"location":"reference/#ghidralib.PcodeOp.PIECE","text":"","title":"PIECE"},{"location":"reference/#ghidralib.PcodeOp.POPCOUNT","text":"","title":"POPCOUNT"},{"location":"reference/#ghidralib.PcodeOp.PTRADD","text":"","title":"PTRADD"},{"location":"reference/#ghidralib.PcodeOp.PTRSUB","text":"","title":"PTRSUB"},{"location":"reference/#ghidralib.PcodeOp.RETURN","text":"","title":"RETURN"},{"location":"reference/#ghidralib.PcodeOp.SEGMENTOP","text":"","title":"SEGMENTOP"},{"location":"reference/#ghidralib.PcodeOp.STORE","text":"","title":"STORE"},{"location":"reference/#ghidralib.PcodeOp.SUBPIECE","text":"","title":"SUBPIECE"},{"location":"reference/#ghidralib.PcodeOp.UNIMPLEMENTED","text":"","title":"UNIMPLEMENTED"},{"location":"reference/#ghidralib.PcodeOp.address","text":"Get an address in the program where this instruction is located","title":"address"},{"location":"reference/#ghidralib.PcodeOp.inputs","text":"","title":"inputs"},{"location":"reference/#ghidralib.PcodeOp.inputs_simple","text":"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).","title":"inputs_simple"},{"location":"reference/#ghidralib.PcodeOp.mnemonic","text":"Get a string representation of the operation, for example \"COPY\"","title":"mnemonic"},{"location":"reference/#ghidralib.PcodeOp.opcode","text":"","title":"opcode"},{"location":"reference/#ghidralib.PcodeOp.output","text":"","title":"output"},{"location":"reference/#ghidralib.PcodeOp.get_high_pcode_at","text":"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 876 877 878 879 880 881 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.Program","text":"Bases: GhidraWrapper A static class that represents the current program Source code in ghidralib.py 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 class Program ( GhidraWrapper ): \"\"\"A static class that represents the current program\"\"\" @staticmethod def create_data ( address , datatype ): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType ( datatype ) try : createData ( resolve ( address ), unwrap ( typeobj )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( typeobj )) @staticmethod def location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return currentLocation . getAddress () . getOffset () @staticmethod def call_graph (): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" g = Graph . create () for func in Function . all (): g . vertex ( func , func . name ) for func in Function . all (): for out in func . called : if out . is_external : continue g . edge ( func , out ) return g @staticmethod def control_flow (): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" g = Graph . create () for block in BasicBlock . all (): g . vertex ( block , str ( block . address )) for block in BasicBlock . all (): for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g @staticmethod def basicblocks (): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock . all () @staticmethod def functions (): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function . all () @staticmethod def instructions (): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction . all () @staticmethod def body (): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program . current () . getNamespaceManager () . getGlobalNamespace () . getBody () return AddressSet ( body ) @staticmethod def current (): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram ()","title":"Program"},{"location":"reference/#ghidralib.Program.basicblocks","text":"Get all the basic blocks defined in the program. Source code in ghidralib.py 3062 3063 3064 3065 @staticmethod def basicblocks (): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock . all ()","title":"basicblocks"},{"location":"reference/#ghidralib.Program.body","text":"Get the set of all addresses of the program. Source code in ghidralib.py 3077 3078 3079 3080 3081 @staticmethod def body (): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program . current () . getNamespaceManager () . getGlobalNamespace () . getBody () return AddressSet ( body )","title":"body"},{"location":"reference/#ghidralib.Program.call_graph","text":"Get the call graph for this program. Source code in ghidralib.py 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 @staticmethod def call_graph (): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" g = Graph . create () for func in Function . all (): g . vertex ( func , func . name ) for func in Function . all (): for out in func . called : if out . is_external : continue g . edge ( func , out ) return g","title":"call_graph"},{"location":"reference/#ghidralib.Program.control_flow","text":"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it. Source code in ghidralib.py 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 @staticmethod def control_flow (): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" g = Graph . create () for block in BasicBlock . all (): g . vertex ( block , str ( block . address )) for block in BasicBlock . all (): for dest in block . destinations : if dest in g : g . edge ( block , dest ) return g","title":"control_flow"},{"location":"reference/#ghidralib.Program.create_data","text":"Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 @staticmethod def create_data ( address , datatype ): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType ( datatype ) try : createData ( resolve ( address ), unwrap ( typeobj )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( typeobj ))","title":"create_data"},{"location":"reference/#ghidralib.Program.current","text":"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool). Source code in ghidralib.py 3083 3084 3085 3086 3087 3088 3089 3090 @staticmethod def current (): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram ()","title":"current"},{"location":"reference/#ghidralib.Program.functions","text":"Get all the functions defined in the program. Source code in ghidralib.py 3067 3068 3069 3070 @staticmethod def functions (): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function . all ()","title":"functions"},{"location":"reference/#ghidralib.Program.instructions","text":"Get all the instructions defined in the program. Source code in ghidralib.py 3072 3073 3074 3075 @staticmethod def instructions (): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction . all ()","title":"instructions"},{"location":"reference/#ghidralib.Program.location","text":"Get the current location in the program. >>> current_location() 0x1000 Returns: \u2013 the current location in the program Source code in ghidralib.py 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 @staticmethod def location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return currentLocation . getAddress () . getOffset ()","title":"location"},{"location":"reference/#ghidralib.RefType","text":"Bases: GhidraWrapper Source code in ghidralib.py 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder ()","title":"RefType"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_CALL","text":"","title":"CALLOTHER_OVERRIDE_CALL"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP","text":"","title":"CALLOTHER_OVERRIDE_JUMP"},{"location":"reference/#ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL","text":"","title":"CALL_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.CALL_TERMINATOR","text":"","title":"CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL","text":"","title":"COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL_TERMINATOR","text":"","title":"COMPUTED_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_JUMP","text":"","title":"COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL","text":"","title":"CONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR","text":"","title":"CONDITIONAL_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_CALL","text":"","title":"CONDITIONAL_COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP","text":"","title":"CONDITIONAL_COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_JUMP","text":"","title":"CONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_TERMINATOR","text":"","title":"CONDITIONAL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.FALL_THROUGH","text":"","title":"FALL_THROUGH"},{"location":"reference/#ghidralib.RefType.FLOW","text":"","title":"FLOW"},{"location":"reference/#ghidralib.RefType.INDIRECTION","text":"","title":"INDIRECTION"},{"location":"reference/#ghidralib.RefType.INVALID","text":"","title":"INVALID"},{"location":"reference/#ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL","text":"","title":"JUMP_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.JUMP_TERMINATOR","text":"","title":"JUMP_TERMINATOR"},{"location":"reference/#ghidralib.RefType.TERMINATOR","text":"","title":"TERMINATOR"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_CALL","text":"","title":"UNCONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_JUMP","text":"","title":"UNCONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.has_fall","text":"","title":"has_fall"},{"location":"reference/#ghidralib.RefType.is_call","text":"","title":"is_call"},{"location":"reference/#ghidralib.RefType.is_computed","text":"","title":"is_computed"},{"location":"reference/#ghidralib.RefType.is_conditional","text":"","title":"is_conditional"},{"location":"reference/#ghidralib.RefType.is_data","text":"","title":"is_data"},{"location":"reference/#ghidralib.RefType.is_flow","text":"","title":"is_flow"},{"location":"reference/#ghidralib.RefType.is_jump","text":"","title":"is_jump"},{"location":"reference/#ghidralib.RefType.is_override","text":"","title":"is_override"},{"location":"reference/#ghidralib.RefType.is_read","text":"","title":"is_read"},{"location":"reference/#ghidralib.RefType.is_terminal","text":"","title":"is_terminal"},{"location":"reference/#ghidralib.RefType.is_unconditional","text":"","title":"is_unconditional"},{"location":"reference/#ghidralib.RefType.is_write","text":"","title":"is_write"},{"location":"reference/#ghidralib.Reference","text":"Bases: GhidraWrapper Source code in ghidralib.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self . raw . getToAddress () . getOffset () @property def source ( self ): # type: () -> SourceType return SourceType ( self . raw . getSource ())","title":"Reference"},{"location":"reference/#ghidralib.Reference.from_address","text":"Return the address of the source of the reference.","title":"from_address"},{"location":"reference/#ghidralib.Reference.is_call","text":"Return True if the reference is a call.","title":"is_call"},{"location":"reference/#ghidralib.Reference.is_jump","text":"Return True if the reference is a jump.","title":"is_jump"},{"location":"reference/#ghidralib.Reference.reftype","text":"Return the type of reference.","title":"reftype"},{"location":"reference/#ghidralib.Reference.source","text":"","title":"source"},{"location":"reference/#ghidralib.Reference.to_address","text":"Return the address of the target of the reference.","title":"to_address"},{"location":"reference/#ghidralib.Register","text":"Bases: GhidraWrapper Source code in ghidralib.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 class Register ( GhidraWrapper ): @staticmethod def get ( raw_or_name ): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance ( raw_or_name , Str ): raw_or_name = Program . current () . getLanguage () . getRegister ( raw_or_name ) if raw_or_name is None : return None return Register ( raw_or_name ) @property def name ( self ): \"\"\"Return the name of this register\"\"\" return self . raw . getName ()","title":"Register"},{"location":"reference/#ghidralib.Register.name","text":"Return the name of this register","title":"name"},{"location":"reference/#ghidralib.Register.get","text":"Get a register by name Source code in ghidralib.py 629 630 631 632 633 634 635 636 @staticmethod def get ( raw_or_name ): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance ( raw_or_name , Str ): raw_or_name = Program . current () . getLanguage () . getRegister ( raw_or_name ) if raw_or_name is None : return None return Register ( raw_or_name )","title":"get"},{"location":"reference/#ghidralib.Symbol","text":"Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 class Symbol ( GhidraWrapper ): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = Program . current () . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = ( Program . current () . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) ) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program . current () . getSymbolTable () . getAllSymbols ( True ) symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) @staticmethod def remove ( address , name ): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol ( resolve ( address ), name ) @property def address ( self ): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferences ()] xrefs_to = xrefs @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program . create_data ( self . address , datatype ) def delete ( self ): # type: () -> None \"\"\"Delete this symbol.\"\"\" self . raw . delete () def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source )","title":"Symbol"},{"location":"reference/#ghidralib.Symbol.address","text":"Get the address of this symbol.","title":"address"},{"location":"reference/#ghidralib.Symbol.name","text":"Get the name of this symbol.","title":"name"},{"location":"reference/#ghidralib.Symbol.name_with_namespace","text":"Get the fully qualified name of this symbol.","title":"name_with_namespace"},{"location":"reference/#ghidralib.Symbol.xref_addrs","text":"Get the addresses of all references to this symbol.","title":"xref_addrs"},{"location":"reference/#ghidralib.Symbol.xrefs","text":"Get a list of references to this symbol.","title":"xrefs"},{"location":"reference/#ghidralib.Symbol.xrefs_to","text":"","title":"xrefs_to"},{"location":"reference/#ghidralib.Symbol.all","text":"Get all symbols defined in the program. Source code in ghidralib.py 2421 2422 2423 2424 2425 2426 @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program . current () . getSymbolTable () . getAllSymbols ( True ) symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ]","title":"all"},{"location":"reference/#ghidralib.Symbol.create","text":"Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw )","title":"create"},{"location":"reference/#ghidralib.Symbol.delete","text":"Delete this symbol. Source code in ghidralib.py 2479 2480 2481 def delete ( self ): # type: () -> None \"\"\"Delete this symbol.\"\"\" self . raw . delete ()","title":"delete"},{"location":"reference/#ghidralib.Symbol.get","text":"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = Program . current () . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = ( Program . current () . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) ) if not raw : return None else : raw = raw_or_name return Symbol ( raw )","title":"get"},{"location":"reference/#ghidralib.Symbol.remove","text":"Remove the symbol with the given name at the given address. Parameters: address \u2013 the address of the symbol to remove. name \u2013 the name of the symbol to remove. Source code in ghidralib.py 2440 2441 2442 2443 2444 2445 2446 @staticmethod def remove ( address , name ): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol ( resolve ( address ), name )","title":"remove"},{"location":"reference/#ghidralib.Symbol.rename","text":"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source )","title":"rename"},{"location":"reference/#ghidralib.Symbol.set_type","text":"Set the data type of this symbol. Source code in ghidralib.py 2475 2476 2477 def set_type ( self , datatype ): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program . create_data ( self . address , datatype )","title":"set_type"},{"location":"reference/#ghidralib.Variable","text":"Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 class Variable ( GhidraWrapper ): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name ( self ): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self . raw . getName () @name . setter def name ( self , name ): # type: (str) -> None \"\"\"Rename this variable\"\"\" self . rename ( name , SourceType . USER_DEFINED ) def rename ( self , name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self . raw . setName ( name , source ) @property def data_type ( self ): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @data_type . setter def data_type ( self , data_type , source = SourceType . USER_DEFINED ): # type: (DataType, SourceType) -> None \"\"\"Set the data type of this variable\"\"\" self . raw . setDataType ( data_type . raw , source ) @property def is_valid ( self ): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self . raw . isValid () @property def comment ( self ): # type: () -> str|None \"\"\" \"Get the comment for this variable\"\"\" return self . raw . getComment () @comment . setter def comment ( self , name ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . set_comment ( name ) def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) @property def is_auto ( self ): # type: () -> bool \"\"\"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.\"\"\" return self . raw . getVariableStorage () . isAutoStorage () @property def is_forced_indirect ( self ): # type: () -> bool \"\"\"Check if this variable was forced to be a pointer by calling convention\"\"\" return self . raw . getVariableStorage () . isForcedIndirect () @property def has_bad_storage ( self ): # type: () -> bool \"\"\"Check if this variable has bad storage (could not be resolved)\"\"\" return self . raw . getVariableStorage () . isBadStorage () @property def is_unassigned_storage ( self ): # type: () -> bool \"\"\"Check if this variable has no assigned storage (varnodes)\"\"\" return self . raw . getVariableStorage () . isUnassignedStorage () @property def is_void ( self ): # type: () -> bool \"\"\"Check if this variable is of type void\"\"\" return self . raw . getVariableStorage () . isVoidStorage () @property def stack_offfset ( self ): # type: () -> int \"\"\"Get the stack offset of this variable.\"\"\" return self . raw . getVariableStorage () . getStackOffset () @property def is_constant ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single constant-space varnode\"\"\" return self . raw . getVariableStorage () . isConstantStorage () @property def is_hash ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single hash-space varnode.\"\"\" return self . raw . getVariableStorage () . isHashStorage () @property def is_stack ( self ): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol \"\"\"Get the symbol for this variable\"\"\" return Symbol ( self . raw . getSymbol ()) @property def source ( self ): # type: () -> SourceType \"\"\"Get the source type of this variable\"\"\" return SourceType ( self . raw . getSource ()) @property def varnode ( self ): # type: () -> Varnode \"\"\"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.\"\"\" return Varnode ( self . raw . getFirstStorageVarnode ()) @property def varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with this variable.\"\"\" storage = self . raw . getVariableStorage () return [ Varnode ( x ) for x in storage . getVarnodes ()] @property def is_register ( self ): # type: () -> bool \"\"\"Check if this variable consists of a single register.\"\"\" return self . raw . isRegisterVariable () @property def register ( self ): # type: () -> str \"\"\"Get the register associated with this variable. Raises an exception if this variable is not a register variable.\"\"\" reg = self . raw . getRegister () if not reg : raise ValueError ( \"Variable is not a register variable\" ) return reg . getName () @property def function ( self ): # type: () -> Function \"\"\"Get the function associated with this variable.\"\"\" return Function ( self . raw . getFunction ())","title":"Variable"},{"location":"reference/#ghidralib.Variable.comment","text":"\"Get the comment for this variable","title":"comment"},{"location":"reference/#ghidralib.Variable.data_type","text":"Get the data type of this variable","title":"data_type"},{"location":"reference/#ghidralib.Variable.function","text":"Get the function associated with this variable.","title":"function"},{"location":"reference/#ghidralib.Variable.has_bad_storage","text":"Check if this variable has bad storage (could not be resolved)","title":"has_bad_storage"},{"location":"reference/#ghidralib.Variable.is_auto","text":"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.","title":"is_auto"},{"location":"reference/#ghidralib.Variable.is_compound","text":"Check if this variable is a compound variable","title":"is_compound"},{"location":"reference/#ghidralib.Variable.is_constant","text":"Check if this variable consists of a single constant-space varnode","title":"is_constant"},{"location":"reference/#ghidralib.Variable.is_forced_indirect","text":"Check if this variable was forced to be a pointer by calling convention","title":"is_forced_indirect"},{"location":"reference/#ghidralib.Variable.is_hash","text":"Check if this variable consists of a single hash-space varnode.","title":"is_hash"},{"location":"reference/#ghidralib.Variable.is_memory","text":"Check if this variable is stored in memory","title":"is_memory"},{"location":"reference/#ghidralib.Variable.is_register","text":"Check if this variable consists of a single register.","title":"is_register"},{"location":"reference/#ghidralib.Variable.is_stack","text":"Check if this variable is a stack variable","title":"is_stack"},{"location":"reference/#ghidralib.Variable.is_unassigned_storage","text":"Check if this variable has no assigned storage (varnodes)","title":"is_unassigned_storage"},{"location":"reference/#ghidralib.Variable.is_unique","text":"Check if this variable is of type unique","title":"is_unique"},{"location":"reference/#ghidralib.Variable.is_valid","text":"Check if this variable is valid","title":"is_valid"},{"location":"reference/#ghidralib.Variable.is_void","text":"Check if this variable is of type void","title":"is_void"},{"location":"reference/#ghidralib.Variable.name","text":"Get the name of this variable","title":"name"},{"location":"reference/#ghidralib.Variable.register","text":"Get the register associated with this variable. Raises an exception if this variable is not a register variable.","title":"register"},{"location":"reference/#ghidralib.Variable.source","text":"Get the source type of this variable","title":"source"},{"location":"reference/#ghidralib.Variable.stack_offfset","text":"Get the stack offset of this variable.","title":"stack_offfset"},{"location":"reference/#ghidralib.Variable.symbol","text":"Get the symbol for this variable","title":"symbol"},{"location":"reference/#ghidralib.Variable.varnode","text":"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.","title":"varnode"},{"location":"reference/#ghidralib.Variable.varnodes","text":"Get all varnodes associated with this variable.","title":"varnodes"},{"location":"reference/#ghidralib.Variable.rename","text":"Rename this variable Source code in ghidralib.py 1690 1691 1692 1693 1694 def rename ( self , name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self . raw . setName ( name , source )","title":"rename"},{"location":"reference/#ghidralib.Variable.set_comment","text":"Set the comment for this variable Source code in ghidralib.py 1723 1724 1725 def set_comment ( self , comment ): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment )","title":"set_comment"},{"location":"reference/#ghidralib.Varnode","text":"Bases: GhidraWrapper Source code in ghidralib.py 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool \"\"\"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.\"\"\" return self . raw . isRegister () @property def is_named_register ( self ): # type: () -> bool \"\"\" \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.\"\"\" language = Program . current () . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return raw is not None @property def as_register ( self ): # type: () -> str \"\"\"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.\"\"\" language = Program . current () . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return raw . getName () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () @property def is_stack ( self ): # type: () -> bool spaceid = self . raw . getSpace () spacetype = AddressSpace . ID_TYPE_MASK & spaceid return spacetype == AddressSpace . TYPE_STACK def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" ) @property def is_unaffected ( self ): # type: () -> bool return self . raw . isUnaffected () @property def is_persistent ( self ): # type: () -> bool return self . raw . isPersistent () @property def is_addr_tied ( self ): # type: () -> bool return self . raw . isAddrTied () @property def is_input ( self ): # type: () -> bool return self . raw . isInput () @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def defining_pcodeop ( self ): # type: () -> PcodeOp \"\"\"Return a PcodeOp that defined this varnode\"\"\" return PcodeOp ( self . raw . getDef ()) @property def descendants ( self ): # type: () -> list[PcodeOp] \"\"\"Return a list of all descendants of this varnode\"\"\" if self . raw . getDescendants () is None : return [] return [ PcodeOp ( x ) for x in self . raw . getDescendants ()]","title":"Varnode"},{"location":"reference/#ghidralib.Varnode.as_register","text":"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.","title":"as_register"},{"location":"reference/#ghidralib.Varnode.defining_pcodeop","text":"Return a PcodeOp that defined this varnode","title":"defining_pcodeop"},{"location":"reference/#ghidralib.Varnode.descendants","text":"Return a list of all descendants of this varnode","title":"descendants"},{"location":"reference/#ghidralib.Varnode.free","text":"","title":"free"},{"location":"reference/#ghidralib.Varnode.has_value","text":"","title":"has_value"},{"location":"reference/#ghidralib.Varnode.high","text":"","title":"high"},{"location":"reference/#ghidralib.Varnode.is_addr_tied","text":"","title":"is_addr_tied"},{"location":"reference/#ghidralib.Varnode.is_address","text":"","title":"is_address"},{"location":"reference/#ghidralib.Varnode.is_constant","text":"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.","title":"is_constant"},{"location":"reference/#ghidralib.Varnode.is_free","text":"","title":"is_free"},{"location":"reference/#ghidralib.Varnode.is_hash","text":"","title":"is_hash"},{"location":"reference/#ghidralib.Varnode.is_input","text":"","title":"is_input"},{"location":"reference/#ghidralib.Varnode.is_named_register","text":"\"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.","title":"is_named_register"},{"location":"reference/#ghidralib.Varnode.is_persistent","text":"","title":"is_persistent"},{"location":"reference/#ghidralib.Varnode.is_register","text":"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.","title":"is_register"},{"location":"reference/#ghidralib.Varnode.is_stack","text":"","title":"is_stack"},{"location":"reference/#ghidralib.Varnode.is_unaffected","text":"","title":"is_unaffected"},{"location":"reference/#ghidralib.Varnode.is_unique","text":"","title":"is_unique"},{"location":"reference/#ghidralib.Varnode.offset","text":"","title":"offset"},{"location":"reference/#ghidralib.Varnode.simple","text":"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.","title":"simple"},{"location":"reference/#ghidralib.Varnode.size","text":"","title":"size"},{"location":"reference/#ghidralib.Varnode.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.Varnode.value","text":"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.","title":"value"},{"location":"reference/#ghidralib.Varnode.rename","text":"Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 727 728 729 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name )","title":"rename"},{"location":"reference/#ghidralib.assemble_at","text":"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Parameters: address \u2013 the address where to write the instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 def assemble_at ( address , instructions ): # type: (Addr, str|list[str]) -> None \"\"\"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". :param address: the address where to write the instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. address = resolve ( address ) asm = Assemblers . getAssembler ( Program . current ()) asm . assemble ( address , instructions )","title":"assemble_at"},{"location":"reference/#ghidralib.assemble_to_bytes","text":"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is required, because instruction bytes may depend on the location. Parameters: address \u2013 the address to use as a base for instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 def assemble_to_bytes ( address , instructions ): # type: (Addr, str|list[str]) -> str \"\"\"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is required, because instruction bytes may depend on the location. :param address: the address to use as a base for instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr_obj = resolve ( address ) asm = Assemblers . getAssembler ( Program . current ()) if isinstance ( instructions , Str ): return to_bytestring ( asm . assembleLine ( addr_obj , instructions )) result = \"\" for instr in instructions : result += to_bytestring ( asm . assembleLine ( addr_obj . add ( len ( result )), instr )) return result","title":"assemble_to_bytes"},{"location":"reference/#ghidralib.can_resolve","text":"Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py 247 248 249 250 251 252 def can_resolve ( addr ): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance ( addr , ( GenericAddress , int , long , unicode , str ))","title":"can_resolve"},{"location":"reference/#ghidralib.collect_iterator","text":"Collect a Java iterator to a Python list. Source code in ghidralib.py 262 263 264 265 266 267 def collect_iterator ( iterator ): \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result","title":"collect_iterator"},{"location":"reference/#ghidralib.disassemble_at","text":"Disassemble the bytes from the program memory at the given address. If neither max_bytes nor max_instr are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. Parameters: address \u2013 the address where to start disassembling max_bytes \u2013 maximum number of bytes to disassemble (None for no limit) max_instr \u2013 maximum number of instructions to disassemble (None for no limit) Returns: \u2013 a list of Instruction objects Source code in ghidralib.py 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 def disassemble_at ( address , max_bytes = None , max_instr = None ): # type: (Addr, int|None, int|None) -> list[Instruction] \"\"\"Disassemble the bytes from the program memory at the given address. If neither `max_bytes` nor `max_instr` are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. :param address: the address where to start disassembling :param max_bytes: maximum number of bytes to disassemble (None for no limit) :param max_instr: maximum number of instructions to disassemble (None for no limit) :return: a list of Instruction objects\"\"\" address = resolve ( address ) if max_instr is None : _max_instr = 1 if max_bytes is None else max_bytes else : _max_instr = max_instr if max_bytes is None : to_block_end = _get_memory_block ( address ) . getEnd () . subtract ( address ) # Hacky and inefficient, but good enough for now (and correct) _max_bytes = min ( to_block_end , _max_instr * 16 ) else : _max_bytes = max_bytes data = read_bytes ( address , _max_bytes ) return disassemble_bytes ( data , address , _max_instr )","title":"disassemble_at"},{"location":"reference/#ghidralib.disassemble_bytes","text":"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. Parameters: data \u2013 the bytes to disassemble addr \u2013 the (virtual) address of the first instruction max_instr \u2013 the maximum number of instructions to disassemble, or to disassemble until the end of the data Returns: \u2013 a list of Instruction objects Source code in ghidralib.py 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 def disassemble_bytes ( data , addr = 0 , max_instr = None ): # type: (str, Addr, int|None) -> list[Instruction] \"\"\"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. :param data: the bytes to disassemble :param addr: the (virtual) address of the first instruction :param max_instr: the maximum number of instructions to disassemble, or to disassemble until the end of the data :return: a list of Instruction objects\"\"\" dis = PseudoDisassembler ( Program . current ()) offset = 0 result = [] address = resolve ( addr ) if max_instr is None : max_instr = 100000000 for _ in range ( 0 , max_instr ): try : arr = data [ offset : offset + 16 ] rawinstr = dis . disassemble ( address . add ( offset ), arr ) instr = Instruction ( rawinstr ) if offset + instr . length > len ( data ): # Don't append the instruction if it would go past the end of the data break result . append ( instr ) offset += instr . length if offset + instr . length > len ( data ): # Check if we're done break except : break return result","title":"disassemble_bytes"},{"location":"reference/#ghidralib.enhex","text":"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 def enhex ( s ): # type: (str | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if not isinstance ( s , Str ): s = \"\" . join ( chr ( c ) for c in s ) return s . encode ( \"hex\" ) # type: ignore <- py2","title":"enhex"},{"location":"reference/#ghidralib.from_bytes","text":"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py 3324 3325 3326 3327 3328 3329 3330 3331 3332 def from_bytes ( b ): # type: (str | list[int]) -> int \"\"\"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 :param b: byte stream to decode.\"\"\" b = to_bytestring ( b ) return sum ( ord ( v ) << ( i * 8 ) for i , v in enumerate ( b ))","title":"from_bytes"},{"location":"reference/#ghidralib.get_string","text":"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 def get_string ( address ): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None","title":"get_string"},{"location":"reference/#ghidralib.get_unique_string","text":"Get a unique string for a given object. This function is used to convert objects to strings for the graph. The only requirement is that the returned string is unique for each object. Function will just return str(obj) for primitives, and for the rest it will try to return str(obj.address). Parameters: obj \u2013 the object to convert. Source code in ghidralib.py 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 def get_unique_string ( obj ): # type: (object) -> str \"\"\"Get a unique string for a given object. This function is used to convert objects to strings for the graph. The only requirement is that the returned string is unique for each object. Function will just return str(obj) for primitives, and for the rest it will try to return str(obj.address). :param obj: the object to convert.\"\"\" if isinstance ( obj , Str ): return obj elif isinstance ( obj , ( int , long )): return str ( obj ) elif hasattr ( obj , \"address\" ): # So you can define your own way to convert an object to a string. return str ( obj . address ) # type: ignore else : raise TypeError ( \"Cannot convert object {} to string\" . format ( obj ))","title":"get_unique_string"},{"location":"reference/#ghidralib.read_bytes","text":"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 def read_bytes ( address , length ): # type: (Addr, int) -> str \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length ))","title":"read_bytes"},{"location":"reference/#ghidralib.read_cstring","text":"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 def read_cstring ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u8 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 1 ) return string","title":"read_cstring"},{"location":"reference/#ghidralib.read_u16","text":"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3282 3283 3284 3285 3286 3287 3288 3289 def read_u16 ( address ): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 2 ))","title":"read_u16"},{"location":"reference/#ghidralib.read_u32","text":"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3292 3293 3294 3295 3296 3297 3298 3299 def read_u32 ( address ): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 4 ))","title":"read_u32"},{"location":"reference/#ghidralib.read_u64","text":"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3302 3303 3304 3305 3306 3307 3308 3309 def read_u64 ( address ): # type: (Addr) -> int \"\"\"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 8 ))","title":"read_u64"},{"location":"reference/#ghidralib.read_u8","text":"Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 3272 3273 3274 3275 3276 3277 3278 3279 def read_u8 ( address ): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 1 ))","title":"read_u8"},{"location":"reference/#ghidralib.read_unicode","text":"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 def read_unicode ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve ( address ) string = \"\" while True : c = read_u16 ( addr ) if c == 0 : break string += chr ( c ) addr = addr . add ( 2 ) return string","title":"read_unicode"},{"location":"reference/#ghidralib.resolve","text":"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def resolve ( addr ): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance ( addr , unicode ): # Why, Ghidra? addr = addr . encode () if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) raise TypeError ( \"Address must be a ghidra Address, int, or str\" )","title":"resolve"},{"location":"reference/#ghidralib.resolve_to_int","text":"Convert an addressable value to an integer representation. Source code in ghidralib.py 242 243 244 def resolve_to_int ( addr ): # type: (Addr) -> int \"\"\"Convert an addressable value to an integer representation.\"\"\" return resolve ( addr ) . getOffset ()","title":"resolve_to_int"},{"location":"reference/#ghidralib.to_bytes","text":"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\x01\\x02' Parameters: value \u2013 integer to encode. length \u2013 number of bytes of the result. Source code in ghidralib.py 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 def to_bytes ( value , length ): # type: (int, int) -> str \"\"\"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\\\x01\\\\x02' :param value: integer to encode. :param length: number of bytes of the result.\"\"\" out = \"\" for i in range ( length ): out += chr ( value & 0xFF ) value >>= 8 return out","title":"to_bytes"},{"location":"reference/#ghidralib.to_bytestring","text":"Ensure the passed value is a bytestring. This is used to convert java byte arrays to a proper python bytestring. Source code in ghidralib.py 3093 3094 3095 3096 3097 3098 3099 def to_bytestring ( val ): # type: (str | list[int]) -> str \"\"\"Ensure the passed value is a bytestring. This is used to convert java byte arrays to a proper python bytestring.\"\"\" if not isinstance ( val , Str ): return \"\" . join ( chr ( i % 256 ) for i in val ) return val","title":"to_bytestring"},{"location":"reference/#ghidralib.try_resolve","text":"Convert an arbitrary addressable value to a Ghidra Address object. See resolve documentation for more details. Source code in ghidralib.py 232 233 234 235 236 237 238 239 def try_resolve ( addr ): # type: (Addr) -> GenericAddress | None \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. See `resolve` documentation for more details.\"\"\" try : return resolve ( addr ) except : return None","title":"try_resolve"},{"location":"reference/#ghidralib.unhex","text":"Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py 3350 3351 3352 3353 3354 3355 3356 3357 def unhex ( s ): # type: (str) -> str \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return s . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) . decode ( \"hex\" ) # type: ignore <- py2","title":"unhex"},{"location":"reference/#ghidralib.unwrap","text":"If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py 255 256 257 258 259 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type","title":"unwrap"},{"location":"reference/#ghidralib.xor","text":"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 def xor ( a , b ): # type: (str, str) -> str \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\\\x01\\\\x02\", \"\\\\x03\\\\x04\") '\\\\x02\\\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"xor"}]}