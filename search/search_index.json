{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ghidralib Welcome to ghidralib documentation! This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args)) Basic Usage To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. A tutorial describing specific features is in development. Finished chapters include: Getting Started , with a brief description of useful API functions (recommended). Emulator If you prefer to learn by example, you can browse the examples . You can find the autogenerated API documentation here . When in doubt, check out the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it? Current compatibility status is documented here .","title":"Ghidralib"},{"location":"#ghidralib","text":"","title":"Ghidralib"},{"location":"#welcome-to-ghidralib-documentation","text":"This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args))","title":"Welcome to ghidralib documentation!"},{"location":"#basic-usage","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. A tutorial describing specific features is in development. Finished chapters include: Getting Started , with a brief description of useful API functions (recommended). Emulator If you prefer to learn by example, you can browse the examples . You can find the autogenerated API documentation here . When in doubt, check out the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it? Current compatibility status is documented here .","title":"Basic Usage"},{"location":"compatibility/","text":"Compatibility This library uses unstable Ghidra APIs, so it's expected to break from time to time (when Ghidra changes internal implementation details). In this document I'll keep track of the compatibility status of the library. I don't to backport fixes and do complex hacks to support more than one Ghidra version at once. Instead, for each Ghidra version I'll try to provide a working ghidralib version. Keep in mind, that this library is still in rapid development, and the API may and will change before we reach the first stable release (v1.0). Compatibility matrix Here is a compatibility matrix of tested Ghidra and ghidralib versions: ghidralib \\ ghidra 11.2.1 11.3 (dev) 0.1.0 \u2705 0.2.0 \u2705 \u2705 (Compatibility is checked by running a testsuite on a test binary) Architectures I work almost exclusively on x86 and x86_64, so the library is tested on these architectures. There is nothing specific to x86 in the code, but I expect that some exotic architectures will not work correctly. Freel free to submit issues/PRs if you find something is broken. Python 3 Basic Python 3 (PyGhidra) is implemented. Right now it's unstable. Known problems: It will only work on the program you had open when you loaded ghidralib. To switch to another program, del sys.modules[\"ghidralib\"] and import again. I don't personally use Ghidrathon, so I didn't test Ghidrathon compatibility.","title":"Compatibility"},{"location":"compatibility/#compatibility","text":"This library uses unstable Ghidra APIs, so it's expected to break from time to time (when Ghidra changes internal implementation details). In this document I'll keep track of the compatibility status of the library. I don't to backport fixes and do complex hacks to support more than one Ghidra version at once. Instead, for each Ghidra version I'll try to provide a working ghidralib version. Keep in mind, that this library is still in rapid development, and the API may and will change before we reach the first stable release (v1.0).","title":"Compatibility"},{"location":"compatibility/#compatibility-matrix","text":"Here is a compatibility matrix of tested Ghidra and ghidralib versions: ghidralib \\ ghidra 11.2.1 11.3 (dev) 0.1.0 \u2705 0.2.0 \u2705 \u2705 (Compatibility is checked by running a testsuite on a test binary)","title":"Compatibility matrix"},{"location":"compatibility/#architectures","text":"I work almost exclusively on x86 and x86_64, so the library is tested on these architectures. There is nothing specific to x86 in the code, but I expect that some exotic architectures will not work correctly. Freel free to submit issues/PRs if you find something is broken.","title":"Architectures"},{"location":"compatibility/#python-3","text":"Basic Python 3 (PyGhidra) is implemented. Right now it's unstable. Known problems: It will only work on the program you had open when you loaded ghidralib. To switch to another program, del sys.modules[\"ghidralib\"] and import again. I don't personally use Ghidrathon, so I didn't test Ghidrathon compatibility.","title":"Python 3"},{"location":"emulator/","text":"Emulator Ghidra features a powerful PCode emulator, which can be used to emulate whole functions or pieces of code. Ghidralib wraps this emulator with a class called Emulator . The basic usage is as follows: emu = Emulator() emu.emulate(0x400000, 0x400010) print(emu[\"eax\"]) Basics Looks easy enough, now let's try it in practice. Create and compile a following C program: #include <stdio.h> #include <stdlib.h> int hash(int value) { return (value * 10) + (value ^ 7); } void check(int value) { if (hash(value) == 189) { printf(\"Success!\"); } } int main(int argc, char *argv[]) { if (argc != 2) { return 1; } check(atoi(argv[1])); return 0; } Compile it with gcc -O0 test.c -o test . Make sure to disable optimisation with -O0 , so the functions are not optimized out. Now load this program to Ghidra, and open interactive console. And check that everything is in order: >>> from ghidralib import * >>> print(hex(Function(\"main\").address)) 0x401190 >>> print(hex(Function(\"check\").address)) 0x401159 >>> print(hex(Function(\"hash\").address)) 0x401136 Now the main point, let's try the Emulator. We may want to emulate the hash function to check how it behaves. For emulation we need a start and end address. You can copy it from the listing view, but for the demonstration I will print that with python too: hash_function = Function(\"hash\") >>> for instr in hash_function.instructions: ... print(\"0x{:x} {}\".format(instr.address, instr)) ... 0x401136 PUSH RBP 0x401137 MOV RBP,RSP 0x40113a MOV dword ptr [RBP + -0x4],EDI 0x40113d MOV EDX,dword ptr [RBP + -0x4] 0x401140 MOV EAX,EDX 0x401142 SHL EAX,0x2 0x401145 ADD EAX,EDX 0x401147 ADD EAX,EAX 0x401149 MOV EDX,EAX 0x40114b MOV EAX,dword ptr [RBP + -0x4] 0x40114e XOR EAX,0x7 0x401151 ADD EAX,EDX 0x401153 POP RBP 0x401154 XOR EDX,EDX 0x401156 XOR EDI,EDI 0x401158 RET Note : we assume Linux x64 ABI everywhere. If you're on Windows or another architecture, you'll need to adjust the code (especially register names). So we want to emulate between 0x401136 and 0x401158, and the parameter is in EDI. >>> emu = Emulator() >>> emu[\"RDI\"] = 10 # We asume Linux x64 ABI >>> emu.emulate(0x401136, 0x401158) >>> print(emu[\"RAX\"]) 113 Great, we successfully emulated our first function. Instead of using hardcoded addresses, it's usually easier to use object attributes. This is equivalent: >>> emu = Emulator() >>> emu[\"RDI\"] = 10 >>> emu.emulate(hash_function.address, hash_function.exitpoints) >>> print(emu[\"RAX\"]) 113 Function.exitpoints is a list that contains all function exit points - perfect for our use-case here. By the way, instead of indexing like emu[\"EAX\"] you can use emu.read_register and emu.write_register . Consider using the more verbose format when writing reusable scripts, but emu[\"EAX\"] is faster to type when working interactively. Hooks Often we are interested in the details of the execution, and we want to process every instruction in some way. We can easily do this using the callback parameter: >>> emu = Emulator() >>> def print_callback(emu): ... instr = Instruction(emu.pc) ... print(\"executing 0x{:x} {}\".format(emu.pc, instr)) >>> emu.emulate(hash_function.address, hash_function.exitpoints, callback=print_callback) executing 0x401136 PUSH RBP executing 0x401137 MOV RBP,RSP executing 0x40113a MOV dword ptr [RBP + -0x4],EDI executing 0x40113d MOV EDX,dword ptr [RBP + -0x4] executing 0x401140 MOV EAX,EDX executing 0x401142 SHL EAX,0x2 executing 0x401145 ADD EAX,EDX executing 0x401147 ADD EAX,EAX executing 0x401149 MOV EDX,EAX executing 0x40114b MOV EAX,dword ptr [RBP + -0x4] executing 0x40114e XOR EAX,0x7 executing 0x401151 ADD EAX,EDX executing 0x401153 POP RBP executing 0x401154 XOR EDX,EDX executing 0x401156 XOR EDI,EDI You can change the emulator context in the hook, and you can control the execution using the callback return value. In particular, you can return: continue to continue execution normally (this is the default) break to stop execution immediately continue_then_break to stop execution after executing the current instruction skip to skip the current instruction and execute the one immediately after it retry means that emulator should try to execute the same instruction again. This is only useful if you changed PC in the callback and want to reevaluate it. So for example, instead of providing the return address directly you can execute until the ret instruction: >>> emu = Emulator() >>> def execute_until_ret(emu): ... instr = Instruction(emu.pc) ... if instr.mnemonic == \"RET\": ... return \"break\" ... return \"continue\" >>> emu[\"RDI\"] = 10 >>> emu.emulate(hash_function.address, callback=execute_until_ret) >>> print(emu[\"RAX\"]) 113 By the way, as a reminder, you can use a symbol name almost everywhere instead of an address. For example, hash_function.address is equivalent to \"hash\" and you can as well do >>> emu.emulate(\"hash\", callback=execute_until_ret) This is probably not a good idea in serious scripts, but it's a nice trick for quick hacks. Exercise : Use your knowledge of the emulator to find a value that will make the hash function return 189. Hint: emulate hash in a for loop and check the return value. Hooks and external functions Another thing we can do with hooks is dealing with calls . For example, check function looks like this: >>> for instr in Function(\"check\").instructions: ... print(\"0x{:x} {}\".format(instr.address, instr)) ... 0x401159 PUSH RBP 0x40115a MOV RBP,RSP 0x40115d SUB RSP,0x10 0x401161 MOV dword ptr [RBP + -0x4],EDI 0x401164 MOV EAX,dword ptr [RBP + -0x4] 0x401167 MOV EDI,EAX 0x401169 CALL 0x00401136 0x40116e CMP EAX,0xbd 0x401173 JNZ 0x00401189 0x401175 LEA RAX,[0x402004] 0x40117c MOV RDI,RAX 0x40117f MOV EAX,0x0 0x401184 CALL 0x00401030 0x401189 NOP 0x40118a LEAVE 0x40118b XOR EAX,EAX 0x40118d XOR EDI,EDI 0x40118f RET The first call is to hash function, but the second one is to printf . We can't easily emulate this function, because it's outside of the current program. To avoid crashing the emulation, we can use the hook to skip the calls: >>> check_function = Function(\"check\") >>> def skip_calls(emu): ... instr = Instruction(emu.pc) ... if instr.mnemonic == \"CALL\": ... return \"skip\" ... return \"continue\" But let's do something else: let's emulate check function until the CALL hash instruction, but skip the call and just return 189 directly. Then emulate until the CALL printf instruction, and print the parameter passed to printf . The callback gets more complicated now: >>> def emulate_check(emu): ... instr = Instruction(emu.pc) ... if instr.address == 0x401169: ... emu[\"RAX\"] = 189 ... return \"skip\" ... if instr.address == 0x401184: ... string_addr = emu[\"RDI\"] # cstring parameter is in RDI (linux ABI) ... print(emu.read_cstring(string_addr)) ... return \"break\" >>> check_function = Function(\"check\") >>> emu = Emulator() >>> emu.emulate(check_function.address, callback=emulate_check) Success! We successfully \"tricked\" the check function into executing the \"success\" branch and trying to print the Success! string. But this code is not very nice. We can use emulator hooks to make it clearer. Hooks are pieces of code that can be automatically executed at certain points during emulation. You can register a hook for a specific address: def printf_hook(emu): arg = emu.read_cstring(emu[\"RDI\"]) print(\"printf called with '{}'\".format(arg)) return \"break\" def hash_hook(emu): # Note that we are already in the called function, so we need to jump # to return address manually, and update the stack pointer appropriately. emu[\"RAX\"] = 189 emu.pc = emu.read_u64(emu.sp) emu.sp += 8 emu = Emulator() emu.add_hook(\"printf\", printf_hook) emu.add_hook(\"hash\", hash_hook) emu.emulate(\"check\") Note that we again (ab)use automatic symbol resolution here. The last three lines are equivalent to: emu.add_hook(Symbol(\"printf\").address, printf_hook) emu.add_hook(Symbol(\"hash\").address, hash_hook) emu.emulate(Symbol(\"check\").address) Exercise : Create a hook for atoi function that will simulate the libc function - it should parse the string from the parameter and return it in RAX. Test it by emulating the \"call atoi\" instruction with a string parameter. State inspection Of course, after emulation we are interested in the final state of the emulator. We already showcased reading and writing registers, and we used read_cstring function in the hook. There are also other useful functions: emu.read_register(reg) and emu.write_register(reg, val) - read or write a register emu[reg] and emu[reg] = val - read or write a register, short version emu.read_u64(addr) and emu.write_u64(addr, val) - read or write a 64-bit value at a given address emu.read_u32(addr) and emu.write_u32(addr, val) - read or write a 32-bit value at a given address emu.read_u16(addr) and emu.write_u16(addr, val) - read or write a 16-bit value at a given address emu.read_u8(addr) and emu.write_u8(addr, val) - read or write an 8-bit value at a given address emu.read_bytes(addr, size) - read size bytes from addr emu.write_bytes(addr, bytes) - write the given bytes to addr emu.read_cstring(addr) - read bytes starting from addr until a null byte is found. emu.read_unicode(addr) - read 16bit chars starting from addr until a null character is found. emu.read_varnode and emu.write_varnode - read or write a varnode They should all be self-explanatory, except the last one. Varnodes are a Ghidra term for an almost arbitrary value. In particular, Function signature contains information about how variables and parameters map to varnodes: >>> Function(\"hash\").return_variable [int <RETURN>@EAX:4] >>> Function(\"hash\").return_variable.varnode (register, 0x0, 4) >>> Function(\"hash\").parameters [[uint param_1@EDI:4]] >>> Function(\"hash\").parameters[0].varnode (register, 0x38, 4) You can use read_varnode and write_varnode to manipulate these values in a pretty generic way. For example, this is levaraged by Function.emulate , to emulate functions in a very generic way: >>> Function(\"hash\").emulate_simple(10) 113 It doesn't get any easier than that. The simple in the name refers to the return value - in many cases you will want to use Function.emulate to get the whole context of the emulator after execution. >>> emu = Function(\"hash\").emulate(10) >>> emu[\"RAX\"] 113 Exercise : Complete the atoi hook from the previous exercise first. Then create an emulator, add printf and atoi hooks, and execute a main function with the correct parameters. This will require you to pass correct argc and argv parameters. Misc features maxsteps When you emulate a function, you may want to limit the number of steps it can take: >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}\".format(emu.pc)) >>> emu.trace(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Especially if you're emulatingh random pieces of code, setting maxsteps to something reasonable (like 2000 instructions) may save you from accidentaly executing an infinite loops. Breakpoints You can set and remove breakpoints using add_breakpoint and clear_breakpoint methods emulate_fast Ghidra emulator is not very fast, but ghidralib emulate is even slower - because we support callbacks, we need to go back and forth between Python and Java. To make things faster, you can use the emulate_fast function. It keeps the main loop of the emulation in Java, which may matter in some cases. The downside is that it doesn't support callbacks or instruction counting - you can only emulate until a specific address. As an upside, function hooks are supprted. Emulation shorthands To save precious keystrokes you may combine creating an emulator, running it, and inspecting the result into one step with: >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This convenience wrapper is equivalent to the following code: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 Some other objects also provide helpers to do the obvious thing with emulator. For example, you can emulate a function call with: >>> emu = Function(\"test\").emulate(10) >>> emu[\"EAX\"] 113 >>> # Or an even shorter version >>> Function(\"test\").emulate_simple(10) 113 Unicorn compatibility There is a very, very thin compatibility layer with Unicorn. There are aliases provided for the following Unicorn methods: reg_write , reg_read , mem_write , mem_read , mem_map , emu_start . Why? The idea is that many people already know Unicorn. It may make it a tiny bit easier for them if they can use familiar method names instead of learning a completely new set. The goal is not to provide actual compatibility layer - Unicorn is a very different library and ghidralib won't replace it. The only goal is really so Unicorn users can use familiar names if they forget ghidralib equivalents. If you are not an Unicorn user, don't use them. Learn more Check out relevant examples in the examples directory, especially: EmulatorHooks.py ContextRecovery.py LummaPatternBasedDeobfuscation.py","title":"Emulator"},{"location":"emulator/#emulator","text":"Ghidra features a powerful PCode emulator, which can be used to emulate whole functions or pieces of code. Ghidralib wraps this emulator with a class called Emulator . The basic usage is as follows: emu = Emulator() emu.emulate(0x400000, 0x400010) print(emu[\"eax\"])","title":"Emulator"},{"location":"emulator/#basics","text":"Looks easy enough, now let's try it in practice. Create and compile a following C program: #include <stdio.h> #include <stdlib.h> int hash(int value) { return (value * 10) + (value ^ 7); } void check(int value) { if (hash(value) == 189) { printf(\"Success!\"); } } int main(int argc, char *argv[]) { if (argc != 2) { return 1; } check(atoi(argv[1])); return 0; } Compile it with gcc -O0 test.c -o test . Make sure to disable optimisation with -O0 , so the functions are not optimized out. Now load this program to Ghidra, and open interactive console. And check that everything is in order: >>> from ghidralib import * >>> print(hex(Function(\"main\").address)) 0x401190 >>> print(hex(Function(\"check\").address)) 0x401159 >>> print(hex(Function(\"hash\").address)) 0x401136 Now the main point, let's try the Emulator. We may want to emulate the hash function to check how it behaves. For emulation we need a start and end address. You can copy it from the listing view, but for the demonstration I will print that with python too: hash_function = Function(\"hash\") >>> for instr in hash_function.instructions: ... print(\"0x{:x} {}\".format(instr.address, instr)) ... 0x401136 PUSH RBP 0x401137 MOV RBP,RSP 0x40113a MOV dword ptr [RBP + -0x4],EDI 0x40113d MOV EDX,dword ptr [RBP + -0x4] 0x401140 MOV EAX,EDX 0x401142 SHL EAX,0x2 0x401145 ADD EAX,EDX 0x401147 ADD EAX,EAX 0x401149 MOV EDX,EAX 0x40114b MOV EAX,dword ptr [RBP + -0x4] 0x40114e XOR EAX,0x7 0x401151 ADD EAX,EDX 0x401153 POP RBP 0x401154 XOR EDX,EDX 0x401156 XOR EDI,EDI 0x401158 RET Note : we assume Linux x64 ABI everywhere. If you're on Windows or another architecture, you'll need to adjust the code (especially register names). So we want to emulate between 0x401136 and 0x401158, and the parameter is in EDI. >>> emu = Emulator() >>> emu[\"RDI\"] = 10 # We asume Linux x64 ABI >>> emu.emulate(0x401136, 0x401158) >>> print(emu[\"RAX\"]) 113 Great, we successfully emulated our first function. Instead of using hardcoded addresses, it's usually easier to use object attributes. This is equivalent: >>> emu = Emulator() >>> emu[\"RDI\"] = 10 >>> emu.emulate(hash_function.address, hash_function.exitpoints) >>> print(emu[\"RAX\"]) 113 Function.exitpoints is a list that contains all function exit points - perfect for our use-case here. By the way, instead of indexing like emu[\"EAX\"] you can use emu.read_register and emu.write_register . Consider using the more verbose format when writing reusable scripts, but emu[\"EAX\"] is faster to type when working interactively.","title":"Basics"},{"location":"emulator/#hooks","text":"Often we are interested in the details of the execution, and we want to process every instruction in some way. We can easily do this using the callback parameter: >>> emu = Emulator() >>> def print_callback(emu): ... instr = Instruction(emu.pc) ... print(\"executing 0x{:x} {}\".format(emu.pc, instr)) >>> emu.emulate(hash_function.address, hash_function.exitpoints, callback=print_callback) executing 0x401136 PUSH RBP executing 0x401137 MOV RBP,RSP executing 0x40113a MOV dword ptr [RBP + -0x4],EDI executing 0x40113d MOV EDX,dword ptr [RBP + -0x4] executing 0x401140 MOV EAX,EDX executing 0x401142 SHL EAX,0x2 executing 0x401145 ADD EAX,EDX executing 0x401147 ADD EAX,EAX executing 0x401149 MOV EDX,EAX executing 0x40114b MOV EAX,dword ptr [RBP + -0x4] executing 0x40114e XOR EAX,0x7 executing 0x401151 ADD EAX,EDX executing 0x401153 POP RBP executing 0x401154 XOR EDX,EDX executing 0x401156 XOR EDI,EDI You can change the emulator context in the hook, and you can control the execution using the callback return value. In particular, you can return: continue to continue execution normally (this is the default) break to stop execution immediately continue_then_break to stop execution after executing the current instruction skip to skip the current instruction and execute the one immediately after it retry means that emulator should try to execute the same instruction again. This is only useful if you changed PC in the callback and want to reevaluate it. So for example, instead of providing the return address directly you can execute until the ret instruction: >>> emu = Emulator() >>> def execute_until_ret(emu): ... instr = Instruction(emu.pc) ... if instr.mnemonic == \"RET\": ... return \"break\" ... return \"continue\" >>> emu[\"RDI\"] = 10 >>> emu.emulate(hash_function.address, callback=execute_until_ret) >>> print(emu[\"RAX\"]) 113 By the way, as a reminder, you can use a symbol name almost everywhere instead of an address. For example, hash_function.address is equivalent to \"hash\" and you can as well do >>> emu.emulate(\"hash\", callback=execute_until_ret) This is probably not a good idea in serious scripts, but it's a nice trick for quick hacks. Exercise : Use your knowledge of the emulator to find a value that will make the hash function return 189. Hint: emulate hash in a for loop and check the return value.","title":"Hooks"},{"location":"emulator/#hooks-and-external-functions","text":"Another thing we can do with hooks is dealing with calls . For example, check function looks like this: >>> for instr in Function(\"check\").instructions: ... print(\"0x{:x} {}\".format(instr.address, instr)) ... 0x401159 PUSH RBP 0x40115a MOV RBP,RSP 0x40115d SUB RSP,0x10 0x401161 MOV dword ptr [RBP + -0x4],EDI 0x401164 MOV EAX,dword ptr [RBP + -0x4] 0x401167 MOV EDI,EAX 0x401169 CALL 0x00401136 0x40116e CMP EAX,0xbd 0x401173 JNZ 0x00401189 0x401175 LEA RAX,[0x402004] 0x40117c MOV RDI,RAX 0x40117f MOV EAX,0x0 0x401184 CALL 0x00401030 0x401189 NOP 0x40118a LEAVE 0x40118b XOR EAX,EAX 0x40118d XOR EDI,EDI 0x40118f RET The first call is to hash function, but the second one is to printf . We can't easily emulate this function, because it's outside of the current program. To avoid crashing the emulation, we can use the hook to skip the calls: >>> check_function = Function(\"check\") >>> def skip_calls(emu): ... instr = Instruction(emu.pc) ... if instr.mnemonic == \"CALL\": ... return \"skip\" ... return \"continue\" But let's do something else: let's emulate check function until the CALL hash instruction, but skip the call and just return 189 directly. Then emulate until the CALL printf instruction, and print the parameter passed to printf . The callback gets more complicated now: >>> def emulate_check(emu): ... instr = Instruction(emu.pc) ... if instr.address == 0x401169: ... emu[\"RAX\"] = 189 ... return \"skip\" ... if instr.address == 0x401184: ... string_addr = emu[\"RDI\"] # cstring parameter is in RDI (linux ABI) ... print(emu.read_cstring(string_addr)) ... return \"break\" >>> check_function = Function(\"check\") >>> emu = Emulator() >>> emu.emulate(check_function.address, callback=emulate_check) Success! We successfully \"tricked\" the check function into executing the \"success\" branch and trying to print the Success! string. But this code is not very nice. We can use emulator hooks to make it clearer. Hooks are pieces of code that can be automatically executed at certain points during emulation. You can register a hook for a specific address: def printf_hook(emu): arg = emu.read_cstring(emu[\"RDI\"]) print(\"printf called with '{}'\".format(arg)) return \"break\" def hash_hook(emu): # Note that we are already in the called function, so we need to jump # to return address manually, and update the stack pointer appropriately. emu[\"RAX\"] = 189 emu.pc = emu.read_u64(emu.sp) emu.sp += 8 emu = Emulator() emu.add_hook(\"printf\", printf_hook) emu.add_hook(\"hash\", hash_hook) emu.emulate(\"check\") Note that we again (ab)use automatic symbol resolution here. The last three lines are equivalent to: emu.add_hook(Symbol(\"printf\").address, printf_hook) emu.add_hook(Symbol(\"hash\").address, hash_hook) emu.emulate(Symbol(\"check\").address) Exercise : Create a hook for atoi function that will simulate the libc function - it should parse the string from the parameter and return it in RAX. Test it by emulating the \"call atoi\" instruction with a string parameter.","title":"Hooks and external functions"},{"location":"emulator/#state-inspection","text":"Of course, after emulation we are interested in the final state of the emulator. We already showcased reading and writing registers, and we used read_cstring function in the hook. There are also other useful functions: emu.read_register(reg) and emu.write_register(reg, val) - read or write a register emu[reg] and emu[reg] = val - read or write a register, short version emu.read_u64(addr) and emu.write_u64(addr, val) - read or write a 64-bit value at a given address emu.read_u32(addr) and emu.write_u32(addr, val) - read or write a 32-bit value at a given address emu.read_u16(addr) and emu.write_u16(addr, val) - read or write a 16-bit value at a given address emu.read_u8(addr) and emu.write_u8(addr, val) - read or write an 8-bit value at a given address emu.read_bytes(addr, size) - read size bytes from addr emu.write_bytes(addr, bytes) - write the given bytes to addr emu.read_cstring(addr) - read bytes starting from addr until a null byte is found. emu.read_unicode(addr) - read 16bit chars starting from addr until a null character is found. emu.read_varnode and emu.write_varnode - read or write a varnode They should all be self-explanatory, except the last one. Varnodes are a Ghidra term for an almost arbitrary value. In particular, Function signature contains information about how variables and parameters map to varnodes: >>> Function(\"hash\").return_variable [int <RETURN>@EAX:4] >>> Function(\"hash\").return_variable.varnode (register, 0x0, 4) >>> Function(\"hash\").parameters [[uint param_1@EDI:4]] >>> Function(\"hash\").parameters[0].varnode (register, 0x38, 4) You can use read_varnode and write_varnode to manipulate these values in a pretty generic way. For example, this is levaraged by Function.emulate , to emulate functions in a very generic way: >>> Function(\"hash\").emulate_simple(10) 113 It doesn't get any easier than that. The simple in the name refers to the return value - in many cases you will want to use Function.emulate to get the whole context of the emulator after execution. >>> emu = Function(\"hash\").emulate(10) >>> emu[\"RAX\"] 113 Exercise : Complete the atoi hook from the previous exercise first. Then create an emulator, add printf and atoi hooks, and execute a main function with the correct parameters. This will require you to pass correct argc and argv parameters.","title":"State inspection"},{"location":"emulator/#misc-features","text":"maxsteps When you emulate a function, you may want to limit the number of steps it can take: >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}\".format(emu.pc)) >>> emu.trace(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Especially if you're emulatingh random pieces of code, setting maxsteps to something reasonable (like 2000 instructions) may save you from accidentaly executing an infinite loops. Breakpoints You can set and remove breakpoints using add_breakpoint and clear_breakpoint methods emulate_fast Ghidra emulator is not very fast, but ghidralib emulate is even slower - because we support callbacks, we need to go back and forth between Python and Java. To make things faster, you can use the emulate_fast function. It keeps the main loop of the emulation in Java, which may matter in some cases. The downside is that it doesn't support callbacks or instruction counting - you can only emulate until a specific address. As an upside, function hooks are supprted. Emulation shorthands To save precious keystrokes you may combine creating an emulator, running it, and inspecting the result into one step with: >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This convenience wrapper is equivalent to the following code: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 Some other objects also provide helpers to do the obvious thing with emulator. For example, you can emulate a function call with: >>> emu = Function(\"test\").emulate(10) >>> emu[\"EAX\"] 113 >>> # Or an even shorter version >>> Function(\"test\").emulate_simple(10) 113 Unicorn compatibility There is a very, very thin compatibility layer with Unicorn. There are aliases provided for the following Unicorn methods: reg_write , reg_read , mem_write , mem_read , mem_map , emu_start . Why? The idea is that many people already know Unicorn. It may make it a tiny bit easier for them if they can use familiar method names instead of learning a completely new set. The goal is not to provide actual compatibility layer - Unicorn is a very different library and ghidralib won't replace it. The only goal is really so Unicorn users can use familiar names if they forget ghidralib equivalents. If you are not an Unicorn user, don't use them.","title":"Misc features"},{"location":"emulator/#learn-more","text":"Check out relevant examples in the examples directory, especially: EmulatorHooks.py ContextRecovery.py LummaPatternBasedDeobfuscation.py","title":"Learn more"},{"location":"getting_started/","text":"Getting Started This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. If you prefer to learn by example, check out the examples directory , or the tests . For a more complete reference, see the API documentation . Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier. IDE configuration I strongly recommend using an IDE that supports type-checking. Installation To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. Main actors A lot of objects are wrapped by this library. The most important at the beginning are: Function - a function recognised by Ghidra Instruction - assembly instruction DataType - a configured data type Symbol - a named address (also called a label) Function A function is a named block of code. Not all code in Ghidra belongs to a function, but being in a function makes it easier to reason about - for example, we can talk about parameters, variables, return values, etc. Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Print high variables in main function # These are the variables as seen by decompiler - the ones # that one thinks about when reversing print(Function(\"main\").high_variables) # Get the control flow graph of the main function... # ...and show it! (you can also do something more useful with it) Function(\"main\").control_flow.show() # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Use symbolic execution to infer values of eax and edx at each call site for call in Function(\"MyCustomCrypto\").calls: ctx = call.infer_context() key, data = ctx[\"eax\"], ctx[\"edx\"] print(key, data) # Infer parameters for each call to this function (using the decmopiler) for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) # Rename functions calling this function for caller in Function(\"MyCustomCrypto\").callers: # Use caller address as a suffix. It's often useful to combine this with # emulation, so you can put more context in the name. caller.rename(\"CallsCustomCrypto_{}\".format(caller.address)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) # Use Ghidra's SymbolicPropagator to get known register values ctx = Function(0x401000).symbolic_context() print(ctx.register_at(0x401020, \"eax\")) Read more in the Function object documentation . Instruction Instructions represent a single assembly operation. They have a mnemonic (e.g. mov ), operands (e.g. eax, 3 ), and a pcode representation used for further analysis. Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation . DataType Data types are used to describe the structure of data in memory. Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) # You can also create structures from C code strings: foo = DataType.from_c('struct foo { int a; int b; };') Read more in the DataType object documentation . Symbol Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(\"funniner_\" + symbol.name\") Read more in the Symbol object documentation . Working at various abstraction levels In this section I'll briefly summarize ghidralib objects that you can use to work at various abstraction levels. Assembly instructions - at the lowest level, there is assembler. You will use familiar Instruction , BasicBlock and Function . When analysing data, you will think in terms of Register s of Variables , and references are in terms of Symbols . Pcode instructions - here you think in terms of PcodeOp s, and PcodeBlocks . You still work with Functions , but the data flows between architecture-independent Varnodes now instead. High Pcode instructions - after the decompilation, many things change. You stil work with PcodeOps , but they are significantly transformed - referred as \"High Pcode\" in this library. You now think in terms of High Functions , High Variables , and High Symbols . Even Varnodes are now slightly more powerful (under the hood they are VarnodeASTs now). Pcode syntax tree ( Function.pcode_tree ) - As far as I know, there was no easy way to work with it. I hope ghidralib makes this much easier. On this level, you still have high PcodeOps , but syntactic elements like \"dowhile\" loops, \"if\" statements etc, are now recovered and you can traverse the syntax tree (while still dealing with PcodeOps ). C abstract syntax tree (AST) - built internally by the decompiler, but not exported by Ghidra. I hope to add support for it in ghidralib one way or another, but for now there is no way to access it. Clang tokens ( Function.tokens ) - a stream of tokens that represent the C code. It is very detailed, to the level that it contains even whitespace. You can clean them up, but the data is still overprocessed a bit too much, and not useful (IMO) during analysis. Ghidra uses it for display. Showcase In this section I'll present a few examples of impressive-but-not-necessarily-useful things you can do with ghidralib. Emulation Emulate the program from 0x400300 to 0x400400. When finished, read the value of eax and the memory at 0x401000. # Create a new emulator and execute code between 0x400300 and 0x400400 emu = Emulator() emu.emulate(0x400300, 0x400400) print(emu[\"eax\"]) print(emu.read_bytes(0x401000, 16)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) In practice you can often use this for recovering obfuscated strings, or unpacking simple packers. Graphs # Get the control flow graph of the main function (and display it) Function(\"main\").control_flow.show() Graph visualisation is not the most useful feature of this library, but it looks cool: And you can easily build the graph yourself: g = Graph.create() foo = g.vertex(\"foo\") bar = g.vertex(\"bar\") g.edge(foo, bar) g.show() Or you can do some actually useful things with included graph algorithms (DFS, BFS, and topological sort) - like tracing paths between functions. Path finding Find the shortest path from source to target in the program control flow graph. If it exists, highlight all basic blocks along the way. source, target = BasicBlock(\"entry\"), BasicBlock(0x00405073) path = Program.control_flow().bfs(source) while path.get(target): target.highlight() target = path[target] You can highlight anything that has an address (like a basic block, function, or a single instruction). Call .unhighlight() to clear the highlight. Conventions There are a few conventions that this library follows, and which may be useful when learning: This library completely ignores the Ghidra \"Address\" abstraction. Plain integers are used everywhere instead. Address abstraction is very powerful, but not necessary for most use cases (at least my use cases). If this is a problem for you, please let me know - maybe there is a simple way to make ghidralib work for you. Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found. IDE Configuration I strongly recommend using an IDE that supports type-checking. This is why: I personally use is VS Code with Python extensions. If you install VsCode/VsCodium, a Python extension, and just drop ghidralib.py in the ghidra_scripts directory, then everything should \"just work\". If for some reason your script lives in a different directory than ghidralib, override the PYTHONPATH so the typechecker knows how to import it: { \"python.analysis.extraPaths\": [\"/home/you/Projects/ghidralib\"], \"terminal.integrated.env.windows\": { \"PYTHONPATH\": \"/home/you/Projects/ghidralib\", } }","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. If you prefer to learn by example, check out the examples directory , or the tests . For a more complete reference, see the API documentation . Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier. IDE configuration I strongly recommend using an IDE that supports type-checking.","title":"Getting Started"},{"location":"getting_started/#installation","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link.","title":"Installation"},{"location":"getting_started/#main-actors","text":"A lot of objects are wrapped by this library. The most important at the beginning are: Function - a function recognised by Ghidra Instruction - assembly instruction DataType - a configured data type Symbol - a named address (also called a label)","title":"Main actors"},{"location":"getting_started/#function","text":"A function is a named block of code. Not all code in Ghidra belongs to a function, but being in a function makes it easier to reason about - for example, we can talk about parameters, variables, return values, etc. Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Print high variables in main function # These are the variables as seen by decompiler - the ones # that one thinks about when reversing print(Function(\"main\").high_variables) # Get the control flow graph of the main function... # ...and show it! (you can also do something more useful with it) Function(\"main\").control_flow.show() # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Use symbolic execution to infer values of eax and edx at each call site for call in Function(\"MyCustomCrypto\").calls: ctx = call.infer_context() key, data = ctx[\"eax\"], ctx[\"edx\"] print(key, data) # Infer parameters for each call to this function (using the decmopiler) for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) # Rename functions calling this function for caller in Function(\"MyCustomCrypto\").callers: # Use caller address as a suffix. It's often useful to combine this with # emulation, so you can put more context in the name. caller.rename(\"CallsCustomCrypto_{}\".format(caller.address)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) # Use Ghidra's SymbolicPropagator to get known register values ctx = Function(0x401000).symbolic_context() print(ctx.register_at(0x401020, \"eax\")) Read more in the Function object documentation .","title":"Function"},{"location":"getting_started/#instruction","text":"Instructions represent a single assembly operation. They have a mnemonic (e.g. mov ), operands (e.g. eax, 3 ), and a pcode representation used for further analysis. Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation .","title":"Instruction"},{"location":"getting_started/#datatype","text":"Data types are used to describe the structure of data in memory. Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) # You can also create structures from C code strings: foo = DataType.from_c('struct foo { int a; int b; };') Read more in the DataType object documentation .","title":"DataType"},{"location":"getting_started/#symbol","text":"Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(\"funniner_\" + symbol.name\") Read more in the Symbol object documentation .","title":"Symbol"},{"location":"getting_started/#working-at-various-abstraction-levels","text":"In this section I'll briefly summarize ghidralib objects that you can use to work at various abstraction levels. Assembly instructions - at the lowest level, there is assembler. You will use familiar Instruction , BasicBlock and Function . When analysing data, you will think in terms of Register s of Variables , and references are in terms of Symbols . Pcode instructions - here you think in terms of PcodeOp s, and PcodeBlocks . You still work with Functions , but the data flows between architecture-independent Varnodes now instead. High Pcode instructions - after the decompilation, many things change. You stil work with PcodeOps , but they are significantly transformed - referred as \"High Pcode\" in this library. You now think in terms of High Functions , High Variables , and High Symbols . Even Varnodes are now slightly more powerful (under the hood they are VarnodeASTs now). Pcode syntax tree ( Function.pcode_tree ) - As far as I know, there was no easy way to work with it. I hope ghidralib makes this much easier. On this level, you still have high PcodeOps , but syntactic elements like \"dowhile\" loops, \"if\" statements etc, are now recovered and you can traverse the syntax tree (while still dealing with PcodeOps ). C abstract syntax tree (AST) - built internally by the decompiler, but not exported by Ghidra. I hope to add support for it in ghidralib one way or another, but for now there is no way to access it. Clang tokens ( Function.tokens ) - a stream of tokens that represent the C code. It is very detailed, to the level that it contains even whitespace. You can clean them up, but the data is still overprocessed a bit too much, and not useful (IMO) during analysis. Ghidra uses it for display.","title":"Working at various abstraction levels"},{"location":"getting_started/#showcase","text":"In this section I'll present a few examples of impressive-but-not-necessarily-useful things you can do with ghidralib.","title":"Showcase"},{"location":"getting_started/#emulation","text":"Emulate the program from 0x400300 to 0x400400. When finished, read the value of eax and the memory at 0x401000. # Create a new emulator and execute code between 0x400300 and 0x400400 emu = Emulator() emu.emulate(0x400300, 0x400400) print(emu[\"eax\"]) print(emu.read_bytes(0x401000, 16)) # Emulate a function call and pass parameters (using the function signature) ctx = Function(\"GetFuncNameByHash\").emulate(0x698766968) print(ctx.read_cstring(ctx[\"eax\"])) In practice you can often use this for recovering obfuscated strings, or unpacking simple packers.","title":"Emulation"},{"location":"getting_started/#graphs","text":"# Get the control flow graph of the main function (and display it) Function(\"main\").control_flow.show() Graph visualisation is not the most useful feature of this library, but it looks cool: And you can easily build the graph yourself: g = Graph.create() foo = g.vertex(\"foo\") bar = g.vertex(\"bar\") g.edge(foo, bar) g.show() Or you can do some actually useful things with included graph algorithms (DFS, BFS, and topological sort) - like tracing paths between functions.","title":"Graphs"},{"location":"getting_started/#path-finding","text":"Find the shortest path from source to target in the program control flow graph. If it exists, highlight all basic blocks along the way. source, target = BasicBlock(\"entry\"), BasicBlock(0x00405073) path = Program.control_flow().bfs(source) while path.get(target): target.highlight() target = path[target] You can highlight anything that has an address (like a basic block, function, or a single instruction). Call .unhighlight() to clear the highlight.","title":"Path finding"},{"location":"getting_started/#conventions","text":"There are a few conventions that this library follows, and which may be useful when learning: This library completely ignores the Ghidra \"Address\" abstraction. Plain integers are used everywhere instead. Address abstraction is very powerful, but not necessary for most use cases (at least my use cases). If this is a problem for you, please let me know - maybe there is a simple way to make ghidralib work for you. Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"Conventions"},{"location":"getting_started/#ide-configuration","text":"I strongly recommend using an IDE that supports type-checking. This is why: I personally use is VS Code with Python extensions. If you install VsCode/VsCodium, a Python extension, and just drop ghidralib.py in the ghidra_scripts directory, then everything should \"just work\". If for some reason your script lives in a different directory than ghidralib, override the PYTHONPATH so the typechecker knows how to import it: { \"python.analysis.extraPaths\": [\"/home/you/Projects/ghidralib\"], \"terminal.integrated.env.windows\": { \"PYTHONPATH\": \"/home/you/Projects/ghidralib\", } }","title":"IDE Configuration"},{"location":"reference/","text":"API reference ghidralib This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/. Addr = GenericAddress | int | str module-attribute DataT = GhidraWrapper | JavaObject | str module-attribute HIGHLIGHT_COLOR = SearchConstants.SEARCH_HIGHLIGHT_COLOR module-attribute Reg = GhRegister | str module-attribute Str = (str, bytes, unicode) module-attribute T = TypeVar('T') module-attribute __version__ = '0.2.0' module-attribute bytes = str module-attribute interpreter = get_current_interpreter() module-attribute long = int module-attribute AddressRange Bases: GhidraWrapper Wraps a Ghidra AddressRange object. Source code in ghidralib.py class AddressRange(GhidraWrapper): \"\"\"Wraps a Ghidra AddressRange object.\"\"\" @property def addresses(self): # type: () -> list[int] \"\"\"Return the addresses in this range.\"\"\" return [a.getOffset() for a in self.raw.getAddresses(True)] def __iter__(self): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self.addresses.__iter__() @property def start(self): # type: () -> int \"\"\"Get the first address in this range.\"\"\" return self.raw.getMinAddress().getOffset() @property def end(self): # type: () -> int \"\"\"Get the last address in this range.\"\"\" return self.raw.getMaxAddress().getOffset() @property def length(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.raw.getLength() def __len__(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.length def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.raw.contains(resolve(addr)) def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.contains(addr) @property def is_empty(self): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self.raw.isEmpty() def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty def __and__(self, other): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange(self.raw.intersect(other.raw)) addresses property Return the addresses in this range. end property Get the last address in this range. is_empty property Return True if this range is empty. length property Get the length of this range. start property Get the first address in this range. __and__(other) Return the intersection of this range and the given range. Source code in ghidralib.py def __and__(self, other): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange(self.raw.intersect(other.raw)) __contains__(addr) Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.contains(addr) __iter__() Iterate over the addresses in this range. Source code in ghidralib.py def __iter__(self): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self.addresses.__iter__() __len__() Get the length of this range. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.length __nonzero__() Return True if this range is not empty. Source code in ghidralib.py def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty contains(addr) Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.raw.contains(resolve(addr)) AddressSet Bases: GhidraWrapper Wraps a Ghidra AddressSetView object. Source code in ghidralib.py class AddressSet(GhidraWrapper): \"\"\"Wraps a Ghidra AddressSetView object.\"\"\" @staticmethod def empty(): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet(GhAddressSet()) @staticmethod def create(start, length): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve(start) return AddressSet(GhAddressSet(addr, addr.add(length - 1))) @property def addresses(self): # type: () -> list[int] \"\"\"Return the addresses in this set.\"\"\" return [a.getOffset() for a in self.raw.getAddresses(True)] @property def ranges(self): # type: () -> list[AddressRange] return [AddressRange(r) for r in self.raw.iterator(True)] def __iter__(self): # type: () -> Iterator[int] return self.addresses.__iter__() def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.raw.contains(resolve(addr)) def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.contains(addr) @property def is_empty(self): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self.raw.isEmpty() def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty def __and__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet(self.raw.intersect(other.raw)) def __sub__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet(self.raw.subtract(other.raw)) def __xor__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet(self.raw.xor(other.raw)) def __or__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet(self.raw.union(other.raw)) def __get_highlighter(self): # type: () -> Any tool = getState().getTool() service = tool.getService(ColorizingService) if service is None: raise RuntimeError(\"Cannot highlight without the ColorizingService\") return service def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None service = self.__get_highlighter() service.setBackgroundColor(self.raw, color) def unhighlight(self): # type: (Color) -> None service = self.__get_highlighter() service.clearBackgroundColor(self.raw) addresses property Return the addresses in this set. is_empty property Return True if this range is empty. ranges property __and__(other) Return the intersection of this set and the given set. Source code in ghidralib.py def __and__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet(self.raw.intersect(other.raw)) __contains__(addr) Return True if the given address is in this range. Source code in ghidralib.py def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.contains(addr) __get_highlighter() Source code in ghidralib.py def __get_highlighter(self): # type: () -> Any tool = getState().getTool() service = tool.getService(ColorizingService) if service is None: raise RuntimeError(\"Cannot highlight without the ColorizingService\") return service __iter__() Source code in ghidralib.py def __iter__(self): # type: () -> Iterator[int] return self.addresses.__iter__() __nonzero__() Return True if this range is not empty. Source code in ghidralib.py def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty __or__(other) Computes the union of this set and the given set. Source code in ghidralib.py def __or__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet(self.raw.union(other.raw)) __sub__(other) Subtract the given set from this set. Source code in ghidralib.py def __sub__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet(self.raw.subtract(other.raw)) __xor__(other) Computes the symmetric difference of this set and the given set. Source code in ghidralib.py def __xor__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet(self.raw.xor(other.raw)) contains(addr) Return True if the given address is in this range. Source code in ghidralib.py def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.raw.contains(resolve(addr)) create(start, length) staticmethod Create a new AddressSet with given address and length. Source code in ghidralib.py @staticmethod def create(start, length): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve(start) return AddressSet(GhAddressSet(addr, addr.add(length - 1))) empty() staticmethod Create a new empty address set Source code in ghidralib.py @staticmethod def empty(): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet(GhAddressSet()) highlight(color=HIGHLIGHT_COLOR) Source code in ghidralib.py def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None service = self.__get_highlighter() service.setBackgroundColor(self.raw, color) unhighlight() Source code in ghidralib.py def unhighlight(self): # type: (Color) -> None service = self.__get_highlighter() service.clearBackgroundColor(self.raw) BasicBlock Bases: AddressSet , BodyTrait Wraps a Ghidra CodeBlock object Source code in ghidralib.py class BasicBlock(AddressSet, BodyTrait): \"\"\"Wraps a Ghidra CodeBlock object\"\"\" @staticmethod def _model(model): # type: (str) -> Callable[[JavaObject], JavaObject] if model == \"basic\": return BasicBlockModel elif model == \"simple\": return SimpleBlockModel else: raise ValueError(\"Unsupported model type: %s\" % model) @staticmethod def get( raw_or_address, model=\"basic\" ): # type: (JavaObject|str|Addr, str) -> BasicBlock|None \"\"\"Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) :param raw_or_address: find basicblock that contains the given address. :param model: Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\".\"\"\" if raw_or_address is None: return None if can_resolve(raw_or_address): block_model = BasicBlock._model(model)(Program.current()) addr = try_resolve(raw_or_address) if addr is None: return None raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY) if raw is None: return None else: raw = raw_or_address return BasicBlock(raw) @staticmethod def all(model=\"basic\"): # type: (str) -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = BasicBlock._model(model)(Program.current()) return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)] @property def name(self): # type: () -> str \"\"\"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.\"\"\" return self.raw.getName() @property def address(self): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self.start_address @property def start_address(self): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self.raw.getMinAddress().getOffset() @property def end_address(self): # type: () -> int \"\"\"Get the address of the last byte in this basic block. Note: this is not the address of the last instruction. Note: end_address - start_address is equal to length - 1. For example, for one-byte basic block, start_address == end_address.\"\"\" return self.raw.getMaxAddress().getOffset() @property def length(self): # type: () -> int \"\"\"Get the length of this basic block in bytes.\"\"\" return self.end_address - self.start_address + 1 @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this basic block. :return: bytes of this basic block.\"\"\" return read_bytes(self.start_address, self.length) @property def instructions(self): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt(resolve(self.start_address)) while instruction and instruction.getAddress().getOffset() <= self.end_address: result.append(Instruction(instruction)) instruction = instruction.getNext() return result @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self.instructions: result.extend(instruction.pcode) return result @property def destinations(self): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator(self.raw.getDestinations(TaskMonitor.DUMMY)) return [BasicBlock(raw.getDestinationBlock()) for raw in raw_refs] @property def sources(self): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator(self.raw.getSources(TaskMonitor.DUMMY)) return [BasicBlock(raw.getSourceBlock()) for raw in raw_refs] @property def body(self): # type: () -> AddressSet \"\"\"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.\"\"\" return AddressSet(self.raw) @property def flow_type(self): # type: () -> FlowType \"\"\"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.\"\"\" return FlowType(self.raw.getFlowType()) def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance(other, BasicBlock): return False # This is not fully correct, but more correct than the default. return self.address == other.address address property Get the address of the first instruction in this basic block. body property Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep. bytes property Get the bytes of this basic block. Returns: \u2013 bytes of this basic block. destinations property Get a list of basic blocks that this basic block jumps to end_address property Get the address of the last byte in this basic block. Note: this is not the address of the last instruction. Note: end_address - start_address is equal to length - 1. For example, for one-byte basic block, start_address == end_address. flow_type property Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node. instructions property Get a list of instructions in this basic block. length property Get the length of this basic block in bytes. name property Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string. pcode property Get a list of Pcode operations that this basic block was parsed to sources property Get a list of basic blocks that jump to this basic block start_address property Get the address of the first instruction in this basic block. __eq__(other) Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance(other, BasicBlock): return False # This is not fully correct, but more correct than the default. return self.address == other.address all(model='basic') staticmethod Get a list of all basic blocks in the program. Source code in ghidralib.py @staticmethod def all(model=\"basic\"): # type: (str) -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = BasicBlock._model(model)(Program.current()) return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)] get(raw_or_address, model='basic') staticmethod Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Parameters: raw_or_address \u2013 find basicblock that contains the given address. model \u2013 Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\". Source code in ghidralib.py @staticmethod def get( raw_or_address, model=\"basic\" ): # type: (JavaObject|str|Addr, str) -> BasicBlock|None \"\"\"Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) :param raw_or_address: find basicblock that contains the given address. :param model: Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\".\"\"\" if raw_or_address is None: return None if can_resolve(raw_or_address): block_model = BasicBlock._model(model)(Program.current()) addr = try_resolve(raw_or_address) if addr is None: return None raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY) if raw is None: return None else: raw = raw_or_address return BasicBlock(raw) BlockGraph Bases: PcodeBlock Source code in ghidralib.py class BlockGraph(PcodeBlock): @property def blocks(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getBlock(i)) for i in range(self.raw.getSize())] blocks property BodyTrait A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting. Source code in ghidralib.py class BodyTrait: \"\"\"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting.\"\"\" @property @abstractmethod def body(self): # type: () -> AddressSet \"\"\"The body of this object\"\"\" def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self.body.highlight(color) def unhighlight(self): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self.body.unhighlight() body abstractmethod property The body of this object highlight(color=HIGHLIGHT_COLOR) Highlight this instruction in the listing. Source code in ghidralib.py def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self.body.highlight(color) unhighlight() Clear the highlight from this instruction. Source code in ghidralib.py def unhighlight(self): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self.body.unhighlight() ClangTokenGroup Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py class ClangTokenGroup(GhidraWrapper): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup(self, token): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup(token.Parent()) for token in list(token.iterator()): if isinstance(token, (ClangCommentToken, ClangBreak)): continue if isinstance(token, ClangSyntaxToken): if not token.getText() or token.getText().isspace(): continue if isinstance(token, GhClangTokenGroup): token = self._cleanup(token) new.AddTokenGroup(token) return new @property def cleaned(self): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup(self._cleanup(self.raw)) def _dump(self, token, indent=0): # type: (JavaObject, int) -> None if isinstance(token, GhClangTokenGroup): print(\"{}[group]\".format(indent * \" \", token.__class__.__name__)) for child in token.iterator(): self._dump(child, indent + 1) else: print(\"{}{} ({})\".format(indent * \" \", token, token.__class__.__name__)) def dump(self): # type: () -> None self._dump(self.raw) cleaned property Remove all whitespace and comments from this token group, recursively. dump() Source code in ghidralib.py def dump(self): # type: () -> None self._dump(self.raw) Data Bases: GhidraWrapper Wraps a structure for convenient access by field name Source code in ghidralib.py class Data(GhidraWrapper): \"\"\" Wraps a structure for convenient access by field name \"\"\" @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Data|None \"\"\"Return a Data instance at the given address, or None if there is no Data defined there.\"\"\" if isinstance(addr, GhData): return Data(addr) addr = try_resolve(addr) if addr is None: return None raw = getDataAt(addr) if raw is None: return None return Data(raw) # type: ignore def __getattr__(self, name): for i in range(self.raw.getNumComponents()): field = self.raw.getComponent(i) if field.getFieldName() == name: if field.isStructure(): return Data(field) return GhidraWrapper(field) raise AttributeError(\"Field %s does not exist\" % name) __getattr__(name) Source code in ghidralib.py def __getattr__(self, name): for i in range(self.raw.getNumComponents()): field = self.raw.getComponent(i) if field.getFieldName() == name: if field.isStructure(): return Data(field) return GhidraWrapper(field) raise AttributeError(\"Field %s does not exist\" % name) get(addr) staticmethod Return a Data instance at the given address, or None if there is no Data defined there. Source code in ghidralib.py @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Data|None \"\"\"Return a Data instance at the given address, or None if there is no Data defined there.\"\"\" if isinstance(addr, GhData): return Data(addr) addr = try_resolve(addr) if addr is None: return None raw = getDataAt(addr) if raw is None: return None return Data(raw) # type: ignore DataType Bases: GhidraWrapper Source code in ghidralib.py class DataType(GhidraWrapper): @staticmethod def get(name_or_raw): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance(name_or_raw, Str): return DataType(name_or_raw) for datatype in DataType.all(): if datatype.name == name_or_raw: return DataType(datatype) return None @staticmethod def all(only_local=False): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list(Program.current().getDataTypeManager().getAllDataTypes()) if not only_local: managers = ( getState() .getTool() .getService(DataTypeManagerService) .getDataTypeManagers() ) for manager in managers: for datatype in manager.getAllDataTypes(): datatypes.append(datatype) return [DataType(raw) for raw in datatypes] @property def name(self): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' . \"\"\" return self.raw.getName() def get_name(self, value): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self.raw.getName(value) def length(self): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self.raw.getLength() __len__ = length @staticmethod def from_c(c_code, insert=True): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program.current().getDataTypeManager() parser = CParser(dtm) new_dt = parser.parse(c_code) if insert: transaction = dtm.startTransaction(\"Adding new data\") dtm.addDataType(new_dt, None) dtm.endTransaction(transaction, True) return new_dt __len__ = length class-attribute instance-attribute name property Get a name of this data type >>> DataType('int').name 'int' . all(only_local=False) staticmethod Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py @staticmethod def all(only_local=False): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list(Program.current().getDataTypeManager().getAllDataTypes()) if not only_local: managers = ( getState() .getTool() .getService(DataTypeManagerService) .getDataTypeManagers() ) for manager in managers: for datatype in manager.getAllDataTypes(): datatypes.append(datatype) return [DataType(raw) for raw in datatypes] from_c(c_code, insert=True) staticmethod Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py @staticmethod def from_c(c_code, insert=True): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program.current().getDataTypeManager() parser = CParser(dtm) new_dt = parser.parse(c_code) if insert: transaction = dtm.startTransaction(\"Adding new data\") dtm.addDataType(new_dt, None) dtm.endTransaction(transaction, True) return new_dt get(name_or_raw) staticmethod Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name_or_raw \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py @staticmethod def get(name_or_raw): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance(name_or_raw, Str): return DataType(name_or_raw) for datatype in DataType.all(): if datatype.name == name_or_raw: return DataType(datatype) return None get_name(value) If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py def get_name(self, value): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self.raw.getName(value) length() Get the length of this data type in bytes >>> DataType('int').length() 4 . Source code in ghidralib.py def length(self): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self.raw.getLength() Emulator Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py class Emulator(GhidraWrapper): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__(self): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper(Program.current()) GhidraWrapper.__init__(self, raw) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset() max_pointer = max_pointer % 2**64 # Java signed ints everywhere strike again. stack_off = ((max_pointer + 1) >> 1) - 0x8000 self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off) # TODO: add a simple allocation manager self._hooks = {} # type: dict[int, Callable[[Emulator], str|None]] def add_hook( self, address, hook ): # type: (Addr, Callable[[Emulator], str|None]) -> None \"\"\"Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported.\"\"\" addr = resolve(address).getOffset() if addr in self._hooks: raise ValueError(\"Multiple hooks at the same address are not supported\") self._hooks[addr] = hook def has_hook_at(self, address): # type: (Addr) -> bool addr = resolve(address).getOffset() return addr in self._hooks def delete_hook_at(self, address): # type: (Addr) -> None addr = resolve(address).getOffset() del self._hooks[addr] @property def pc(self): # type: () -> int \"\"\"Get the program counter of the emulated program.\"\"\" return self.raw.getExecutionAddress().getOffset() @pc.setter def pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" self.set_pc(address) def set_pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self.raw.getPCRegister() self.raw.writeRegister(pc, resolve(address).getOffset()) @property def sp_register(self): # type: () -> str \"\"\"Get the stack pointer register name for the emulated architecture.\"\"\" return self.raw.getStackPointerRegister().getName() @property def sp(self): # type: () -> int \"\"\"Get the current stack pointer register value.\"\"\" return self.read_register(self.sp_register) @sp.setter def sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.set_sp(value) def set_sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.write_register(self.sp_register, resolve(value).getOffset()) def __getitem__(self, reg): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self.read_register(reg) def __setitem__(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self.write_register(reg, value) def read_register(self, reg): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return _python_int(self.raw.readRegister(reg)) def read_bytes(self, address, length): # type: (Addr, int) -> bytes \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self.raw.readMemory(resolve(address), length) return _bytes_from_bytelist(bytelist) def read_u8(self, address): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 1)) def read_u16(self, address): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 2)) def read_u32(self, address): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 4)) def read_u64(self, address): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 8)) def read_cstring(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string def read_unicode(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string def read_varnode(self, varnode): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: return varnode.offset elif varnode.is_address: rawnum = self.read_bytes(varnode.offset, varnode.size) return from_bytes(rawnum) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) rawnum = self.read_bytes(offset, varnode.size) return from_bytes(rawnum) elif varnode.is_stack: return self.raw.readStackValue(varnode.offset, varnode.size, False) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) return self.read_register(reg) raise RuntimeError(\"Unsupported varnode type\") def write_register(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self.raw.writeRegister(reg, value) def write_bytes(self, address, value): # type: (Addr, bytes) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self.raw.writeMemory(resolve(address), value) def write_u8(self, address, value): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**8, \"value out of range\" self.write_bytes(address, to_bytes(value, 1)) def write_u16(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**16, \"value out of range\" self.write_bytes(address, to_bytes(value, 2)) def write_u32(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**32, \"value out of range\" self.write_bytes(address, to_bytes(value, 4)) def write_u64(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**64, \"value out of range\" self.write_bytes(address, to_bytes(value, 8)) def write_varnode(self, varnode, value): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: raise ValueError(\"Can't set value of a constant varnodes\") elif varnode.is_address: self.write_bytes(varnode.offset, to_bytes(value, varnode.size)) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) self.write_bytes(offset, to_bytes(value, varnode.size)) elif varnode.is_stack: self.raw.writeStackValue(varnode.offset, varnode.size, value) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) self.raw.writeRegister(reg, value) else: raise RuntimeError(\"Unsupported varnode type\") def __run_with_hooks(self): # type: () -> bool \"\"\"Run the Ghidra emulator, and transparently handle all hooks. :return: True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break).\"\"\" while not getMonitor().isCancelled(): is_breakpoint = self.raw.run(getMonitor()) if self.pc not in self._hooks: return is_breakpoint result = self._hooks[self.pc](self) if self.__handle_hook_result(result): return True return False def add_breakpoint(self, address): # type: (Addr) -> None \"\"\"Add a breakpoint at the given address. :param address: the address to break on\"\"\" self.raw.setBreakpoint(resolve(address)) def clear_breakpoint(self, address): # type: (Addr) -> None \"\"\"Clear a breakpoint at the given address. :param address: the address to clear breakpoint from\"\"\" self.raw.clearBreakpoint(resolve(address)) def emulate_fast(self, start, ends): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] for end in ends: self.add_breakpoint(end) is_breakpoint = self.__run_with_hooks() for end in ends: self.clear_breakpoint(end) if not is_breakpoint: err = self.raw.getLastError() raise RuntimeError(\"Error when running: {}\".format(err)) def __handle_hook_result(self, result): # type: (str|None) -> bool \"\"\"Handle a hook return value and return True if emulation should stop.\"\"\" if result is None or result == \"continue\": return False elif result == \"skip\": self.pc = Instruction(self.pc).next.address return False elif result == \"break\": return True else: raise RuntimeError(\"Invalid hook return value: {}\".format(result)) def single_step(self): # type: () -> bool \"\"\"Do a single emulation step. This will step into calls. Note: This method *will* call hooks. :return: True if the emulation should be stopped, False otherwise.\"\"\" success = self.raw.step(getMonitor()) if not success: err = self.raw.getLastError() raise RuntimeError(\"Error at {}: {}\".format(self.pc, err)) if self.pc in self._hooks: result = self._hooks[self.pc](self) return self.__handle_hook_result(result) if self.is_at_breakpoint: return True return False @staticmethod def new( start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> Emulator \"\"\"Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See `emulate` documentation for info about this method parameters.\"\"\" emu = Emulator() emu.emulate(start, ends, callback, stop_when, maxsteps) return emu def emulate( self, start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> None \"\"\"Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction * 'retry' like continue, but call the callback again (useful after pc change) * 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). :param stop_when: the callback to call before each executed instruction. Return True here to stop emulation. :param maxsteps: the maximum number of steps to execute\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] ends = [resolve(e).getOffset() for e in ends] while maxsteps > 0: maxsteps -= 1 if self.pc in ends: break command = callback(self) if command == \"retry\": continue elif command == \"continue_then_break\": maxsteps = 0 elif self.__handle_hook_result(command): return if stop_when(self): return if self.single_step(): return @property def is_at_breakpoint(self): # type: () -> bool \"\"\"Check if the emulator is at a breakpoint\"\"\" return self.raw.getEmulator().isAtBreakpoint() # Basic unicorn compatibility, because why not # You may prefer these aliases if you already know Unicorn API. reg_write = write_register reg_read = read_register mem_write = write_bytes mem_read = read_bytes mem_map = ( lambda _1, _2, _3: None ) # This is a noop - all memory is already available. emu_start = lambda self, begin, until: self.emulate(begin, until) emu_start = lambda self, begin, until: self.emulate(begin, until) class-attribute instance-attribute is_at_breakpoint property Check if the emulator is at a breakpoint mem_map = lambda _1, _2, _3: None class-attribute instance-attribute mem_read = read_bytes class-attribute instance-attribute mem_write = write_bytes class-attribute instance-attribute pc property writable Get the program counter of the emulated program. reg_read = read_register class-attribute instance-attribute reg_write = write_register class-attribute instance-attribute sp property writable Get the current stack pointer register value. sp_register property Get the stack pointer register name for the emulated architecture. __getitem__(reg) Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 Parameters: reg \u2013 the register or address to read from Source code in ghidralib.py def __getitem__(self, reg): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self.read_register(reg) __handle_hook_result(result) Handle a hook return value and return True if emulation should stop. Source code in ghidralib.py def __handle_hook_result(self, result): # type: (str|None) -> bool \"\"\"Handle a hook return value and return True if emulation should stop.\"\"\" if result is None or result == \"continue\": return False elif result == \"skip\": self.pc = Instruction(self.pc).next.address return False elif result == \"break\": return True else: raise RuntimeError(\"Invalid hook return value: {}\".format(result)) __init__() Create a new Emulator object. Source code in ghidralib.py def __init__(self): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper(Program.current()) GhidraWrapper.__init__(self, raw) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset() max_pointer = max_pointer % 2**64 # Java signed ints everywhere strike again. stack_off = ((max_pointer + 1) >> 1) - 0x8000 self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off) # TODO: add a simple allocation manager self._hooks = {} # type: dict[int, Callable[[Emulator], str|None]] __run_with_hooks() Run the Ghidra emulator, and transparently handle all hooks. Returns: \u2013 True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break). Source code in ghidralib.py def __run_with_hooks(self): # type: () -> bool \"\"\"Run the Ghidra emulator, and transparently handle all hooks. :return: True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break).\"\"\" while not getMonitor().isCancelled(): is_breakpoint = self.raw.run(getMonitor()) if self.pc not in self._hooks: return is_breakpoint result = self._hooks[self.pc](self) if self.__handle_hook_result(result): return True return False __setitem__(reg, value) Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py def __setitem__(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self.write_register(reg, value) add_breakpoint(address) Add a breakpoint at the given address. Parameters: address \u2013 the address to break on Source code in ghidralib.py def add_breakpoint(self, address): # type: (Addr) -> None \"\"\"Add a breakpoint at the given address. :param address: the address to break on\"\"\" self.raw.setBreakpoint(resolve(address)) add_hook(address, hook) Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: 'continue' or None, to continue execution normally 'break' to stop execution 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported. Source code in ghidralib.py def add_hook( self, address, hook ): # type: (Addr, Callable[[Emulator], str|None]) -> None \"\"\"Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported.\"\"\" addr = resolve(address).getOffset() if addr in self._hooks: raise ValueError(\"Multiple hooks at the same address are not supported\") self._hooks[addr] = hook clear_breakpoint(address) Clear a breakpoint at the given address. Parameters: address \u2013 the address to clear breakpoint from Source code in ghidralib.py def clear_breakpoint(self, address): # type: (Addr) -> None \"\"\"Clear a breakpoint at the given address. :param address: the address to clear breakpoint from\"\"\" self.raw.clearBreakpoint(resolve(address)) delete_hook_at(address) Source code in ghidralib.py def delete_hook_at(self, address): # type: (Addr) -> None addr = resolve(address).getOffset() del self._hooks[addr] emulate(start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2 ** 48) Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: 'continue' or None, to continue execution normally 'break' to stop execution 'skip' to skip the next instruction 'retry' like continue, but call the callback again (useful after pc change) 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). stop_when \u2013 the callback to call before each executed instruction. Return True here to stop emulation. maxsteps \u2013 the maximum number of steps to execute Source code in ghidralib.py def emulate( self, start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> None \"\"\"Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction * 'retry' like continue, but call the callback again (useful after pc change) * 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). :param stop_when: the callback to call before each executed instruction. Return True here to stop emulation. :param maxsteps: the maximum number of steps to execute\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] ends = [resolve(e).getOffset() for e in ends] while maxsteps > 0: maxsteps -= 1 if self.pc in ends: break command = callback(self) if command == \"retry\": continue elif command == \"continue_then_break\": maxsteps = 0 elif self.__handle_hook_result(command): return if stop_when(self): return if self.single_step(): return emulate_fast(start, ends) Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' Parameters: start \u2013 the start address to emulate ends \u2013 one or many end address Source code in ghidralib.py def emulate_fast(self, start, ends): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] for end in ends: self.add_breakpoint(end) is_breakpoint = self.__run_with_hooks() for end in ends: self.clear_breakpoint(end) if not is_breakpoint: err = self.raw.getLastError() raise RuntimeError(\"Error when running: {}\".format(err)) has_hook_at(address) Source code in ghidralib.py def has_hook_at(self, address): # type: (Addr) -> bool addr = resolve(address).getOffset() return addr in self._hooks new(start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2 ** 48) staticmethod Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See emulate documentation for info about this method parameters. Source code in ghidralib.py @staticmethod def new( start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> Emulator \"\"\"Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See `emulate` documentation for info about this method parameters.\"\"\" emu = Emulator() emu.emulate(start, ends, callback, stop_when, maxsteps) return emu read_bytes(address, length) Read length bytes at address from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py def read_bytes(self, address, length): # type: (Addr, int) -> bytes \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self.raw.readMemory(resolve(address), length) return _bytes_from_bytelist(bytelist) read_cstring(address) Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_cstring(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string read_register(reg) Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py def read_register(self, reg): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return _python_int(self.raw.readRegister(reg)) read_u16(address) Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u16(self, address): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 2)) read_u32(address) Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u32(self, address): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 4)) read_u64(address) Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u64(self, address): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 8)) read_u8(address) Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u8(self, address): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 1)) read_unicode(address) Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_unicode(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string read_varnode(varnode) Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py def read_varnode(self, varnode): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: return varnode.offset elif varnode.is_address: rawnum = self.read_bytes(varnode.offset, varnode.size) return from_bytes(rawnum) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) rawnum = self.read_bytes(offset, varnode.size) return from_bytes(rawnum) elif varnode.is_stack: return self.raw.readStackValue(varnode.offset, varnode.size, False) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) return self.read_register(reg) raise RuntimeError(\"Unsupported varnode type\") set_pc(address) Set the program counter of the emulated program. Source code in ghidralib.py def set_pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self.raw.getPCRegister() self.raw.writeRegister(pc, resolve(address).getOffset()) set_sp(value) Set the current stack pointer register value. Parameters: value \u2013 new stack pointer value. Source code in ghidralib.py def set_sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.write_register(self.sp_register, resolve(value).getOffset()) single_step() Do a single emulation step. This will step into calls. Note: This method will call hooks. Returns: \u2013 True if the emulation should be stopped, False otherwise. Source code in ghidralib.py def single_step(self): # type: () -> bool \"\"\"Do a single emulation step. This will step into calls. Note: This method *will* call hooks. :return: True if the emulation should be stopped, False otherwise.\"\"\" success = self.raw.step(getMonitor()) if not success: err = self.raw.getLastError() raise RuntimeError(\"Error at {}: {}\".format(self.pc, err)) if self.pc in self._hooks: result = self._hooks[self.pc](self) return self.__handle_hook_result(result) if self.is_at_breakpoint: return True return False write_bytes(address, value) Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py def write_bytes(self, address, value): # type: (Addr, bytes) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self.raw.writeMemory(resolve(address), value) write_register(reg, value) Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py def write_register(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self.raw.writeRegister(reg, value) write_u16(address, value) Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u16(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**16, \"value out of range\" self.write_bytes(address, to_bytes(value, 2)) write_u32(address, value) Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u32(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**32, \"value out of range\" self.write_bytes(address, to_bytes(value, 4)) write_u64(address, value) Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u64(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**64, \"value out of range\" self.write_bytes(address, to_bytes(value, 8)) write_u8(address, value) Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u8(self, address, value): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**8, \"value out of range\" self.write_bytes(address, to_bytes(value, 1)) write_varnode(varnode, value) Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py def write_varnode(self, varnode, value): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: raise ValueError(\"Can't set value of a constant varnodes\") elif varnode.is_address: self.write_bytes(varnode.offset, to_bytes(value, varnode.size)) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) self.write_bytes(offset, to_bytes(value, varnode.size)) elif varnode.is_stack: self.raw.writeStackValue(varnode.offset, varnode.size, value) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) self.raw.writeRegister(reg, value) else: raise RuntimeError(\"Unsupported varnode type\") FlowType Bases: GhidraWrapper Wraps a Ghidra FlowType object Source code in ghidralib.py class FlowType(GhidraWrapper): \"\"\"Wraps a Ghidra FlowType object\"\"\" # TODO is class this necessary? This is just a subclass of RefType. @property def is_call(self): # type: () -> bool \"\"\"Return True if this flow is a call.\"\"\" return self.raw.isCall() @property def is_jump(self): # type: () -> bool \"\"\"Return True if this flow is a jump.\"\"\" return self.raw.isJump() @property def is_computed(self): # type: () -> bool \"\"\"Return True if this flow is a computed jump.\"\"\" return self.raw.isComputed() @property def is_conditional(self): # type: () -> bool \"\"\"Return True if this flow is a conditional jump.\"\"\" return self.raw.isConditional() @property def is_unconditional(self): # type: () -> bool \"\"\"Return True if this flow is an unconditional jump.\"\"\" return not self.is_conditional @property def is_terminal(self): # type: () -> bool \"\"\"Return True if this flow is a terminator.\"\"\" return self.raw.isTerminal() @property def has_fallthrough(self): # type: () -> bool \"\"\"Return True if this flow has a fallthrough.\"\"\" return self.raw.hasFallthrough() @property def is_override(self): # type: () -> bool \"\"\"Return True if this flow is an override.\"\"\" return self.raw.isOverride() has_fallthrough property Return True if this flow has a fallthrough. is_call property Return True if this flow is a call. is_computed property Return True if this flow is a computed jump. is_conditional property Return True if this flow is a conditional jump. is_jump property Return True if this flow is a jump. is_override property Return True if this flow is an override. is_terminal property Return True if this flow is a terminator. is_unconditional property Return True if this flow is an unconditional jump. Function Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Function object. Source code in ghidralib.py class Function(GhidraWrapper, BodyTrait): \"\"\"Wraps a Ghidra Function object.\"\"\" UNDERLYING_CLASS = GhFunction @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance(addr, GhFunction): return Function(addr) if isinstance(addr, Function): return Function(addr.raw) addr = try_resolve(addr) if addr is None: return None raw = Program.current().getListing().getFunctionContaining(addr) if raw is None: return None return Function(raw) # type: ignore @staticmethod def all(): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program.current().getFunctionManager().getFunctions(True) return [Function(f) for f in raw_functions] @staticmethod def create(address, name): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction(resolve(address), name) return Function(func) @property def return_type(self): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType(self.raw.getReturnType()) @property def return_variable(self): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter(self.raw.getReturn()) @property def entrypoint(self): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self.raw.getEntryPoint().getOffset() @property def address(self): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self.entrypoint @property def exitpoints(self): # type: () -> list[int] \"\"\"Get a list of exit points for the function. This will return a list of addresses of function terminators. For example, if a function has two RETs, this function will return their addresses.\"\"\" return [i.address for i in self.instructions if i.flow_type.is_terminal] @property def name(self): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self.raw.getName() @property def comment(self): # type: () -> str|None \"\"\"Get the comment of this function, if any.\"\"\" return self.raw.getComment() def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self.raw.setComment(comment) @property def is_thunk(self): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self.raw.isThunk() @property def is_external(self): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self.raw.isExternal() @property def repeatable_comment(self): # type: () -> str|None \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self.raw.getRepeatableComment() def set_repeatable_comment(self, comment): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self.raw.setRepeatableComment(comment) @property def parameters(self): # type: () -> list[Parameter] \"\"\"Get the parameters of this function.\"\"\" return [Parameter(raw) for raw in self.raw.getParameters()] def add_named_parameter(self, datatype, name): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self.raw.hasCustomVariableStorage(): raise ValueError( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType(datatype) param = ParameterImpl(name, data.raw, 0, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) def add_register_parameter( self, datatype, register, name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self.raw.hasCustomVariableStorage(): self.raw.setCustomVariableStorage(True) reg = Register(register) data = DataType(datatype) param = ParameterImpl(name, data.raw, reg.raw, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) def fixup_body(self): # type: () -> bool \"\"\"Fixup the function body: follow control flow and add thunks.\"\"\" return CreateFunctionCmd.fixupFunctionBody( Program.current(), self.raw, getMonitor() ) @property def local_variables(self): # type: () -> list[Variable] \"\"\"Get the local variables of this function.\"\"\" return [Variable(raw) for raw in self.raw.getLocalVariables()] @property def variables(self): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [Variable(raw) for raw in self.raw.getAllVariables()] @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with a variable in this function.\"\"\" varnodes = [] for var in self.variables: varnodes.extend(var.varnodes) return varnodes @property def high_variables(self): # type: () -> list[HighVariable] \"\"\"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.high_function.variables @property def stack(self): # type: () -> list[Variable] \"\"\"Get the defined stack variables (both parameters and locals).\"\"\" raw_vars = self.raw.getStackFrame().getStackVariables() return [Variable(raw) for raw in raw_vars] def rename(self, name): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self.raw.setName(name, SourceType.USER_DEFINED) @property def instructions(self): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = Program.current().getListing() raw_instructions = listing.getInstructions(self.raw.getBody(), True) return [Instruction(raw) for raw in raw_instructions] @property def xrefs(self): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo(resolve(self.entrypoint)) return [Reference(raw) for raw in raw_refs] xrefs_to = xrefs @property def xref_addrs(self): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [xref.from_address for xref in self.xrefs] @property def callers(self): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function(raw) for raw in self.raw.getCallingFunctions(TaskMonitor.DUMMY) ] @property def called(self): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [Function(raw) for raw in self.raw.getCalledFunctions(TaskMonitor.DUMMY)] @property def fixup(self): # type: () -> str|None \"\"\"Get the fixup of this function.\"\"\" return self.raw.getCallFixup() @fixup.setter def fixup(self, fixup): # type: (str|None) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self.raw.setCallFixup(fixup) @property def calls(self): # type: () -> list[FunctionCall] \"\"\"Get all function calls to this function.\"\"\" calls = [] for ref in self.xrefs: if ref.is_call: calls.append(FunctionCall(self, ref.from_address)) return calls @property def basicblocks(self): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel(Program.current()) blocks = block_model.getCodeBlocksContaining( self.raw.getBody(), TaskMonitor.DUMMY ) return [BasicBlock(block) for block in blocks] def _decompile(self, simplify=\"decompile\"): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface() decompiler.openProgram(Program.current()) decompiler.setSimplificationStyle(simplify) decompiled = decompiler.decompileFunction(self.raw, 5, TaskMonitor.DUMMY) decompiler.closeProgram() decompiler.dispose() if decompiled is None: raise RuntimeError(\"Failed to decompile function {}\".format(self.name)) return decompiled def decompile(self): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self._decompile() return decompiled.getDecompiledFunction().getC() @property def clang_tokens(self): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self._decompile() return ClangTokenGroup(decompiled.getCCodeMarkup()) @property def high_function(self): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function() def get_high_function(self, simplify=\"decompile\"): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self._decompile(simplify) return HighFunction(decompiled.getHighFunction()) def get_high_pcode(self, simplify=\"decompile\"): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self.get_high_function(simplify).pcode @property def pcode_tree(self): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function().pcode_tree @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self.basicblocks: result.extend(block.pcode) return result @property def high_pcode(self): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_pcode() @property def high_basicblocks(self): # type: () -> list[PcodeBlock] \"\"\"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.high_function.basicblocks def get_high_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self.get_high_function().get_pcode_at(address) @property def high_symbols(self): # type: () -> list[HighSymbol] \"\"\"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function().symbols @property def primary_symbols(self): # type: () -> list[Symbol] \"\"\"Get the primary symbols for this function.\"\"\" symtable = Program.current().getSymbolTable() syms = symtable.getPrimarySymbolIterator(self.raw.getBody(), True) return [Symbol(s) for s in syms] @property def symbols(self): # type: () -> list[Symbol] \"\"\"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.\"\"\" body = self.raw.getBody() symbols = [] symtable = Program.current().getSymbolTable() for rng in body: for addr in rng: symbols.extend(symtable.getSymbols(addr)) return [Symbol(raw) for raw in symbols] @property def body(self): # type: () -> AddressSet \"\"\"Get the set of addresses of this function.\"\"\" return AddressSet(self.raw.getBody()) @property def control_flow(self): # type: () -> Graph[BasicBlock] \"\"\"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.\"\"\" return Graph.construct(self.basicblocks, lambda v: v.destinations) def emulate(self, *args, **kwargs): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs: # Jython doesn't support keyword arguments after args, apparently emulator = kwargs[\"emulator\"] else: emulator = Emulator() if len(args) != len(self.raw.getParameters()): raise ValueError( \"Wrong number of arguments for {} - got {} expected {}\".format( self.name, len(args), len(self.raw.getParameters()) ) ) for param, value in zip(self.parameters, args): emulator.write_varnode(param.varnode, value) emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body) return emulator def emulate_simple(self, *args, **kwargs): # type: (int, Emulator) -> int \"\"\"Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" context = self.emulate(*args, **kwargs) return context.read_varnode(self.return_variable.varnode) def symbolic_context(self): # type: () -> SymbolicPropogator \"\"\"Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. :return: a SymbolicPropogator instance with this function context.\"\"\" propagator = SymbolicPropogator.create() evaluator = ConstantPropagationContextEvaluator(getMonitor()) propagator.flow_constants(self.entrypoint, self.body, evaluator) return propagator UNDERLYING_CLASS = GhFunction class-attribute instance-attribute address property Get the address of this function. basicblocks property Get the basic blocks of this function. body property Get the set of addresses of this function. called property Get all functions that are called by this function. callers property Get all functions that call this function. calls property Get all function calls to this function. clang_tokens property Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value. comment property Get the comment of this function, if any. control_flow property Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function. entrypoint property Get the entrypoint of this function. exitpoints property Get a list of exit points for the function. This will return a list of addresses of function terminators. For example, if a function has two RETs, this function will return their addresses. fixup property writable Get the fixup of this function. high_basicblocks property Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow. high_function property Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. high_pcode property Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow. high_symbols property Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow. high_variables property Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow. instructions property Get the assembler instructions for this function. is_external property Return True if this function is external. is_thunk property Return True if this function is a thunk. local_variables property Get the local variables of this function. name property Get the name of this function. parameters property Get the parameters of this function. pcode property Get the (low-level) Pcode for this function. pcode_tree property Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. primary_symbols property Get the primary symbols for this function. repeatable_comment property Get the repeatable comment of this function, if any. return_type property Get the return type of this function. return_variable property Get the variable representing a return value of this function. stack property Get the defined stack variables (both parameters and locals). symbols property Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate. variables property Get all variables defined in this function. varnodes property Get all varnodes associated with a variable in this function. xref_addrs property Get the source addresses of references to this function. xrefs property Get the references to this function. xrefs_to = xrefs class-attribute instance-attribute add_named_parameter(datatype, name) Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented Source code in ghidralib.py def add_named_parameter(self, datatype, name): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self.raw.hasCustomVariableStorage(): raise ValueError( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType(datatype) param = ParameterImpl(name, data.raw, 0, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) add_register_parameter(datatype, register, name) Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore Source code in ghidralib.py def add_register_parameter( self, datatype, register, name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self.raw.hasCustomVariableStorage(): self.raw.setCustomVariableStorage(True) reg = Register(register) data = DataType(datatype) param = ParameterImpl(name, data.raw, reg.raw, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) all() staticmethod Return all functions in the current program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program.current().getFunctionManager().getFunctions(True) return [Function(f) for f in raw_functions] create(address, name) staticmethod Create a new function at the given address with the given name. Source code in ghidralib.py @staticmethod def create(address, name): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction(resolve(address), name) return Function(func) decompile() Get decompiled C code for the function as string. Source code in ghidralib.py def decompile(self): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self._decompile() return decompiled.getDecompiledFunction().getC() emulate(*args, **kwargs) Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py def emulate(self, *args, **kwargs): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs: # Jython doesn't support keyword arguments after args, apparently emulator = kwargs[\"emulator\"] else: emulator = Emulator() if len(args) != len(self.raw.getParameters()): raise ValueError( \"Wrong number of arguments for {} - got {} expected {}\".format( self.name, len(args), len(self.raw.getParameters()) ) ) for param, value in zip(self.parameters, args): emulator.write_varnode(param.varnode, value) emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body) return emulator emulate_simple(*args, **kwargs) Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py def emulate_simple(self, *args, **kwargs): # type: (int, Emulator) -> int \"\"\"Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" context = self.emulate(*args, **kwargs) return context.read_varnode(self.return_variable.varnode) fixup_body() Fixup the function body: follow control flow and add thunks. Source code in ghidralib.py def fixup_body(self): # type: () -> bool \"\"\"Fixup the function body: follow control flow and add thunks.\"\"\" return CreateFunctionCmd.fixupFunctionBody( Program.current(), self.raw, getMonitor() ) get(addr) staticmethod Return a function at the given address, or None if no function exists there. Source code in ghidralib.py @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance(addr, GhFunction): return Function(addr) if isinstance(addr, Function): return Function(addr.raw) addr = try_resolve(addr) if addr is None: return None raw = Program.current().getListing().getFunctionContaining(addr) if raw is None: return None return Function(raw) # type: ignore get_high_function(simplify='decompile') Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py def get_high_function(self, simplify=\"decompile\"): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self._decompile(simplify) return HighFunction(decompiled.getHighFunction()) get_high_pcode(simplify='decompile') Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py def get_high_pcode(self, simplify=\"decompile\"): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self.get_high_function(simplify).pcode get_high_pcode_at(address) Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py def get_high_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self.get_high_function().get_pcode_at(address) rename(name) Change the name of this function. Source code in ghidralib.py def rename(self, name): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self.raw.setName(name, SourceType.USER_DEFINED) set_comment(comment) Set the comment of this function. Source code in ghidralib.py def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self.raw.setComment(comment) set_repeatable_comment(comment) Set the repeatable comment of this function. Source code in ghidralib.py def set_repeatable_comment(self, comment): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self.raw.setRepeatableComment(comment) symbolic_context() Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. Returns: \u2013 a SymbolicPropogator instance with this function context. Source code in ghidralib.py def symbolic_context(self): # type: () -> SymbolicPropogator \"\"\"Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. :return: a SymbolicPropogator instance with this function context.\"\"\" propagator = SymbolicPropogator.create() evaluator = ConstantPropagationContextEvaluator(getMonitor()) propagator.flow_constants(self.entrypoint, self.body, evaluator) return propagator FunctionCall Bases: BodyTrait Represents a function call at a given location in the program. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py class FunctionCall(BodyTrait): \"\"\"Represents a function call at a given location in the program. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__(self, function, address): # type: (Function, Addr) -> None self.called_function = function self._address = resolve(address) @property def address(self): # type: () -> int return self._address.getOffset() @property def caller(self): # type: () -> Function|None \"\"\"Get the function where this function call takes place.\"\"\" return Function.get(self._address) calling_function = caller @property def instruction(self): # type: () -> Instruction return Instruction(self._address) @property def callee(self): # type: () -> Function \"\"\"Get the function being called.\"\"\" return self.called_function def infer_context(self): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"].\"\"\" basicblock = BasicBlock(self._address) return Emulator.new(basicblock.start_address, self._address) @property def high_pcodeop(self): # type: () -> PcodeOp|None \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp.get_high_pcode_at(self._address): if pcode_op.opcode != pcode_op.CALL: continue return pcode_op raise RuntimeError(\"No CALL at {}\".format(self.address)) @property def high_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" op = self.high_pcodeop if not op: return [] return op.inputs[1:] # skip function addr def infer_args(self): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" args = [] for varnode in self.high_varnodes: if varnode.value is not None: args.append(varnode.value) else: args.append(None) return args @property def body(self): return self.instruction.body address property body property called_function = function instance-attribute callee property Get the function being called. caller property Get the function where this function call takes place. calling_function = caller class-attribute instance-attribute high_pcodeop property Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. high_varnodes property Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. instruction property __init__(function, address) Source code in ghidralib.py def __init__(self, function, address): # type: (Function, Addr) -> None self.called_function = function self._address = resolve(address) infer_args() Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py def infer_args(self): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" args = [] for varnode in self.high_varnodes: if varnode.value is not None: args.append(varnode.value) else: args.append(None) return args infer_context() Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"]. Source code in ghidralib.py def infer_context(self): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"].\"\"\" basicblock = BasicBlock(self._address) return Emulator.new(basicblock.start_address, self._address) GenericT Source code in ghidralib.py class GenericT: pass GhidraWrapper Bases: object The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py class GhidraWrapper(object): \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__(self, raw): # type: (JavaObject|int|str|GhidraWrapper) -> None \"\"\"Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: * If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. * If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). * If \"raw\" is None at this point, raise an exception. * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. * Save the final \"raw\" value.\"\"\" if isinstance(raw, (int, long, str, unicode, GenericAddress)): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr(self, \"get\"): new_raw = self.get(raw) # type: ignore if new_raw is None: # Show original data for better error messages raise RuntimeError(\"Unable to wrap \" + str(raw)) raw = new_raw else: raise RuntimeError(\"Unable to wrap a primitive: \" + str(raw)) while isinstance(raw, GhidraWrapper): # In case someone tries to Function(Function(\"main\")) us raw = raw.raw if raw is None: raise RuntimeError(\"Object doesn't exist (refusing to wrap None)\") # TODO - remove the conditional checks and implement this everywhere if hasattr(self, \"UNDERLYING_CLASS\"): wrapped_type = getattr(self, \"UNDERLYING_CLASS\") if not isinstance(raw, wrapped_type): raise RuntimeError( \"You are trying to wrap {} as {}\".format( raw.__class__.__name__, self.__class__.__name__ ) ) def _java_cast(raw): # type: (Any) -> JavaObject \"\"\"This function exists only to make type-checker happy\"\"\" return raw self.raw = _java_cast(raw) def __str__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__str__() def __repr__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__repr__() def __tojava__(self, klass): \"\"\"Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet.\"\"\" return self.raw def __hash__(self): # type: () -> int \"\"\"Return the hash of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.hashCode() def __eq__(self, other): # type: (object) -> bool \"\"\"Check if this object is equal to another. This just forwards the call to the underlying object.\"\"\" if isinstance(other, GhidraWrapper): return self.raw.equals(other.raw) return self.raw.equals(other) raw = _java_cast(raw) instance-attribute __eq__(other) Check if this object is equal to another. This just forwards the call to the underlying object. Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Check if this object is equal to another. This just forwards the call to the underlying object.\"\"\" if isinstance(other, GhidraWrapper): return self.raw.equals(other.raw) return self.raw.equals(other) __hash__() Return the hash of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __hash__(self): # type: () -> int \"\"\"Return the hash of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.hashCode() __init__(raw) Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). If \"raw\" is None at this point, raise an exception. If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. Save the final \"raw\" value. Source code in ghidralib.py def __init__(self, raw): # type: (JavaObject|int|str|GhidraWrapper) -> None \"\"\"Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: * If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. * If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). * If \"raw\" is None at this point, raise an exception. * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. * Save the final \"raw\" value.\"\"\" if isinstance(raw, (int, long, str, unicode, GenericAddress)): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr(self, \"get\"): new_raw = self.get(raw) # type: ignore if new_raw is None: # Show original data for better error messages raise RuntimeError(\"Unable to wrap \" + str(raw)) raw = new_raw else: raise RuntimeError(\"Unable to wrap a primitive: \" + str(raw)) while isinstance(raw, GhidraWrapper): # In case someone tries to Function(Function(\"main\")) us raw = raw.raw if raw is None: raise RuntimeError(\"Object doesn't exist (refusing to wrap None)\") # TODO - remove the conditional checks and implement this everywhere if hasattr(self, \"UNDERLYING_CLASS\"): wrapped_type = getattr(self, \"UNDERLYING_CLASS\") if not isinstance(raw, wrapped_type): raise RuntimeError( \"You are trying to wrap {} as {}\".format( raw.__class__.__name__, self.__class__.__name__ ) ) def _java_cast(raw): # type: (Any) -> JavaObject \"\"\"This function exists only to make type-checker happy\"\"\" return raw self.raw = _java_cast(raw) __repr__() Return a string representation of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __repr__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__repr__() __str__() Return a string representation of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __str__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__str__() __tojava__(klass) Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet. Source code in ghidralib.py def __tojava__(self, klass): \"\"\"Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet.\"\"\" return self.raw Graph Bases: GenericT , GhidraWrapper Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see _get_unique_string() method. Source code in ghidralib.py class Graph(GenericT, GhidraWrapper): \"\"\"Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see _get_unique_string() method.\"\"\" # TODO: maybe this should be a GDirectedGraph, so we get some algorithms # for free, and we can just convert it for display. def __init__(self, raw): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper.__init__(self, raw) self.data = {} @staticmethod def create(name=None, description=None): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType(name, description, ArrayList([]), ArrayList([])) return Graph(AttributedGraph(name, graphtype, description)) @staticmethod def construct( vertexlist, getedges ): # type: (list[T], Callable[[T], list[T]]) -> Graph[T] \"\"\"Create a new Graph from a list of vertices and a function to get edges. :param vertexlist: The list of vertices. :param getedges: A function that gets a list of destinations from a vertex.\"\"\" g = Graph.create() for v in vertexlist: g.vertex(v) for v in vertexlist: for dest in getedges(v): if dest in g: g.edge(v, dest) return g def __contains__(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = _get_unique_string(vtx) vobj = self.raw.getVertex(vid) return self.raw.containsVertex(vobj) def has_vertex(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self def vertex(self, vtx, name=None): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = _get_unique_string(vtx) name = name or str(vtx) self.raw.addVertex(vid, name) self.data[vid] = vtx return vtx def edge(self, src, dst): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = _get_unique_string(src) dstid = _get_unique_string(dst) srcobj = self.raw.getVertex(srcid) dstobj = self.raw.getVertex(dstid) self.raw.addEdge(srcobj, dstobj) @property def vertices(self): # type: () -> list[T] \"\"\"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.\"\"\" return [self.__resolve(vid.getId()) for vid in self.raw.vertexSet()] @property def vertex_count(self): # type: () -> int \"\"\"Return the number of vertices in this graph.\"\"\" return self.raw.vertexSet().size() def __len__(self): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self.vertex_count @property def edges(self): # type: () -> list[tuple[T, T]] \"\"\"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.\"\"\" result = [] for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) frmobj = self.data.get(frm, frm) toobj = self.data.get(to, to) result.append((frmobj, toobj)) return result @property def edge_count(self): # type: () -> int \"\"\"Return the number of edges in this graph.\"\"\" return self.raw.edgeSet().size() @property def name(self): # type: () -> str \"\"\"Return the name of this graph.\"\"\" return self.raw.getName() @property def description(self): # type: () -> str \"\"\"Return the description of this graph.\"\"\" return self.raw.getDescription() def to_dot(self): # type: () -> str \"\"\"Return a DOT representation of this graph.\"\"\" result = [] result.append(\"digraph {} {{\".format(self.name)) for v in self.raw.vertexSet(): result.append(' \"{}\" [label=\"{}\"];'.format(v.getId(), v.getName())) for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) result.append(' \"{}\" -> \"{}\";'.format(frm.getId(), to.getId())) result.append(\"}\") return \"\\n\".join(result) def show(self): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self.raw.getGraphType() description = graphtype.getDescription() options = GraphDisplayOptions(graphtype) broker = getState().tool.getService(GraphDisplayBroker) display = broker.getDefaultGraphDisplay(False, getMonitor()) display.setGraph(self.raw, options, description, False, getMonitor()) def __resolve(self, vid): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self.data: return self.data[vid] else: return vid # type: ignore graph created outside of ghidralib? def dfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop() if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents def toposort(self, origin): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] :param origin: The ID of the origin vertex to start the sort from. :returns: a list of vertex IDs in topological order.\"\"\" visited = set() result = [] def dfs(vid): visited.add(vid) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): target = self.raw.getEdgeTarget(edge) if target.getId() not in visited: dfs(target.getId()) result.append(self.__resolve(vid)) dfs(_get_unique_string(origin)) for vid in self.raw.vertexSet(): if vid.getId() not in visited: dfs(vid.getId()) return result def bfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop(0) if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents data = {} instance-attribute description property Return the description of this graph. edge_count property Return the number of edges in this graph. edges property Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting. name property Return the name of this graph. vertex_count property Return the number of vertices in this graph. vertices property Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting. __contains__(vtx) Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py def __contains__(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = _get_unique_string(vtx) vobj = self.raw.getVertex(vid) return self.raw.containsVertex(vobj) __init__(raw) Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. Parameters: raw \u2013 The AttributedGraph object to wrap. Source code in ghidralib.py def __init__(self, raw): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper.__init__(self, raw) self.data = {} __len__() Return the number of vertices in this graph. To get the number of edges, use edge_count. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self.vertex_count __resolve(vid) Resolve a vertex ID to a vertex object. Parameters: vid \u2013 The ID of the vertex to resolve. Source code in ghidralib.py def __resolve(self, vid): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self.data: return self.data[vid] else: return vid # type: ignore graph created outside of ghidralib? bfs(origin, callback=lambda _: None) Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Source code in ghidralib.py def bfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop(0) if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents construct(vertexlist, getedges) staticmethod Create a new Graph from a list of vertices and a function to get edges. Parameters: vertexlist \u2013 The list of vertices. getedges \u2013 A function that gets a list of destinations from a vertex. Source code in ghidralib.py @staticmethod def construct( vertexlist, getedges ): # type: (list[T], Callable[[T], list[T]]) -> Graph[T] \"\"\"Create a new Graph from a list of vertices and a function to get edges. :param vertexlist: The list of vertices. :param getedges: A function that gets a list of destinations from a vertex.\"\"\" g = Graph.create() for v in vertexlist: g.vertex(v) for v in vertexlist: for dest in getedges(v): if dest in g: g.edge(v, dest) return g create(name=None, description=None) staticmethod Create a new Graph. Parameters: name \u2013 The name of the graph. If None, a default name will be used. description \u2013 The description of the graph. If None, a default description will be used. Returns: \u2013 a new Graph object. Source code in ghidralib.py @staticmethod def create(name=None, description=None): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType(name, description, ArrayList([]), ArrayList([])) return Graph(AttributedGraph(name, graphtype, description)) dfs(origin, callback=lambda _: None) Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Returns: \u2013 A dictionary of parent vertices for each visited vertex. Source code in ghidralib.py def dfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop() if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents edge(src, dst) Create an edge between two vertices in this graph. Parameters: src \u2013 The source vertex ID. dst \u2013 The destination vertex ID. Source code in ghidralib.py def edge(self, src, dst): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = _get_unique_string(src) dstid = _get_unique_string(dst) srcobj = self.raw.getVertex(srcid) dstobj = self.raw.getVertex(dstid) self.raw.addEdge(srcobj, dstobj) has_vertex(vtx) Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py def has_vertex(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self show() Display this graph in the Ghidra GUI. Source code in ghidralib.py def show(self): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self.raw.getGraphType() description = graphtype.getDescription() options = GraphDisplayOptions(graphtype) broker = getState().tool.getService(GraphDisplayBroker) display = broker.getDefaultGraphDisplay(False, getMonitor()) display.setGraph(self.raw, options, description, False, getMonitor()) to_dot() Return a DOT representation of this graph. Source code in ghidralib.py def to_dot(self): # type: () -> str \"\"\"Return a DOT representation of this graph.\"\"\" result = [] result.append(\"digraph {} {{\".format(self.name)) for v in self.raw.vertexSet(): result.append(' \"{}\" [label=\"{}\"];'.format(v.getId(), v.getName())) for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) result.append(' \"{}\" -> \"{}\";'.format(frm.getId(), to.getId())) result.append(\"}\") return \"\\n\".join(result) toposort(origin) Perform a topological sort on this graph, starting from the given vertex. Parameters: origin \u2013 The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] Returns: \u2013 a list of vertex IDs in topological order. Source code in ghidralib.py def toposort(self, origin): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] :param origin: The ID of the origin vertex to start the sort from. :returns: a list of vertex IDs in topological order.\"\"\" visited = set() result = [] def dfs(vid): visited.add(vid) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): target = self.raw.getEdgeTarget(edge) if target.getId() not in visited: dfs(target.getId()) result.append(self.__resolve(vid)) dfs(_get_unique_string(origin)) for vid in self.raw.vertexSet(): if vid.getId() not in visited: dfs(vid.getId()) return result vertex(vtx, name=None) Get or create a vertex in this graph. Parameters: vtx \u2013 The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. name \u2013 The name of the vertex. If not provided, the ID will be used as the name. Returns: \u2013 vtx parameter is returned Source code in ghidralib.py def vertex(self, vtx, name=None): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = _get_unique_string(vtx) name = name or str(vtx) self.raw.addVertex(vid, name) self.data[vid] = vtx return vtx HighFunction Bases: GhidraWrapper Source code in ghidralib.py class HighFunction(GhidraWrapper): @staticmethod def get(address): # type: (JavaObject|str|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance(address, GhHighFunction): return HighFunction(address) func = Function.get(address) if func is None: return None return func.high_function @property def function(self): # type: () -> Function \"\"\"Get the underlying function of this high function.\"\"\" return Function(self.raw.getFunction()) def get_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve(address) return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)] @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.\"\"\" return [PcodeOp(raw) for raw in self.raw.getPcodeOps()] @property def data_flow(self): # type: () -> Graph[PcodeOp] \"\"\"Get a data flow graph of varnodes in this function. Note: I don't think this method is currently very useful, but you can use it to easily get information about all varnodes that impact a value of another varnode :returns: A graph where vertexes are varnodes, and edges mean that target varnode is a result of operation on source varnodes.\"\"\" g = Graph.create() for op in self.pcode: if op.output: for inp in op.inputs: g.vertex(op.output) g.vertex(inp) g.edge(inp, op.output) return g @property def basicblocks(self): # type: () -> list[PcodeBlock] \"\"\"Get a list of basic blocks in this high function.\"\"\" return [PcodeBlock(raw) for raw in self.raw.getBasicBlocks()] @property def pcode_tree(self): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" edge_map = {} ingraph = GhBlockGraph() for block in self.basicblocks: gb = BlockCopy(block.raw, block.raw.getStart()) ingraph.addBlock(gb) edge_map[block.raw] = gb for block in self.basicblocks: for edge in block.outgoing_edges: ingraph.addEdge(edge_map[block.raw], edge_map[edge.raw]) ingraph.setIndices() decompiler = DecompInterface() decompiler.openProgram(Program.current()) outgraph = decompiler.structureGraph(ingraph, 0, getMonitor()) return BlockGraph(outgraph) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes used in this function.\"\"\" return [Varnode(raw) for raw in self.raw.locRange()] @property def symbols(self): # type: () -> list[HighSymbol] \"\"\"Get high symbols used in this function (including parameters).\"\"\" sm = self.raw.getLocalSymbolMap() return [HighSymbol(symbol) for symbol in sm.getSymbols()] @property def variables(self): # type: () -> list[HighVariable] \"\"\"Get high variables defined in this function.\"\"\" result = [] for sym in self.symbols: var = sym.variable if var is not None: result.append(var) return result def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance(other, HighFunction): return False return self.function == other.function basicblocks property Get a list of basic blocks in this high function. data_flow property Get a data flow graph of varnodes in this function. Note: I don't think this method is currently very useful, but you can use it to easily get information about all varnodes that impact a value of another varnode Returns: \u2013 A graph where vertexes are varnodes, and edges mean that target varnode is a result of operation on source varnodes. function property Get the underlying function of this high function. pcode property Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally. pcode_tree property Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. symbols property Get high symbols used in this function (including parameters). variables property Get high variables defined in this function. varnodes property Get all varnodes used in this function. __eq__(other) Compare two high functions. Fun fact - Ghidra doesn't know how to do this. Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance(other, HighFunction): return False return self.function == other.function get(address) staticmethod Get a HighFunction at a given address, or None if there is none. Source code in ghidralib.py @staticmethod def get(address): # type: (JavaObject|str|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance(address, GhHighFunction): return HighFunction(address) func = Function.get(address) if func is None: return None return func.high_function get_pcode_at(address) Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address. Source code in ghidralib.py def get_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve(address) return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)] HighSymbol Bases: GhidraWrapper Source code in ghidralib.py class HighSymbol(GhidraWrapper): def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source) @property def size(self): # type: () -> int \"\"\"Return the size of this symbol in bytes\"\"\" return self.raw.getSize() @property def data_type(self): # type: () -> DataType \"\"\"Return the data type of this symbol\"\"\" return DataType(self.raw.getDataType()) @property def variable(self): # type: () -> HighVariable|None \"\"\"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.\"\"\" raw = self.raw.getHighVariable() if raw is None: return None return HighVariable(raw) @property def name(self): # type: () -> str \"\"\"Return the name of this symbol\"\"\" return self.raw.getName() @property def symbol(self): # type: () -> Symbol|None \"\"\"Get the corresponding symbol, if it exists.\"\"\" raw = self.raw.getSymbol() if raw is None: return None return Symbol(raw) @property def is_this_pointer(self): # type: () -> bool \"\"\"Return True if this symbol is a \"this\" pointer for a class\"\"\" return self.raw.isThisPointer() data_type property Return the data type of this symbol is_this_pointer property Return True if this symbol is a \"this\" pointer for a class name property Return the name of this symbol size property Return the size of this symbol in bytes symbol property Get the corresponding symbol, if it exists. variable property Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one. rename(new_name, source=SourceType.USER_DEFINED) Rename this high symbol. Parameters: new_name \u2013 The new name of the symbol source \u2013 The source of the symbol Source code in ghidralib.py def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source) HighVariable Bases: GhidraWrapper Source code in ghidralib.py class HighVariable(GhidraWrapper): @property def symbol(self): # type: () -> HighSymbol return HighSymbol(self.raw.getSymbol()) def rename(self, new_name): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self.symbol.rename(new_name) @property def size(self): # type: () -> int \"\"\"Return the size of this variable in bytes\"\"\" return self.raw.getSize() @property def data_type(self): # type: () -> DataType \"\"\"Return the data type of this variable\"\"\" return DataType(self.raw.getDataType()) @property def name(self): # type: () -> str \"\"\"Return the name of this variable\"\"\" return self.raw.getName() @property def varnode(self): # type: () -> Varnode \"\"\"Return the Varnode that represents this variable\"\"\" return Varnode(self.raw.getRepresentative()) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Return all Varnodes that represent this variable at some point\"\"\" return [Varnode(vn) for vn in self.raw.getInstances()] @property def is_unaffected(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are is unaffected.\"\"\" return any(vn.is_unaffected for vn in self.varnodes) @property def is_persistent(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are persistent.\"\"\" return any(vn.is_persistent for vn in self.varnodes) @property def is_addr_tied(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are addr tied.\"\"\" return any(vn.is_addr_tied for vn in self.varnodes) @property def is_input(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are input.\"\"\" return any(vn.is_input for vn in self.varnodes) @property def is_free(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are free.\"\"\" return all(vn.is_free for vn in self.varnodes) data_type property Return the data type of this variable is_addr_tied property Return True if ALL varnodes of this variable are addr tied. is_free property Return True if ALL varnodes of this variable are free. is_input property Return True if ALL varnodes of this variable are input. is_persistent property Return True if ALL varnodes of this variable are persistent. is_unaffected property Return True if ALL varnodes of this variable are is unaffected. name property Return the name of this variable size property Return the size of this variable in bytes symbol property varnode property Return the Varnode that represents this variable varnodes property Return all Varnodes that represent this variable at some point rename(new_name) Rename this high variable. Source code in ghidralib.py def rename(self, new_name): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self.symbol.rename(new_name) Instruction Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Instruction object Source code in ghidralib.py class Instruction(GhidraWrapper, BodyTrait): \"\"\"Wraps a Ghidra Instruction object\"\"\" @staticmethod def get(address): # type: (JavaObject|str|Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve(address): raw = getInstructionAt(resolve(address)) else: raw = address if raw is None: return None return Instruction(raw) @staticmethod def all(): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program.current().getListing().getInstructions(True) return [Instruction(raw) for raw in raw_instructions] @staticmethod def create(address): # type: (Addr) -> Instruction \"\"\"Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use `assemble_at` instead. If you want to just create an instruction object, use `assemble` method. :param address: The address where instruction should be created. \"\"\" addr = resolve(address) disassemble(addr) return Instruction(addr) @property def mnemonic(self): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self.raw.getMnemonicString() @property def next(self): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction(self.raw.getNext()) @property def previous(self): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction(self.raw.getPrevious()) prev = previous @property def flows(self): # type: () -> list[int] \"\"\"Get a set of possible flows (next executed addresses). Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO, but I'm being faithful to Ghidra API.\"\"\" return [addr.getOffset() for addr in self.raw.getFlows()] @property def all_flows(self): # type: () -> list[int] \"\"\"Get a set of possible flows (next executed addresses). Note: this INCLUDES fallthrough.\"\"\" fallthrough = self.fallthrough return self.flows + ([fallthrough] if fallthrough else []) @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [PcodeOp(raw) for raw in self.raw.getPcode()] @property def output_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of output (LOW) varnodes for this instruction.\"\"\" return [op.output for op in self.pcode if op.output] @property def input_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of output (LOW) varnodes for this instruction.\"\"\" return [inp for op in self.pcode if op.output for inp in op.inputs] @property def high_pcode(self): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp.get_high_pcode_at(self.address) @property def xrefs_from(self): # type: () -> list[Reference] \"\"\"Get a list of references from this instruction.\"\"\" return [Reference(raw) for raw in self.raw.getReferencesFrom()] @property def xrefs_to(self): # type: () -> list[Reference] \"\"\"Get a list of references to this instruction.\"\"\" return [Reference(raw) for raw in self.raw.getReferenceIteratorTo()] @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return _bytes_from_bytelist(self.raw.getBytes()) @property def length(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.raw.getLength() def __len__(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.length def __convert_operand(self, operand): # type: (JavaObject) -> Operand \"\"\"Convert an operand to a scalar or address.\"\"\" from ghidra.program.model.address import Address # type: ignore from ghidra.program.model.scalar import Scalar # type: ignore if isinstance(operand, GhRegister): return Operand(_python_str(operand.getName())) elif isinstance(operand, Address): return Operand(operand.getOffset()) elif isinstance(operand, Scalar): return Operand(operand.getValue()) elif _is_array(operand): operands = [self.__convert_operand(o).raw for o in operand] # type: ignore if len(operands) == 1: # Unwrap the operands if there is only one operand return Operand(operands[0]) return Operand(operands) # type: ignore (we know there are no nested lists) else: raise RuntimeError(\"Don't know how to read operand {}\".format(operand)) def operand(self, ndx): # type: (int) -> Operand \"\"\"Get the nth operand of this instruction as an object.\"\"\" operand = self.raw.getOpObjects(ndx) return self.__convert_operand(operand) @property def address(self): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self.raw.getAddress().getOffset() @property def operands(self): # type: () -> list[Operand] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. If you know operand type, call .scalar(), .register() or .list() instead.\"\"\" return [self.operand(i) for i in range(self.raw.getNumOperands())] @property def operand_values(self): # type: () -> list[int|str|list[int|str]] \"\"\"Return operands as primitive values (int or a string representation). This is equivalent to calling .operands() and then calling .value() on each operand.\"\"\" return [operand.value for operand in self.operands] @property def flow_type(self): # type: () -> FlowType \"\"\"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return FlowType(self.raw.getFlowType()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference( self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type) @property def body(self): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet.create(self.address, self.length) @property def has_fallthrough(self): # type: () -> bool \"\"\"Return true if this instruction has a fallthrough.\"\"\" return self.raw.hasFallthrough() @property def fallthrough(self): # type: () -> int|None \"\"\"Get the fallthrough address (next address executed), if any. For normal instruction, this is the next instruction address. For jumps, this is None. Can be overriden by fallthrough override.\"\"\" fall = self.raw.getFallThrough() if not fall: return None return fall.getOffset() def set_fallthrough_override(self, value): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override :param value: new fallthrough address\"\"\" self.raw.setFallThrough(resolve(value)) def clear_fallthrough_override(self): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" self.raw.clearFallThroughOverride() @property def has_fallthrough_override(self): # type: () -> bool \"\"\"Return true if this instruction fallthrough was overriden.\"\"\" return self.raw.isFallThroughOverridden() def write_jumptable(self, targets): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [resolve(addr) for addr in targets] for dest in targets: disassemble(dest) self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP) func = Function.get(self.address) if func is None: raise RuntimeError(\"Instruction is not part of a function\") targetlist = ArrayList([dest for dest in targets]) jumpTab = JumpTable(toAddr(self.address), targetlist, True) jumpTab.writeOverride(func.raw) CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor()) address property Get the address of this instruction. all_flows property Get a set of possible flows (next executed addresses). Note: this INCLUDES fallthrough. body property Get the address range this instruction. bytes property Get the bytes of this instruction. fallthrough property Get the fallthrough address (next address executed), if any. For normal instruction, this is the next instruction address. For jumps, this is None. Can be overriden by fallthrough override. flow_type property Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP flows property Get a set of possible flows (next executed addresses). Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO, but I'm being faithful to Ghidra API. has_fallthrough property Return true if this instruction has a fallthrough. has_fallthrough_override property Return true if this instruction fallthrough was overriden. high_pcode property Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead. input_varnodes property Get a list of output (LOW) varnodes for this instruction. length property Get the length of this instruction in bytes. mnemonic property Get the mnemonic of this instruction. next property Get the next instruction. operand_values property Return operands as primitive values (int or a string representation). This is equivalent to calling .operands() and then calling .value() on each operand. operands property Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. If you know operand type, call .scalar(), .register() or .list() instead. output_varnodes property Get a list of output (LOW) varnodes for this instruction. pcode property Get a list of Pcode operations that this instruction was parsed to prev = previous class-attribute instance-attribute previous property Get the previous instruction. xrefs_from property Get a list of references from this instruction. xrefs_to property Get a list of references to this instruction. __convert_operand(operand) Convert an operand to a scalar or address. Source code in ghidralib.py def __convert_operand(self, operand): # type: (JavaObject) -> Operand \"\"\"Convert an operand to a scalar or address.\"\"\" from ghidra.program.model.address import Address # type: ignore from ghidra.program.model.scalar import Scalar # type: ignore if isinstance(operand, GhRegister): return Operand(_python_str(operand.getName())) elif isinstance(operand, Address): return Operand(operand.getOffset()) elif isinstance(operand, Scalar): return Operand(operand.getValue()) elif _is_array(operand): operands = [self.__convert_operand(o).raw for o in operand] # type: ignore if len(operands) == 1: # Unwrap the operands if there is only one operand return Operand(operands[0]) return Operand(operands) # type: ignore (we know there are no nested lists) else: raise RuntimeError(\"Don't know how to read operand {}\".format(operand)) __len__() Get the length of this instruction in bytes. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.length add_operand_reference(op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED) Add a reference to an operand of this instruction. Source code in ghidralib.py def add_operand_reference( self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type) all() staticmethod Get all instruction defined in the current program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program.current().getListing().getInstructions(True) return [Instruction(raw) for raw in raw_instructions] clear_fallthrough_override() This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override Source code in ghidralib.py def clear_fallthrough_override(self): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" self.raw.clearFallThroughOverride() create(address) staticmethod Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use assemble_at instead. If you want to just create an instruction object, use assemble method. Parameters: address \u2013 The address where instruction should be created. Source code in ghidralib.py @staticmethod def create(address): # type: (Addr) -> Instruction \"\"\"Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use `assemble_at` instead. If you want to just create an instruction object, use `assemble` method. :param address: The address where instruction should be created. \"\"\" addr = resolve(address) disassemble(addr) return Instruction(addr) get(address) staticmethod Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func: disassemble_at instead. Parameters: address \u2013 The address of the instruction. Returns: \u2013 The instruction at the address, or None if not found. Source code in ghidralib.py @staticmethod def get(address): # type: (JavaObject|str|Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve(address): raw = getInstructionAt(resolve(address)) else: raw = address if raw is None: return None return Instruction(raw) operand(ndx) Get the nth operand of this instruction as an object. Source code in ghidralib.py def operand(self, ndx): # type: (int) -> Operand \"\"\"Get the nth operand of this instruction as an object.\"\"\" operand = self.raw.getOpObjects(ndx) return self.__convert_operand(operand) set_fallthrough_override(value) Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override Parameters: value \u2013 new fallthrough address Source code in ghidralib.py def set_fallthrough_override(self, value): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override :param value: new fallthrough address\"\"\" self.raw.setFallThrough(resolve(value)) write_jumptable(targets) Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?). Source code in ghidralib.py def write_jumptable(self, targets): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [resolve(addr) for addr in targets] for dest in targets: disassemble(dest) self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP) func = Function.get(self.address) if func is None: raise RuntimeError(\"Instruction is not part of a function\") targetlist = ArrayList([dest for dest in targets]) jumpTab = JumpTable(toAddr(self.address), targetlist, True) jumpTab.writeOverride(func.raw) CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor()) JavaObject A fake class, used for static type hints. Source code in ghidralib.py class JavaObject: \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__(self, name): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass __getattribute__(name) This attribute exists to make mypy happy. Source code in ghidralib.py def __getattribute__(self, name): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass MemoryBlock Bases: GhidraWrapper , BodyTrait A Ghidra wrapper for a Ghidra MemoryBlock Source code in ghidralib.py class MemoryBlock(GhidraWrapper, BodyTrait): \"\"\"A Ghidra wrapper for a Ghidra MemoryBlock\"\"\" @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> MemoryBlock|None \"\"\"Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address :param raw_or_name: name or address of MemoryBlock to get :return: the MemoryBlock, or None if not found \"\"\" memory = Program.current().getMemory() if isinstance(raw_or_name, str): raw = memory.getBlock(raw_or_name) if raw is not None: return MemoryBlock(raw) addr = try_resolve(raw_or_name) if addr is None: return None return MemoryBlock(memory.getBlock(addr)) @staticmethod def all(): # type: () -> list[MemoryBlock] \"\"\"Get all MemoryBlocks in the current program\"\"\" raw_blocks = Program.current().getMemory().getBlocks() return [MemoryBlock(raw) for raw in raw_blocks] @property def comment(self): # type: () -> str \"\"\"Get the comment associated with this MemoryBlock\"\"\" return self.raw.getComment() @property def start(self): # type: () -> int \"\"\"Get the first address of this MemoryBlock\"\"\" return self.raw.getStart().getOffset() @property def name(self): # type: () -> str \"\"\"Get the name of this MemoryBlock\"\"\" return self.raw.getName() address = start @property def end(self): # type: () -> int return self.raw.getEnd().getOffset() @property def size(self): # type: () -> int \"\"\"Get the size of this MemoryBlock\"\"\" return int(self.raw.getSize()) length = size @property def body(self): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet.create(self.address, self.length) @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return read_bytes(self.address, self.length) address = start class-attribute instance-attribute body property Get the address range this instruction. bytes property Get the bytes of this instruction. comment property Get the comment associated with this MemoryBlock end property length = size class-attribute instance-attribute name property Get the name of this MemoryBlock size property Get the size of this MemoryBlock start property Get the first address of this MemoryBlock all() staticmethod Get all MemoryBlocks in the current program Source code in ghidralib.py @staticmethod def all(): # type: () -> list[MemoryBlock] \"\"\"Get all MemoryBlocks in the current program\"\"\" raw_blocks = Program.current().getMemory().getBlocks() return [MemoryBlock(raw) for raw in raw_blocks] get(raw_or_name) staticmethod Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address Parameters: raw_or_name \u2013 name or address of MemoryBlock to get Returns: \u2013 the MemoryBlock, or None if not found Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> MemoryBlock|None \"\"\"Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address :param raw_or_name: name or address of MemoryBlock to get :return: the MemoryBlock, or None if not found \"\"\" memory = Program.current().getMemory() if isinstance(raw_or_name, str): raw = memory.getBlock(raw_or_name) if raw is not None: return MemoryBlock(raw) addr = try_resolve(raw_or_name) if addr is None: return None return MemoryBlock(memory.getBlock(addr)) Operand Operand helper for instruction, may be a register, const or a list Source code in ghidralib.py class Operand: \"\"\"Operand helper for instruction, may be a register, const or a list\"\"\" def __init__(self, operand): # type: (str|int|list[int|str]) -> None self.raw = operand @property def is_register(self): # type: () -> bool \"\"\"Return True if this operand is a register.\"\"\" return isinstance(self.raw, Str) @property def is_scalar(self): # type: () -> bool \"\"\"Return True if this operand is a scalar.\"\"\" return isinstance(self.raw, (int, long)) @property def is_list(self): # type: () -> bool \"\"\"Return True if this operand is a list.\"\"\" return isinstance(self.raw, list) @property def register(self): # type: () -> str \"\"\"Gets this operand value as a register name\"\"\" if not isinstance(self.raw, (str)): raise RuntimeError(\"Operand {} is not a register\".format(self.raw)) return self.raw @property def scalar(self): # type: () -> int \"\"\"Gets this operand value as a scalar\"\"\" if not isinstance(self.raw, (int, long)): raise RuntimeError(\"Operand {} is not a scalar\".format(self.raw)) return self.raw @property def list(self): # type: () -> list \"\"\"Gets this operand value as a list\"\"\" if not isinstance(self.raw, list): raise RuntimeError(\"Operand {} is not a list\".format(self.raw)) return self.raw @property def value(self): # type: () -> str|int|list[int|str] \"\"\"Return internal representation of this operand - string, int or a list\"\"\" return self.raw is_list property Return True if this operand is a list. is_register property Return True if this operand is a register. is_scalar property Return True if this operand is a scalar. list property Gets this operand value as a list raw = operand instance-attribute register property Gets this operand value as a register name scalar property Gets this operand value as a scalar value property Return internal representation of this operand - string, int or a list __init__(operand) Source code in ghidralib.py def __init__(self, operand): # type: (str|int|list[int|str]) -> None self.raw = operand Parameter Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py class Parameter(Variable): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal(self): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self.raw.getOrdinal() @property def formal_data_type(self): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType(self.raw.getFormalDataType()) formal_data_type property Returns the formal data type of this parameter. ordinal property Returns the ordinal of this parameter. PcodeBlock Bases: GhidraWrapper Source code in ghidralib.py class PcodeBlock(GhidraWrapper): @property def outgoing_edges(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getOut(i)) for i in range(self.raw.getOutSize())] @property def incoming_edges(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getIn(i)) for i in range(self.raw.getInSize())] @property def has_children(self): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance(self.raw, GhBlockGraph) @property def pcode(self): # type: () -> list[PcodeOp] raw_pcode = collect_iterator(self.raw.getRef().getIterator()) return [PcodeOp(raw) for raw in raw_pcode] has_children property Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph. incoming_edges property outgoing_edges property pcode property PcodeOp Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py class PcodeOp(GhidraWrapper): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at(address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function(address).get_high_pcode_at(address) @property def address(self): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self.raw.getSeqnum().getTarget().getOffset() @property def opcode(self): # type: () -> int return self.raw.getOpcode() @property def mnemonic(self): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self.raw.getMnemonic() @property def inputs(self): # type: () -> list[Varnode] return [Varnode(raw) for raw in self.raw.getInputs()] @property def inputs_simple(self): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [varnode.simple for varnode in self.inputs] @property def output(self): # type: () -> Varnode|None if self.raw.getOutput() is None: return None return Varnode(self.raw.getOutput()) @property def result(self): # type: () -> int|None \"\"\"Try to evaluate the pcode operation to a constant value. Right now this is very poor and doesn't try to implement most of the opcodes. Mostly because I suspect I'm reinventing the wheel, and there is code to do this already in Ghidra. :return: Result of this operation, or None if can't be evaluated as const.\"\"\" if self.opcode == PcodeOp.COPY: return self.inputs[0].value return None BOOL_AND = 39 class-attribute instance-attribute BOOL_NEGATE = 37 class-attribute instance-attribute BOOL_OR = 40 class-attribute instance-attribute BOOL_XOR = 38 class-attribute instance-attribute BRANCH = 4 class-attribute instance-attribute BRANCHIND = 6 class-attribute instance-attribute CALL = 7 class-attribute instance-attribute CALLIND = 8 class-attribute instance-attribute CALLOTHER = 9 class-attribute instance-attribute CAST = 64 class-attribute instance-attribute CBRANCH = 5 class-attribute instance-attribute COPY = 1 class-attribute instance-attribute CPOOLREF = 68 class-attribute instance-attribute EXTRACT = 71 class-attribute instance-attribute FLOAT_ABS = 52 class-attribute instance-attribute FLOAT_ADD = 47 class-attribute instance-attribute FLOAT_CEIL = 57 class-attribute instance-attribute FLOAT_DIV = 48 class-attribute instance-attribute FLOAT_EQUAL = 41 class-attribute instance-attribute FLOAT_FLOAT2FLOAT = 55 class-attribute instance-attribute FLOAT_FLOOR = 58 class-attribute instance-attribute FLOAT_INT2FLOAT = 54 class-attribute instance-attribute FLOAT_LESS = 43 class-attribute instance-attribute FLOAT_LESSEQUAL = 44 class-attribute instance-attribute FLOAT_MULT = 49 class-attribute instance-attribute FLOAT_NAN = 46 class-attribute instance-attribute FLOAT_NEG = 51 class-attribute instance-attribute FLOAT_NOTEQUAL = 42 class-attribute instance-attribute FLOAT_ROUND = 59 class-attribute instance-attribute FLOAT_SQRT = 53 class-attribute instance-attribute FLOAT_SUB = 50 class-attribute instance-attribute FLOAT_TRUNC = 56 class-attribute instance-attribute INDIRECT = 61 class-attribute instance-attribute INSERT = 70 class-attribute instance-attribute INT_2COMP = 24 class-attribute instance-attribute INT_ADD = 19 class-attribute instance-attribute INT_AND = 27 class-attribute instance-attribute INT_CARRY = 21 class-attribute instance-attribute INT_DIV = 33 class-attribute instance-attribute INT_EQUAL = 11 class-attribute instance-attribute INT_LEFT = 29 class-attribute instance-attribute INT_LESS = 15 class-attribute instance-attribute INT_LESSEQUAL = 16 class-attribute instance-attribute INT_MULT = 32 class-attribute instance-attribute INT_NEGATE = 25 class-attribute instance-attribute INT_NOTEQUAL = 12 class-attribute instance-attribute INT_OR = 28 class-attribute instance-attribute INT_REM = 35 class-attribute instance-attribute INT_RIGHT = 30 class-attribute instance-attribute INT_SBORROW = 23 class-attribute instance-attribute INT_SCARRY = 22 class-attribute instance-attribute INT_SDIV = 34 class-attribute instance-attribute INT_SEXT = 18 class-attribute instance-attribute INT_SLESS = 13 class-attribute instance-attribute INT_SLESSEQUAL = 14 class-attribute instance-attribute INT_SREM = 36 class-attribute instance-attribute INT_SRIGHT = 31 class-attribute instance-attribute INT_SUB = 20 class-attribute instance-attribute INT_XOR = 26 class-attribute instance-attribute INT_ZEXT = 17 class-attribute instance-attribute LOAD = 2 class-attribute instance-attribute LZCOUNT = 73 class-attribute instance-attribute MULTIEQUAL = 60 class-attribute instance-attribute NEW = 69 class-attribute instance-attribute PCODE_MAX = 74 class-attribute instance-attribute PIECE = 62 class-attribute instance-attribute POPCOUNT = 72 class-attribute instance-attribute PTRADD = 65 class-attribute instance-attribute PTRSUB = 66 class-attribute instance-attribute RETURN = 10 class-attribute instance-attribute SEGMENTOP = 67 class-attribute instance-attribute STORE = 3 class-attribute instance-attribute SUBPIECE = 63 class-attribute instance-attribute UNIMPLEMENTED = 0 class-attribute instance-attribute address property Get an address in the program where this instruction is located inputs property inputs_simple property Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). mnemonic property Get a string representation of the operation, for example \"COPY\" opcode property output property result property Try to evaluate the pcode operation to a constant value. Right now this is very poor and doesn't try to implement most of the opcodes. Mostly because I suspect I'm reinventing the wheel, and there is code to do this already in Ghidra. Returns: \u2013 Result of this operation, or None if can't be evaluated as const. get_high_pcode_at(address) staticmethod Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py @staticmethod def get_high_pcode_at(address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function(address).get_high_pcode_at(address) Program Bases: GhidraWrapper A static class that represents the current program Source code in ghidralib.py class Program(GhidraWrapper): \"\"\"A static class that represents the current program\"\"\" @staticmethod def create_data(address, datatype): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType(datatype) addr = resolve(address) try: createData(addr, unwrap(typeobj)) except: clearListing(addr, addr.add(len(typeobj) - 1)) createData(addr, unwrap(typeobj)) @staticmethod def location(): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return getState().getCurrentLocation().getAddress().getOffset() @staticmethod def call_graph(): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" return Graph.construct(Function.all(), lambda f: f.called) @staticmethod def control_flow(): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" return Graph.construct(BasicBlock.all(), lambda b: b.destinations) @staticmethod def basicblocks(): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock.all() @staticmethod def memory_blocks(): # type: () -> list[MemoryBlock] \"\"\"Get memory blocks defined for the current program.\"\"\" return MemoryBlock.all() @staticmethod def functions(): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function.all() @staticmethod def instructions(): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction.all() @staticmethod def body(): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program.current().getNamespaceManager().getGlobalNamespace().getBody() return AddressSet(body) @staticmethod def current(): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram() @staticmethod def analyze(): # type: () -> None \"\"\"Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script.\"\"\" analyzeChanges(Program.current()) analyze() staticmethod Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script. Source code in ghidralib.py @staticmethod def analyze(): # type: () -> None \"\"\"Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script.\"\"\" analyzeChanges(Program.current()) basicblocks() staticmethod Get all the basic blocks defined in the program. Source code in ghidralib.py @staticmethod def basicblocks(): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock.all() body() staticmethod Get the set of all addresses of the program. Source code in ghidralib.py @staticmethod def body(): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program.current().getNamespaceManager().getGlobalNamespace().getBody() return AddressSet(body) call_graph() staticmethod Get the call graph for this program. Source code in ghidralib.py @staticmethod def call_graph(): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" return Graph.construct(Function.all(), lambda f: f.called) control_flow() staticmethod Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it. Source code in ghidralib.py @staticmethod def control_flow(): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" return Graph.construct(BasicBlock.all(), lambda b: b.destinations) create_data(address, datatype) staticmethod Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py @staticmethod def create_data(address, datatype): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType(datatype) addr = resolve(address) try: createData(addr, unwrap(typeobj)) except: clearListing(addr, addr.add(len(typeobj) - 1)) createData(addr, unwrap(typeobj)) current() staticmethod Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool). Source code in ghidralib.py @staticmethod def current(): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram() functions() staticmethod Get all the functions defined in the program. Source code in ghidralib.py @staticmethod def functions(): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function.all() instructions() staticmethod Get all the instructions defined in the program. Source code in ghidralib.py @staticmethod def instructions(): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction.all() location() staticmethod Get the current location in the program. >>> current_location() 0x1000 Returns: \u2013 the current location in the program Source code in ghidralib.py @staticmethod def location(): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return getState().getCurrentLocation().getAddress().getOffset() memory_blocks() staticmethod Get memory blocks defined for the current program. Source code in ghidralib.py @staticmethod def memory_blocks(): # type: () -> list[MemoryBlock] \"\"\"Get memory blocks defined for the current program.\"\"\" return MemoryBlock.all() RefType Bases: GhidraWrapper Source code in ghidralib.py class RefType(GhidraWrapper): @property def has_fallthrough(self): # type: () -> bool return self.raw.hasFallthrough() @has_fallthrough.setter def has_fallthrough(self, value): # type: (bool) -> None self.raw.setHasFall(value) @property def is_call(self): # type: () -> bool return self.raw.isCall() @is_call.setter def is_call(self, value): # type: (bool) -> None self.raw.setIsCall(value) @property def is_jump(self): # type: () -> bool return self.raw.isJump() @is_jump.setter def is_jump(self, value): # type: (bool) -> None self.raw.setIsJump(value) @property def is_computed(self): # type: () -> bool return self.raw.isComputed() @is_computed.setter def is_computed(self, value): # type: (bool) -> None self.raw.setIsComputed(value) @property def is_conditional(self): # type: () -> bool return self.raw.isConditional() @is_conditional.setter def is_conditional(self, value): # type: (bool) -> None self.raw.setIsConditional(value) @property def is_unconditional(self): # type: () -> bool return not self.is_conditional @property def is_terminal(self): # type: () -> bool return self.raw.isTerminal() @property def is_data(self): # type: () -> bool return self.raw.isData() @property def is_read(self): # type: () -> bool return self.raw.isRead() @property def is_write(self): # type: () -> bool return self.raw.isWrite() @property def is_flow(self): # type: () -> bool return self.raw.isFlow() @property def is_override(self): # type: () -> bool return self.raw.isOverride() INVALID = _reftype_placeholder() FLOW = _reftype_placeholder() FALL_THROUGH = _reftype_placeholder() UNCONDITIONAL_JUMP = _reftype_placeholder() CONDITIONAL_JUMP = _reftype_placeholder() UNCONDITIONAL_CALL = _reftype_placeholder() CONDITIONAL_CALL = _reftype_placeholder() TERMINATOR = _reftype_placeholder() COMPUTED_JUMP = _reftype_placeholder() CONDITIONAL_TERMINATOR = _reftype_placeholder() COMPUTED_CALL = _reftype_placeholder() CALL_TERMINATOR = _reftype_placeholder() COMPUTED_CALL_TERMINATOR = _reftype_placeholder() CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder() CONDITIONAL_COMPUTED_CALL = _reftype_placeholder() CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder() JUMP_TERMINATOR = _reftype_placeholder() INDIRECTION = _reftype_placeholder() CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() CALLOTHER_OVERRIDE_CALL = _reftype_placeholder() CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder() CALLOTHER_OVERRIDE_CALL = _reftype_placeholder() class-attribute instance-attribute CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder() class-attribute instance-attribute CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() class-attribute instance-attribute CALL_TERMINATOR = _reftype_placeholder() class-attribute instance-attribute COMPUTED_CALL = _reftype_placeholder() class-attribute instance-attribute COMPUTED_CALL_TERMINATOR = _reftype_placeholder() class-attribute instance-attribute COMPUTED_JUMP = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_CALL = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_COMPUTED_CALL = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_JUMP = _reftype_placeholder() class-attribute instance-attribute CONDITIONAL_TERMINATOR = _reftype_placeholder() class-attribute instance-attribute FALL_THROUGH = _reftype_placeholder() class-attribute instance-attribute FLOW = _reftype_placeholder() class-attribute instance-attribute INDIRECTION = _reftype_placeholder() class-attribute instance-attribute INVALID = _reftype_placeholder() class-attribute instance-attribute JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() class-attribute instance-attribute JUMP_TERMINATOR = _reftype_placeholder() class-attribute instance-attribute TERMINATOR = _reftype_placeholder() class-attribute instance-attribute UNCONDITIONAL_CALL = _reftype_placeholder() class-attribute instance-attribute UNCONDITIONAL_JUMP = _reftype_placeholder() class-attribute instance-attribute has_fallthrough property writable is_call property writable is_computed property writable is_conditional property writable is_data property is_flow property is_jump property writable is_override property is_read property is_terminal property is_unconditional property is_write property Reference Bases: GhidraWrapper Source code in ghidralib.py class Reference(GhidraWrapper): @property def is_call(self): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self.reftype.is_call @property def is_jump(self): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self.reftype.is_jump @property def reftype(self): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType(self.raw.getReferenceType()) @property def from_address(self): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self.raw.getFromAddress().getOffset() @property def to_address(self): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self.raw.getToAddress().getOffset() @property def source(self): # type: () -> SourceType return SourceType(self.raw.getSource()) from_address property Return the address of the source of the reference. is_call property Return True if the reference is a call. is_jump property Return True if the reference is a jump. reftype property Return the type of reference. source property to_address property Return the address of the target of the reference. Register Bases: GhidraWrapper Source code in ghidralib.py class Register(GhidraWrapper): @staticmethod def get(raw_or_name): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance(raw_or_name, Str): raw_or_name = Program.current().getLanguage().getRegister(raw_or_name) if raw_or_name is None: return None return Register(raw_or_name) @property def name(self): # type: () -> str \"\"\"Return the name of this register\"\"\" return self.raw.getName() @property def size(self): # type: () -> int \"\"\"Return the size of this register in bytes This will tell the total number of bytes this register contains - because register values don't have to be byte-aligned\"\"\" return self.raw.getNumBytes() @property def varnode(self): # type: () -> Varnode \"\"\"Return the varnode associated with this register Warning: this doesn't support registers that are not byte-aligned (for example, flag registers). It will round the address down to byte. \"\"\" raw = GhVarnode(self.raw.getAddress(), self.raw.getNumBytes()) return Varnode(raw) name property Return the name of this register size property Return the size of this register in bytes This will tell the total number of bytes this register contains - because register values don't have to be byte-aligned varnode property Return the varnode associated with this register Warning: this doesn't support registers that are not byte-aligned (for example, flag registers). It will round the address down to byte. get(raw_or_name) staticmethod Get a register by name Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance(raw_or_name, Str): raw_or_name = Program.current().getLanguage().getRegister(raw_or_name) if raw_or_name is None: return None return Register(raw_or_name) Symbol Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py class Symbol(GhidraWrapper): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def resolve_thunk_if_exists(external_symbol): # type: (JavaObject) -> JavaObject \"\"\"Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls `printf` it jumps to the appropriate `printf` thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. :param external_symbol: Symbol to find thunk for (if it exists). \"\"\" xrefs = list(external_symbol.getReferences()) for xref in xrefs: if xref.getReferenceType() == GhRefType.THUNK: addr = xref.getFromAddress() thunk = Program.current().getSymbolTable().getPrimarySymbol(addr) if thunk is not None: return thunk return external_symbol @staticmethod def resolve_external(external_symbol): # type: (JavaObject) -> int \"\"\"Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. :param external_symbol: External symbol to resolve.\"\"\" external_manager = Program.current().getExternalManager() ram_addr = external_manager.getExternalLocation(external_symbol).getAddress() if ram_addr: return ram_addr.getOffset() return external_symbol.getAddress().getOffset() @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance(raw_or_name, str): symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name) symbols = collect_iterator(symbol_iterator) if not symbols: return None raw = symbols[0] if raw.isExternal(): raw = Symbol.resolve_thunk_if_exists(raw) elif can_resolve(raw_or_name): raw = ( Program.current() .getSymbolTable() .getPrimarySymbol(resolve(raw_or_name)) ) if not raw: return None else: raw = raw_or_name return Symbol(raw) @staticmethod def all(): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True) symbols = collect_iterator(symbol_iterator) return [Symbol(s) for s in symbols] @staticmethod def create( address, name, source=SourceType.USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel(resolve(address), name, False, source) return Symbol(raw) @staticmethod def remove(address, name): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol(resolve(address), name) @property def address(self): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" if self.is_external: return Symbol.resolve_external(self.raw) return self.raw.getAddress().getOffset() @property def name(self): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self.raw.getName() @property def name_with_namespace(self): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self.raw.getName(True) @property def xrefs(self): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [Reference(raw) for raw in self.raw.getReferences()] xrefs_to = xrefs @property def xref_addrs(self): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [xref.from_address for xref in self.xrefs] def set_type(self, datatype): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program.create_data(self.address, datatype) def delete(self): # type: () -> None \"\"\"Delete this symbol.\"\"\" self.raw.delete() def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self.raw.setName(new_name, source) @property def is_external(self): # type: () -> bool \"\"\"Return true if this symbol is external, otherwise false. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :return: true if the symbol is external\"\"\" return self.raw.isExternal() address property Get the address of this symbol. is_external property Return true if this symbol is external, otherwise false. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). Returns: \u2013 true if the symbol is external name property Get the name of this symbol. name_with_namespace property Get the fully qualified name of this symbol. xref_addrs property Get the addresses of all references to this symbol. xrefs property Get a list of references to this symbol. xrefs_to = xrefs class-attribute instance-attribute all() staticmethod Get all symbols defined in the program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True) symbols = collect_iterator(symbol_iterator) return [Symbol(s) for s in symbols] create(address, name, source=SourceType.USER_DEFINED) staticmethod Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py @staticmethod def create( address, name, source=SourceType.USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel(resolve(address), name, False, source) return Symbol(raw) delete() Delete this symbol. Source code in ghidralib.py def delete(self): # type: () -> None \"\"\"Delete this symbol.\"\"\" self.raw.delete() get(raw_or_name) staticmethod Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance(raw_or_name, str): symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name) symbols = collect_iterator(symbol_iterator) if not symbols: return None raw = symbols[0] if raw.isExternal(): raw = Symbol.resolve_thunk_if_exists(raw) elif can_resolve(raw_or_name): raw = ( Program.current() .getSymbolTable() .getPrimarySymbol(resolve(raw_or_name)) ) if not raw: return None else: raw = raw_or_name return Symbol(raw) remove(address, name) staticmethod Remove the symbol with the given name at the given address. Parameters: address \u2013 the address of the symbol to remove. name \u2013 the name of the symbol to remove. Source code in ghidralib.py @staticmethod def remove(address, name): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol(resolve(address), name) rename(new_name, source=SourceType.USER_DEFINED) Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self.raw.setName(new_name, source) resolve_external(external_symbol) staticmethod Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. Parameters: external_symbol \u2013 External symbol to resolve. Source code in ghidralib.py @staticmethod def resolve_external(external_symbol): # type: (JavaObject) -> int \"\"\"Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. :param external_symbol: External symbol to resolve.\"\"\" external_manager = Program.current().getExternalManager() ram_addr = external_manager.getExternalLocation(external_symbol).getAddress() if ram_addr: return ram_addr.getOffset() return external_symbol.getAddress().getOffset() resolve_thunk_if_exists(external_symbol) staticmethod Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls printf it jumps to the appropriate printf thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. Parameters: external_symbol \u2013 Symbol to find thunk for (if it exists). Source code in ghidralib.py @staticmethod def resolve_thunk_if_exists(external_symbol): # type: (JavaObject) -> JavaObject \"\"\"Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls `printf` it jumps to the appropriate `printf` thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. :param external_symbol: Symbol to find thunk for (if it exists). \"\"\" xrefs = list(external_symbol.getReferences()) for xref in xrefs: if xref.getReferenceType() == GhRefType.THUNK: addr = xref.getFromAddress() thunk = Program.current().getSymbolTable().getPrimarySymbol(addr) if thunk is not None: return thunk return external_symbol set_type(datatype) Set the data type of this symbol. Source code in ghidralib.py def set_type(self, datatype): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program.create_data(self.address, datatype) SymbolicPropogator Bases: GhidraWrapper Wraps SymbolicPropogator. Can be used to get known values at various locations in a given function (or outside of a function) Source code in ghidralib.py class SymbolicPropogator(GhidraWrapper): \"\"\"Wraps SymbolicPropogator. Can be used to get known values at various locations in a given function (or outside of a function)\"\"\" @staticmethod def create(): return SymbolicPropogator(GhSymbolicPropogator(Program.current())) def flow_constants( self, addr, body, evaluator ): # type: (Addr, AddressSet, JavaObject) -> None \"\"\"Flow constants from the given address in the given body :param addr: The address to start from :param body: The body where constants should be propagated :param evaluator: The evaluator to use for the propagation\"\"\" addr = resolve(addr) self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor()) def register_at(self, addr, register): # type: (Addr, Reg) -> int|None \"\"\"Get a known register value at the given address (or None) Warning: this value is signed. :param addr: The address to get a register value at :param register: The register to get a value for :return: The value of the register at the given address, or None if the register is not known at that address\"\"\" addr = resolve(addr) reg = Register(register) value = self.raw.getRegisterValue(addr, reg.raw) if not value or value.isRegisterRelativeValue(): # This never happens in my tests, so I just won't handle register-relative # values. I don't know when this can ever happen. return None return value.value create() staticmethod Source code in ghidralib.py @staticmethod def create(): return SymbolicPropogator(GhSymbolicPropogator(Program.current())) flow_constants(addr, body, evaluator) Flow constants from the given address in the given body Parameters: addr \u2013 The address to start from body \u2013 The body where constants should be propagated evaluator \u2013 The evaluator to use for the propagation Source code in ghidralib.py def flow_constants( self, addr, body, evaluator ): # type: (Addr, AddressSet, JavaObject) -> None \"\"\"Flow constants from the given address in the given body :param addr: The address to start from :param body: The body where constants should be propagated :param evaluator: The evaluator to use for the propagation\"\"\" addr = resolve(addr) self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor()) register_at(addr, register) Get a known register value at the given address (or None) Warning: this value is signed. Parameters: addr \u2013 The address to get a register value at register \u2013 The register to get a value for Returns: \u2013 The value of the register at the given address, or None if the register is not known at that address Source code in ghidralib.py def register_at(self, addr, register): # type: (Addr, Reg) -> int|None \"\"\"Get a known register value at the given address (or None) Warning: this value is signed. :param addr: The address to get a register value at :param register: The register to get a value for :return: The value of the register at the given address, or None if the register is not known at that address\"\"\" addr = resolve(addr) reg = Register(register) value = self.raw.getRegisterValue(addr, reg.raw) if not value or value.isRegisterRelativeValue(): # This never happens in my tests, so I just won't handle register-relative # values. I don't know when this can ever happen. return None return value.value Variable Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py class Variable(GhidraWrapper): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name(self): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self.raw.getName() @name.setter def name(self, name): # type: (str) -> None \"\"\"Rename this variable\"\"\" self.rename(name, SourceType.USER_DEFINED) def rename( self, name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self.raw.setName(name, source) @property def data_type(self): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType(self.raw.getDataType()) @data_type.setter def data_type( self, data_type, source=SourceType.USER_DEFINED ): # type: (DataType, SourceType) -> None \"\"\"Set the data type of this variable\"\"\" self.raw.setDataType(data_type.raw, source) @property def is_valid(self): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self.raw.isValid() @property def comment(self): # type: () -> str|None \"\"\" \"Get the comment for this variable\"\"\" return self.raw.getComment() @comment.setter def comment(self, name): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.set_comment(name) def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.raw.setComment(comment) @property def is_auto(self): # type: () -> bool \"\"\"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.\"\"\" return self.raw.getVariableStorage().isAutoStorage() @property def is_forced_indirect(self): # type: () -> bool \"\"\"Check if this variable was forced to be a pointer by calling convention\"\"\" return self.raw.getVariableStorage().isForcedIndirect() @property def has_bad_storage(self): # type: () -> bool \"\"\"Check if this variable has bad storage (could not be resolved)\"\"\" return self.raw.getVariableStorage().isBadStorage() @property def is_unassigned_storage(self): # type: () -> bool \"\"\"Check if this variable has no assigned storage (varnodes)\"\"\" return self.raw.getVariableStorage().isUnassignedStorage() @property def is_void(self): # type: () -> bool \"\"\"Check if this variable is of type void\"\"\" return self.raw.getVariableStorage().isVoidStorage() @property def stack_offfset(self): # type: () -> int \"\"\"Get the stack offset of this variable.\"\"\" return self.raw.getVariableStorage().getStackOffset() @property def is_constant(self): # type: () -> bool \"\"\"Check if this variable consists of a single constant-space varnode\"\"\" return self.raw.getVariableStorage().isConstantStorage() @property def is_hash(self): # type: () -> bool \"\"\"Check if this variable consists of a single hash-space varnode.\"\"\" return self.raw.getVariableStorage().isHashStorage() @property def is_stack(self): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self.raw.isStackVariable() @property def is_memory(self): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self.raw.isMemoryVariable() @property def is_unique(self): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self.raw.isUniqueVariable() @property def is_compound(self): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self.raw.isCompoundVariable() @property def symbol(self): # type: () -> Symbol \"\"\"Get the symbol for this variable\"\"\" return Symbol(self.raw.getSymbol()) @property def source(self): # type: () -> SourceType \"\"\"Get the source type of this variable\"\"\" return SourceType(self.raw.getSource()) @property def varnode(self): # type: () -> Varnode \"\"\"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.\"\"\" return Varnode(self.raw.getFirstStorageVarnode()) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with this variable.\"\"\" storage = self.raw.getVariableStorage() return [Varnode(x) for x in storage.getVarnodes()] @property def is_register(self): # type: () -> bool \"\"\"Check if this variable consists of a single register.\"\"\" return self.raw.isRegisterVariable() @property def register(self): # type: () -> str \"\"\"Get the register associated with this variable. Raises an exception if this variable is not a register variable.\"\"\" reg = self.raw.getRegister() if not reg: raise ValueError(\"Variable is not a register variable\") return reg.getName() @property def function(self): # type: () -> Function \"\"\"Get the function associated with this variable.\"\"\" return Function(self.raw.getFunction()) comment property writable \"Get the comment for this variable data_type property writable Get the data type of this variable function property Get the function associated with this variable. has_bad_storage property Check if this variable has bad storage (could not be resolved) is_auto property Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters. is_compound property Check if this variable is a compound variable is_constant property Check if this variable consists of a single constant-space varnode is_forced_indirect property Check if this variable was forced to be a pointer by calling convention is_hash property Check if this variable consists of a single hash-space varnode. is_memory property Check if this variable is stored in memory is_register property Check if this variable consists of a single register. is_stack property Check if this variable is a stack variable is_unassigned_storage property Check if this variable has no assigned storage (varnodes) is_unique property Check if this variable is of type unique is_valid property Check if this variable is valid is_void property Check if this variable is of type void name property writable Get the name of this variable register property Get the register associated with this variable. Raises an exception if this variable is not a register variable. source property Get the source type of this variable stack_offfset property Get the stack offset of this variable. symbol property Get the symbol for this variable varnode property Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable. varnodes property Get all varnodes associated with this variable. rename(name, source=SourceType.USER_DEFINED) Rename this variable Source code in ghidralib.py def rename( self, name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self.raw.setName(name, source) set_comment(comment) Set the comment for this variable Source code in ghidralib.py def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.raw.setComment(comment) Varnode Bases: GhidraWrapper Source code in ghidralib.py class Varnode(GhidraWrapper): @property def has_value(self): # type: () -> bool \"\"\"Return true if this varnode can be converted to a integer value. In particular, this will return true for Address and Constant varnodes\"\"\" return self.value is not None @property def value(self): # type: () -> int|None \"\"\"Get the value of this varnode. Traverse defining pcodeops if necessary.\"\"\" if self.is_address or self.is_constant: return self.offset if self.defining_pcodeop is None: return None return self.defining_pcodeop.result @property def offset(self): # type: () -> int return int(self.raw.getOffset()) @property def size(self): # type: () -> int return self.raw.getSize() @property def high(self): # type: () -> HighVariable return HighVariable(self.raw.getHigh()) @property def symbol(self): # type: () -> HighSymbol return self.high.symbol @property def is_constant(self): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self.raw.isConstant() @property def is_register(self): # type: () -> bool \"\"\"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.\"\"\" return self.raw.isRegister() @property def is_named_register(self): # type: () -> bool \"\"\" \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.\"\"\" language = Program.current().getLanguage() raw = language.getRegister(self.raw.getAddress(), self.size) return raw is not None @property def as_register(self): # type: () -> str \"\"\"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.\"\"\" language = Program.current().getLanguage() raw = language.getRegister(self.raw.getAddress(), self.size) return raw.getName() @property def is_address(self): # type: () -> bool return self.raw.isAddress() @property def is_unique(self): # type: () -> bool return self.raw.isUnique() @property def is_hash(self): # type: () -> bool return self.raw.isHash() @property def is_stack(self): # type: () -> bool spaceid = self.raw.getSpace() spacetype = AddressSpace.ID_TYPE_MASK & spaceid return spacetype == AddressSpace.TYPE_STACK def rename(self, new_name): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self.symbol.rename(new_name) @property def free(self): # type: () -> Varnode return Varnode(GhVarnode(self.raw.getAddress(), self.raw.getSize())) @property def simple(self): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" value = self.value if value is not None: return value elif self.is_register: if self.is_named_register: return self.as_register return \"reg:{:x}:{:x}\".format(self.offset, self.size) elif self.is_unique: return \"uniq:{:x}:{:x}\".format(self.offset, self.size) elif self.is_hash: return \"hash:{:x}:{:x}\".format(self.offset, self.size) elif self.is_stack: return \"stack:{:x}:{:x}\".format(self.offset, self.size) raise RuntimeError(\"Unknown varnode type\") @property def is_unaffected(self): # type: () -> bool return self.raw.isUnaffected() @property def is_persistent(self): # type: () -> bool return self.raw.isPersistent() @property def is_addr_tied(self): # type: () -> bool return self.raw.isAddrTied() @property def is_input(self): # type: () -> bool return self.raw.isInput() @property def is_free(self): # type: () -> bool return self.raw.isFree() @property def defining_pcodeop(self): # type: () -> PcodeOp|None \"\"\"Return a PcodeOp that defined this varnode\"\"\" raw = self.raw.getDef() if raw is None: return None return PcodeOp(raw) @property def descendants(self): # type: () -> list[PcodeOp] \"\"\"Return a list of all descendants of this varnode\"\"\" if self.raw.getDescendants() is None: return [] return [PcodeOp(x) for x in self.raw.getDescendants()] def intersects(self, other): # type: (Varnode) -> list[PcodeOp] \"\"\"Return true if this varnode intersects other\"\"\" return self.raw.intersects(other.raw) as_register property Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure. defining_pcodeop property Return a PcodeOp that defined this varnode descendants property Return a list of all descendants of this varnode free property has_value property Return true if this varnode can be converted to a integer value. In particular, this will return true for Address and Constant varnodes high property is_addr_tied property is_address property is_constant property Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value. is_free property is_hash property is_input property is_named_register property \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name. is_persistent property is_register property Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead. is_stack property is_unaffected property is_unique property offset property simple property Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position. size property symbol property value property Get the value of this varnode. Traverse defining pcodeops if necessary. intersects(other) Return true if this varnode intersects other Source code in ghidralib.py def intersects(self, other): # type: (Varnode) -> list[PcodeOp] \"\"\"Return true if this varnode intersects other\"\"\" return self.raw.intersects(other.raw) rename(new_name) Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py def rename(self, new_name): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self.symbol.rename(new_name) unicode A fake stub class, to keep type-checker relatively happy Source code in ghidralib.py class unicode: \"\"\"A fake stub class, to keep type-checker relatively happy\"\"\" def encode(self): # type: () -> str \"\"\"A fake method, to keep type-checker relatively happy\"\"\" raise NotImplementedError(\"This method should never be called\") encode() A fake method, to keep type-checker relatively happy Source code in ghidralib.py def encode(self): # type: () -> str \"\"\"A fake method, to keep type-checker relatively happy\"\"\" raise NotImplementedError(\"This method should never be called\") assemble(instructions, address=0) Assemble the given instructions and return them as a list of instructions. Note: Address is important, because instruction meaning may depend on the location. Parameters: address \u2013 the address where the instructious would be written instructions \u2013 a list of instructions, or a single instruction to assemble Returns: \u2013 the newly assembled instructions Source code in ghidralib.py def assemble( instructions, address=0 ): # type: (str|list[str], Addr) -> list[Instruction] \"\"\"Assemble the given instructions and return them as a list of instructions. Note: Address is important, because instruction meaning may depend on the location. :param address: the address where the instructious would be written :param instructions: a list of instructions, or a single instruction to assemble :return: the newly assembled instructions\"\"\" data = assemble_to_bytes(instructions, address) return disassemble_bytes(data, address) assemble_at(address, instructions, pad_to=0) Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". >>> assemble_at(Function(\"exit\").entrypoint, \"RET\") Parameters: address \u2013 the address where to write the instructions instructions \u2013 a list of instructions, or a single instruction to assemble pad_to \u2013 optionally, pad the code with NOPs to reach this size Returns: \u2013 the newly assembled instructions Source code in ghidralib.py def assemble_at( address, instructions, pad_to=0 ): # type: (Addr, str|list[str], int) -> list[Instruction] \"\"\"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". >>> assemble_at(Function(\"exit\").entrypoint, \"RET\") :param address: the address where to write the instructions :param instructions: a list of instructions, or a single instruction to assemble :param pad_to: optionally, pad the code with NOPs to reach this size :return: the newly assembled instructions\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr = resolve(address) asm = Assemblers.getAssembler(Program.current()) result = [Instruction(i) for i in asm.assemble(addr, instructions)] # Append NOPs at the end, if length is shorter than pad_to. # This is purely to make the assembled code look nicer. if result: last = result[-1] end_addr = last.address + last.length code_size = end_addr - addr.getOffset() if pad_to > code_size: asm.assemble(addr.add(code_size), [\"NOP\"] * (pad_to - code_size)) # Do what Ghidra should do automaticaly, and automatically try to disassemble # jump targets from the newly assembled instructions for instr in result: for xref in instr.xrefs_from: if xref.is_call or xref.is_jump: disassemble(toAddr(xref.to_address)) return result assemble_to_bytes(instructions, address=0) Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is important, because instruction bytes may depend on the location. >>> assemble_to_bytes(\"ADD EAX, EAX\") \"\u0001\u00c0\" >>> assemble_to_bytes([\"ADD EAX, EAX\", \"ADD EAX, EAX\"]) \"\u0001\u00c0\u0001\u00c0\" Parameters: address \u2013 the address to use as a base for instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py def assemble_to_bytes(instructions, address=0): # type: (str|list[str], Addr) -> bytes \"\"\"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is important, because instruction bytes may depend on the location. >>> assemble_to_bytes(\"ADD EAX, EAX\") \"\\x01\\xc0\" >>> assemble_to_bytes([\"ADD EAX, EAX\", \"ADD EAX, EAX\"]) \"\\x01\\xc0\\x01\\xc0\" :param address: the address to use as a base for instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr_obj = resolve(address) asm = Assemblers.getAssembler(Program.current()) if isinstance(instructions, Str): return _bytes_from_bytelist(asm.assembleLine(addr_obj, instructions)) result = _asbytes(\"\") for instr in instructions: result += _bytes_from_bytelist( asm.assembleLine(addr_obj.add(len(result)), instr) ) return result can_resolve(addr) Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py def can_resolve(addr): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance(addr, (GenericAddress, int, long, unicode, str)) collect_iterator(iterator) Collect a Java iterator to a Python list. Source code in ghidralib.py def collect_iterator(iterator): # type: (JavaObject) -> list \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator.hasNext(): result.append(iterator.next()) return result disassemble_at(address, max_instr=None, max_bytes=None) Disassemble the bytes from the program memory at the given address. If neither max_bytes nor max_instr are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. >>> disassemble_at(0x0403ED0) [INC ESI] Parameters: address \u2013 the address where to start disassembling max_bytes \u2013 maximum number of bytes to disassemble (None for no limit) max_instr \u2013 maximum number of instructions to disassemble (None for no limit) Returns: \u2013 a list of Instruction objects Source code in ghidralib.py def disassemble_at( address, max_instr=None, max_bytes=None ): # type: (Addr, int|None, int|None) -> list[Instruction] \"\"\"Disassemble the bytes from the program memory at the given address. If neither `max_bytes` nor `max_instr` are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. >>> disassemble_at(0x0403ED0) [INC ESI] :param address: the address where to start disassembling :param max_bytes: maximum number of bytes to disassemble (None for no limit) :param max_instr: maximum number of instructions to disassemble (None for no limit) :return: a list of Instruction objects\"\"\" addr = resolve(address) if max_instr is None: _max_instr = 1 if max_bytes is None else max_bytes else: _max_instr = max_instr if max_bytes is None: to_block_end = MemoryBlock(addr).end - addr.getOffset() # Hacky and inefficient, but good enough for now (and correct) _max_bytes = min(to_block_end, _max_instr * 16) else: _max_bytes = max_bytes data = read_bytes(addr, _max_bytes) return disassemble_bytes(data, addr, _max_instr) disassemble_bytes(data, addr=0, max_instr=None) Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. >>> disassemble_bytes('F') [INC ESI] Note: Address is important, because instruction meaning may depend on the location. Parameters: data \u2013 the bytes to disassemble addr \u2013 the (virtual) address of the first instruction max_instr \u2013 the maximum number of instructions to disassemble, or to disassemble until the end of the data Returns: \u2013 a list of Instruction objects Source code in ghidralib.py def disassemble_bytes( data, addr=0, max_instr=None ): # type: (bytes, Addr, int|None) -> list[Instruction] \"\"\"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. >>> disassemble_bytes('F') [INC ESI] Note: Address is important, because instruction meaning may depend on the location. :param data: the bytes to disassemble :param addr: the (virtual) address of the first instruction :param max_instr: the maximum number of instructions to disassemble, or to disassemble until the end of the data :return: a list of Instruction objects\"\"\" dis = PseudoDisassembler(Program.current()) offset = 0 result = [] address = resolve(addr) if max_instr is None: max_instr = 100000000 for _ in range(0, max_instr): try: arr = data[offset : offset + 16] rawinstr = dis.disassemble(address.add(offset), arr) instr = Instruction(rawinstr) if offset + instr.length > len(data): break result.append(instr) offset += instr.length if offset + instr.length == len(data): break except: break return result enhex(s) Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py def enhex(s): # type: (bytes | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if not isinstance(s, Str): return _enhex(_asbytes(\"\".join(chr(c) for c in s))) return _enhex(s) findall_pattern(byte_pattern) Find all occurrences of a byte pattern in the program. >>> findall_pattern(\"01 02 ?? 04\") [0x1000, 0x1004] Parameters: byte_pattern \u2013 the pattern string. Returns: \u2013 iterator over all addresses of all occurrences. Source code in ghidralib.py def findall_pattern(byte_pattern): # type: (str) -> Iterator[int] \"\"\"Find all occurrences of a byte pattern in the program. >>> findall_pattern(\"01 02 ?? 04\") [0x1000, 0x1004] :param byte_pattern: the pattern string. :return: iterator over all addresses of all occurrences.\"\"\" addr = -1 while True: addr = findone_pattern(byte_pattern, start=addr + 1) if addr is None: break yield addr findone_pattern(byte_pattern, start=0) Find the first occurrence of a byte pattern in the program (or None). >>> findone_pattern(\"01 02 ?? 04\") 0x1000 Parameters: byte_pattern \u2013 the pattern string. start \u2013 the address to start searching from. Returns: \u2013 address of the first occurrence, or None if not found. Source code in ghidralib.py def findone_pattern(byte_pattern, start=0): # type: (str, Addr) -> int|None \"\"\"Find the first occurrence of a byte pattern in the program (or None). >>> findone_pattern(\"01 02 ?? 04\") 0x1000 :param byte_pattern: the pattern string. :param start: the address to start searching from. :return: address of the first occurrence, or None if not found.\"\"\" start = resolve(start) bytes = _pattern_to_bytes(byte_pattern) mask = _pattern_to_mask(byte_pattern) addr = ( Program.current().getMemory().findBytes(start, bytes, mask, True, getMonitor()) ) if not addr: return None return addr.getOffset() from_bytes(b) Decode a bytes as a little-endian integer. >>> from_bytes('ab') 25185 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py def from_bytes(b): # type: (bytes) -> int \"\"\"Decode a bytes as a little-endian integer. >>> from_bytes('ab') 25185 :param b: byte stream to decode.\"\"\" bl = _bytes_as_list(b) return sum(v << (i * 8) for i, v in enumerate(bl)) get_string(address) Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py def get_string(address): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt(resolve(address)) if string and string.hasStringValue(): return string.getValue() return None read_bytes(address, length) Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py def read_bytes(address, length): # type: (Addr, int) -> bytes \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve(address) return _bytes_from_bytelist(getBytes(address, length)) read_cstring(address) Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_cstring(address): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string read_u16(address) Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u16(address): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 2)) read_u32(address) Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u32(address): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 4)) read_u64(address) Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u64(address): # type: (Addr) -> int \"\"\"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 8)) read_u8(address) Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u8(address): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 1)) read_unicode(address) Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_unicode(address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string resolve(addr) Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py def resolve(addr): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance(addr, unicode): # Why, Ghidra? addr = addr.encode() if isinstance(addr, GenericAddress): return addr if isinstance(addr, (int, long)): # Why convert to string? Java cannot handle large (unsigned) integers :/ return toAddr(\"{:x}\".format(addr)) if isinstance(addr, str): return toAddr(Symbol(addr).address) raise TypeError(\"Address must be a ghidra Address, int, or str\") to_bytes(value, length) Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\x01\\x02' Parameters: value \u2013 integer to encode. length \u2013 number of bytes of the result. Source code in ghidralib.py def to_bytes(value, length): # type: (int, int) -> bytes \"\"\"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\\\x01\\\\x02' :param value: integer to encode. :param length: number of bytes of the result.\"\"\" out = \"\" for i in range(length): out += chr(value & 0xFF) value >>= 8 return _asbytes(out) try_resolve(addr) Convert an arbitrary addressable value to a Ghidra Address object. See resolve documentation for more details. Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress representing the value, or None resolving failed. Source code in ghidralib.py def try_resolve(addr): # type: (Addr) -> GenericAddress | None \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. See `resolve` documentation for more details. :param addr: An addressable value. :return: A GenericAddress representing the value, or None resolving failed.\"\"\" try: return resolve(addr) except: return None unhex(s) Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py def unhex(s): # type: (str) -> bytes \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return _unhex(s) unwrap(wrapper_or_java_type) If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py def unwrap(wrapper_or_java_type): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance(wrapper_or_java_type, GhidraWrapper): return wrapper_or_java_type.raw return wrapper_or_java_type write_bytes(address, data) Write the provided bytes at a given address. >>> write_bytes(0x1000, \"test) >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address where bytes should be written. data \u2013 bytes to write. Source code in ghidralib.py def write_bytes(address, data): # type: (Addr, bytes) -> None \"\"\"Write the provided bytes at a given address. >>> write_bytes(0x1000, \"test) >>> read_bytes(0x1000, 4) 'test' :param address: address where bytes should be written. :param data: bytes to write.\"\"\" addr = resolve(address) try: setBytes(addr, data) except: clearListing(addr, addr.add(len(data) - 1)) setBytes(addr, data) xor(a, b) XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py def xor(a, b): # type: (bytes, bytes) -> bytes \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\\\x01\\\\x02\", \"\\\\x03\\\\x04\") '\\\\x02\\\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" al = _bytes_as_list(a) bl = _bytes_as_list(b) return _asbytes(\"\".join(chr(x ^ y) for x, y in zip(al, bl)))","title":"API reference"},{"location":"reference/#api-reference","text":"","title":"API reference"},{"location":"reference/#ghidralib","text":"This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/.","title":"ghidralib"},{"location":"reference/#ghidralib.Addr","text":"","title":"Addr"},{"location":"reference/#ghidralib.DataT","text":"","title":"DataT"},{"location":"reference/#ghidralib.HIGHLIGHT_COLOR","text":"","title":"HIGHLIGHT_COLOR"},{"location":"reference/#ghidralib.Reg","text":"","title":"Reg"},{"location":"reference/#ghidralib.Str","text":"","title":"Str"},{"location":"reference/#ghidralib.T","text":"","title":"T"},{"location":"reference/#ghidralib.__version__","text":"","title":"__version__"},{"location":"reference/#ghidralib.bytes","text":"","title":"bytes"},{"location":"reference/#ghidralib.interpreter","text":"","title":"interpreter"},{"location":"reference/#ghidralib.long","text":"","title":"long"},{"location":"reference/#ghidralib.AddressRange","text":"Bases: GhidraWrapper Wraps a Ghidra AddressRange object. Source code in ghidralib.py class AddressRange(GhidraWrapper): \"\"\"Wraps a Ghidra AddressRange object.\"\"\" @property def addresses(self): # type: () -> list[int] \"\"\"Return the addresses in this range.\"\"\" return [a.getOffset() for a in self.raw.getAddresses(True)] def __iter__(self): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self.addresses.__iter__() @property def start(self): # type: () -> int \"\"\"Get the first address in this range.\"\"\" return self.raw.getMinAddress().getOffset() @property def end(self): # type: () -> int \"\"\"Get the last address in this range.\"\"\" return self.raw.getMaxAddress().getOffset() @property def length(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.raw.getLength() def __len__(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.length def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.raw.contains(resolve(addr)) def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.contains(addr) @property def is_empty(self): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self.raw.isEmpty() def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty def __and__(self, other): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange(self.raw.intersect(other.raw))","title":"AddressRange"},{"location":"reference/#ghidralib.AddressRange.addresses","text":"Return the addresses in this range.","title":"addresses"},{"location":"reference/#ghidralib.AddressRange.end","text":"Get the last address in this range.","title":"end"},{"location":"reference/#ghidralib.AddressRange.is_empty","text":"Return True if this range is empty.","title":"is_empty"},{"location":"reference/#ghidralib.AddressRange.length","text":"Get the length of this range.","title":"length"},{"location":"reference/#ghidralib.AddressRange.start","text":"Get the first address in this range.","title":"start"},{"location":"reference/#ghidralib.AddressRange.__and__","text":"Return the intersection of this range and the given range. Source code in ghidralib.py def __and__(self, other): # type: (AddressRange) -> AddressRange \"\"\"Return the intersection of this range and the given range.\"\"\" return AddressRange(self.raw.intersect(other.raw))","title":"__and__"},{"location":"reference/#ghidralib.AddressRange.__contains__","text":"Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.contains(addr)","title":"__contains__"},{"location":"reference/#ghidralib.AddressRange.__iter__","text":"Iterate over the addresses in this range. Source code in ghidralib.py def __iter__(self): # type: () -> Iterator[int] \"\"\"Iterate over the addresses in this range.\"\"\" return self.addresses.__iter__()","title":"__iter__"},{"location":"reference/#ghidralib.AddressRange.__len__","text":"Get the length of this range. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Get the length of this range.\"\"\" return self.length","title":"__len__"},{"location":"reference/#ghidralib.AddressRange.__nonzero__","text":"Return True if this range is not empty. Source code in ghidralib.py def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty","title":"__nonzero__"},{"location":"reference/#ghidralib.AddressRange.contains","text":"Return True if the given address is in this range. Parameters: addr \u2013 address to check Source code in ghidralib.py def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range. :param addr: address to check\"\"\" return self.raw.contains(resolve(addr))","title":"contains"},{"location":"reference/#ghidralib.AddressSet","text":"Bases: GhidraWrapper Wraps a Ghidra AddressSetView object. Source code in ghidralib.py class AddressSet(GhidraWrapper): \"\"\"Wraps a Ghidra AddressSetView object.\"\"\" @staticmethod def empty(): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet(GhAddressSet()) @staticmethod def create(start, length): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve(start) return AddressSet(GhAddressSet(addr, addr.add(length - 1))) @property def addresses(self): # type: () -> list[int] \"\"\"Return the addresses in this set.\"\"\" return [a.getOffset() for a in self.raw.getAddresses(True)] @property def ranges(self): # type: () -> list[AddressRange] return [AddressRange(r) for r in self.raw.iterator(True)] def __iter__(self): # type: () -> Iterator[int] return self.addresses.__iter__() def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.raw.contains(resolve(addr)) def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.contains(addr) @property def is_empty(self): # type: () -> bool \"\"\"Return True if this range is empty.\"\"\" return self.raw.isEmpty() def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty def __and__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet(self.raw.intersect(other.raw)) def __sub__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet(self.raw.subtract(other.raw)) def __xor__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet(self.raw.xor(other.raw)) def __or__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet(self.raw.union(other.raw)) def __get_highlighter(self): # type: () -> Any tool = getState().getTool() service = tool.getService(ColorizingService) if service is None: raise RuntimeError(\"Cannot highlight without the ColorizingService\") return service def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None service = self.__get_highlighter() service.setBackgroundColor(self.raw, color) def unhighlight(self): # type: (Color) -> None service = self.__get_highlighter() service.clearBackgroundColor(self.raw)","title":"AddressSet"},{"location":"reference/#ghidralib.AddressSet.addresses","text":"Return the addresses in this set.","title":"addresses"},{"location":"reference/#ghidralib.AddressSet.is_empty","text":"Return True if this range is empty.","title":"is_empty"},{"location":"reference/#ghidralib.AddressSet.ranges","text":"","title":"ranges"},{"location":"reference/#ghidralib.AddressSet.__and__","text":"Return the intersection of this set and the given set. Source code in ghidralib.py def __and__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Return the intersection of this set and the given set.\"\"\" return AddressSet(self.raw.intersect(other.raw))","title":"__and__"},{"location":"reference/#ghidralib.AddressSet.__contains__","text":"Return True if the given address is in this range. Source code in ghidralib.py def __contains__(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.contains(addr)","title":"__contains__"},{"location":"reference/#ghidralib.AddressSet.__get_highlighter","text":"Source code in ghidralib.py def __get_highlighter(self): # type: () -> Any tool = getState().getTool() service = tool.getService(ColorizingService) if service is None: raise RuntimeError(\"Cannot highlight without the ColorizingService\") return service","title":"__get_highlighter"},{"location":"reference/#ghidralib.AddressSet.__iter__","text":"Source code in ghidralib.py def __iter__(self): # type: () -> Iterator[int] return self.addresses.__iter__()","title":"__iter__"},{"location":"reference/#ghidralib.AddressSet.__nonzero__","text":"Return True if this range is not empty. Source code in ghidralib.py def __nonzero__(self): # type: () -> bool \"\"\"Return True if this range is not empty.\"\"\" return not self.is_empty","title":"__nonzero__"},{"location":"reference/#ghidralib.AddressSet.__or__","text":"Computes the union of this set and the given set. Source code in ghidralib.py def __or__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the union of this set and the given set.\"\"\" return AddressSet(self.raw.union(other.raw))","title":"__or__"},{"location":"reference/#ghidralib.AddressSet.__sub__","text":"Subtract the given set from this set. Source code in ghidralib.py def __sub__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Subtract the given set from this set.\"\"\" return AddressSet(self.raw.subtract(other.raw))","title":"__sub__"},{"location":"reference/#ghidralib.AddressSet.__xor__","text":"Computes the symmetric difference of this set and the given set. Source code in ghidralib.py def __xor__(self, other): # type: (AddressSet) -> AddressSet \"\"\"Computes the symmetric difference of this set and the given set.\"\"\" return AddressSet(self.raw.xor(other.raw))","title":"__xor__"},{"location":"reference/#ghidralib.AddressSet.contains","text":"Return True if the given address is in this range. Source code in ghidralib.py def contains(self, addr): # type: (Addr) -> bool \"\"\"Return True if the given address is in this range.\"\"\" return self.raw.contains(resolve(addr))","title":"contains"},{"location":"reference/#ghidralib.AddressSet.create","text":"Create a new AddressSet with given address and length. Source code in ghidralib.py @staticmethod def create(start, length): # type: (Addr, int) -> AddressSet \"\"\"Create a new AddressSet with given address and length.\"\"\" addr = resolve(start) return AddressSet(GhAddressSet(addr, addr.add(length - 1)))","title":"create"},{"location":"reference/#ghidralib.AddressSet.empty","text":"Create a new empty address set Source code in ghidralib.py @staticmethod def empty(): # type: () -> AddressSet \"\"\"Create a new empty address set\"\"\" return AddressSet(GhAddressSet())","title":"empty"},{"location":"reference/#ghidralib.AddressSet.highlight","text":"Source code in ghidralib.py def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None service = self.__get_highlighter() service.setBackgroundColor(self.raw, color)","title":"highlight"},{"location":"reference/#ghidralib.AddressSet.unhighlight","text":"Source code in ghidralib.py def unhighlight(self): # type: (Color) -> None service = self.__get_highlighter() service.clearBackgroundColor(self.raw)","title":"unhighlight"},{"location":"reference/#ghidralib.BasicBlock","text":"Bases: AddressSet , BodyTrait Wraps a Ghidra CodeBlock object Source code in ghidralib.py class BasicBlock(AddressSet, BodyTrait): \"\"\"Wraps a Ghidra CodeBlock object\"\"\" @staticmethod def _model(model): # type: (str) -> Callable[[JavaObject], JavaObject] if model == \"basic\": return BasicBlockModel elif model == \"simple\": return SimpleBlockModel else: raise ValueError(\"Unsupported model type: %s\" % model) @staticmethod def get( raw_or_address, model=\"basic\" ): # type: (JavaObject|str|Addr, str) -> BasicBlock|None \"\"\"Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) :param raw_or_address: find basicblock that contains the given address. :param model: Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\".\"\"\" if raw_or_address is None: return None if can_resolve(raw_or_address): block_model = BasicBlock._model(model)(Program.current()) addr = try_resolve(raw_or_address) if addr is None: return None raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY) if raw is None: return None else: raw = raw_or_address return BasicBlock(raw) @staticmethod def all(model=\"basic\"): # type: (str) -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = BasicBlock._model(model)(Program.current()) return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)] @property def name(self): # type: () -> str \"\"\"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.\"\"\" return self.raw.getName() @property def address(self): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self.start_address @property def start_address(self): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self.raw.getMinAddress().getOffset() @property def end_address(self): # type: () -> int \"\"\"Get the address of the last byte in this basic block. Note: this is not the address of the last instruction. Note: end_address - start_address is equal to length - 1. For example, for one-byte basic block, start_address == end_address.\"\"\" return self.raw.getMaxAddress().getOffset() @property def length(self): # type: () -> int \"\"\"Get the length of this basic block in bytes.\"\"\" return self.end_address - self.start_address + 1 @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this basic block. :return: bytes of this basic block.\"\"\" return read_bytes(self.start_address, self.length) @property def instructions(self): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt(resolve(self.start_address)) while instruction and instruction.getAddress().getOffset() <= self.end_address: result.append(Instruction(instruction)) instruction = instruction.getNext() return result @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self.instructions: result.extend(instruction.pcode) return result @property def destinations(self): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator(self.raw.getDestinations(TaskMonitor.DUMMY)) return [BasicBlock(raw.getDestinationBlock()) for raw in raw_refs] @property def sources(self): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator(self.raw.getSources(TaskMonitor.DUMMY)) return [BasicBlock(raw.getSourceBlock()) for raw in raw_refs] @property def body(self): # type: () -> AddressSet \"\"\"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.\"\"\" return AddressSet(self.raw) @property def flow_type(self): # type: () -> FlowType \"\"\"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.\"\"\" return FlowType(self.raw.getFlowType()) def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance(other, BasicBlock): return False # This is not fully correct, but more correct than the default. return self.address == other.address","title":"BasicBlock"},{"location":"reference/#ghidralib.BasicBlock.address","text":"Get the address of the first instruction in this basic block.","title":"address"},{"location":"reference/#ghidralib.BasicBlock.body","text":"Get the address set of this basic block Technically BasicBlock (CodeBlock) is is already an AddressSet, but I think this is a useful distinction to keep.","title":"body"},{"location":"reference/#ghidralib.BasicBlock.bytes","text":"Get the bytes of this basic block. Returns: \u2013 bytes of this basic block.","title":"bytes"},{"location":"reference/#ghidralib.BasicBlock.destinations","text":"Get a list of basic blocks that this basic block jumps to","title":"destinations"},{"location":"reference/#ghidralib.BasicBlock.end_address","text":"Get the address of the last byte in this basic block. Note: this is not the address of the last instruction. Note: end_address - start_address is equal to length - 1. For example, for one-byte basic block, start_address == end_address.","title":"end_address"},{"location":"reference/#ghidralib.BasicBlock.flow_type","text":"Get the flow type of this basic block. In other words, if any weird things with control flow are happening in this node.","title":"flow_type"},{"location":"reference/#ghidralib.BasicBlock.instructions","text":"Get a list of instructions in this basic block.","title":"instructions"},{"location":"reference/#ghidralib.BasicBlock.length","text":"Get the length of this basic block in bytes.","title":"length"},{"location":"reference/#ghidralib.BasicBlock.name","text":"Get the name of this basic block. Return the symbol at the start of this basic block, if any. Otherwise, return the address of the first instruction as string.","title":"name"},{"location":"reference/#ghidralib.BasicBlock.pcode","text":"Get a list of Pcode operations that this basic block was parsed to","title":"pcode"},{"location":"reference/#ghidralib.BasicBlock.sources","text":"Get a list of basic blocks that jump to this basic block","title":"sources"},{"location":"reference/#ghidralib.BasicBlock.start_address","text":"Get the address of the first instruction in this basic block.","title":"start_address"},{"location":"reference/#ghidralib.BasicBlock.__eq__","text":"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two basic blocks for equality. Apparently Ghidra doesn't know how to do this\"\"\" if not isinstance(other, BasicBlock): return False # This is not fully correct, but more correct than the default. return self.address == other.address","title":"__eq__"},{"location":"reference/#ghidralib.BasicBlock.all","text":"Get a list of all basic blocks in the program. Source code in ghidralib.py @staticmethod def all(model=\"basic\"): # type: (str) -> list[BasicBlock] \"\"\"Get a list of all basic blocks in the program.\"\"\" block_model = BasicBlock._model(model)(Program.current()) return [BasicBlock(b) for b in block_model.getCodeBlocks(TaskMonitor.DUMMY)]","title":"all"},{"location":"reference/#ghidralib.BasicBlock.get","text":"Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Parameters: raw_or_address \u2013 find basicblock that contains the given address. model \u2013 Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\". Source code in ghidralib.py @staticmethod def get( raw_or_address, model=\"basic\" ): # type: (JavaObject|str|Addr, str) -> BasicBlock|None \"\"\"Get a BasicBlock object containing the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) :param raw_or_address: find basicblock that contains the given address. :param model: Ghidra supports different types of basic block \"models\". Supported options are \"basic\" and \"simple\".\"\"\" if raw_or_address is None: return None if can_resolve(raw_or_address): block_model = BasicBlock._model(model)(Program.current()) addr = try_resolve(raw_or_address) if addr is None: return None raw = block_model.getFirstCodeBlockContaining(addr, TaskMonitor.DUMMY) if raw is None: return None else: raw = raw_or_address return BasicBlock(raw)","title":"get"},{"location":"reference/#ghidralib.BlockGraph","text":"Bases: PcodeBlock Source code in ghidralib.py class BlockGraph(PcodeBlock): @property def blocks(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getBlock(i)) for i in range(self.raw.getSize())]","title":"BlockGraph"},{"location":"reference/#ghidralib.BlockGraph.blocks","text":"","title":"blocks"},{"location":"reference/#ghidralib.BodyTrait","text":"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting. Source code in ghidralib.py class BodyTrait: \"\"\"A trait for objects that have a body. It provides generic methods that work with anything that has a body (an assigned set of addresses in the program), such as highlighting.\"\"\" @property @abstractmethod def body(self): # type: () -> AddressSet \"\"\"The body of this object\"\"\" def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self.body.highlight(color) def unhighlight(self): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self.body.unhighlight()","title":"BodyTrait"},{"location":"reference/#ghidralib.BodyTrait.body","text":"The body of this object","title":"body"},{"location":"reference/#ghidralib.BodyTrait.highlight","text":"Highlight this instruction in the listing. Source code in ghidralib.py def highlight(self, color=HIGHLIGHT_COLOR): # type: (Color) -> None \"\"\"Highlight this instruction in the listing.\"\"\" self.body.highlight(color)","title":"highlight"},{"location":"reference/#ghidralib.BodyTrait.unhighlight","text":"Clear the highlight from this instruction. Source code in ghidralib.py def unhighlight(self): # type: () -> None \"\"\"Clear the highlight from this instruction.\"\"\" self.body.unhighlight()","title":"unhighlight"},{"location":"reference/#ghidralib.ClangTokenGroup","text":"Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py class ClangTokenGroup(GhidraWrapper): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup(self, token): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup(token.Parent()) for token in list(token.iterator()): if isinstance(token, (ClangCommentToken, ClangBreak)): continue if isinstance(token, ClangSyntaxToken): if not token.getText() or token.getText().isspace(): continue if isinstance(token, GhClangTokenGroup): token = self._cleanup(token) new.AddTokenGroup(token) return new @property def cleaned(self): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup(self._cleanup(self.raw)) def _dump(self, token, indent=0): # type: (JavaObject, int) -> None if isinstance(token, GhClangTokenGroup): print(\"{}[group]\".format(indent * \" \", token.__class__.__name__)) for child in token.iterator(): self._dump(child, indent + 1) else: print(\"{}{} ({})\".format(indent * \" \", token, token.__class__.__name__)) def dump(self): # type: () -> None self._dump(self.raw)","title":"ClangTokenGroup"},{"location":"reference/#ghidralib.ClangTokenGroup.cleaned","text":"Remove all whitespace and comments from this token group, recursively.","title":"cleaned"},{"location":"reference/#ghidralib.ClangTokenGroup.dump","text":"Source code in ghidralib.py def dump(self): # type: () -> None self._dump(self.raw)","title":"dump"},{"location":"reference/#ghidralib.Data","text":"Bases: GhidraWrapper Wraps a structure for convenient access by field name Source code in ghidralib.py class Data(GhidraWrapper): \"\"\" Wraps a structure for convenient access by field name \"\"\" @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Data|None \"\"\"Return a Data instance at the given address, or None if there is no Data defined there.\"\"\" if isinstance(addr, GhData): return Data(addr) addr = try_resolve(addr) if addr is None: return None raw = getDataAt(addr) if raw is None: return None return Data(raw) # type: ignore def __getattr__(self, name): for i in range(self.raw.getNumComponents()): field = self.raw.getComponent(i) if field.getFieldName() == name: if field.isStructure(): return Data(field) return GhidraWrapper(field) raise AttributeError(\"Field %s does not exist\" % name)","title":"Data"},{"location":"reference/#ghidralib.Data.__getattr__","text":"Source code in ghidralib.py def __getattr__(self, name): for i in range(self.raw.getNumComponents()): field = self.raw.getComponent(i) if field.getFieldName() == name: if field.isStructure(): return Data(field) return GhidraWrapper(field) raise AttributeError(\"Field %s does not exist\" % name)","title":"__getattr__"},{"location":"reference/#ghidralib.Data.get","text":"Return a Data instance at the given address, or None if there is no Data defined there. Source code in ghidralib.py @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Data|None \"\"\"Return a Data instance at the given address, or None if there is no Data defined there.\"\"\" if isinstance(addr, GhData): return Data(addr) addr = try_resolve(addr) if addr is None: return None raw = getDataAt(addr) if raw is None: return None return Data(raw) # type: ignore","title":"get"},{"location":"reference/#ghidralib.DataType","text":"Bases: GhidraWrapper Source code in ghidralib.py class DataType(GhidraWrapper): @staticmethod def get(name_or_raw): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance(name_or_raw, Str): return DataType(name_or_raw) for datatype in DataType.all(): if datatype.name == name_or_raw: return DataType(datatype) return None @staticmethod def all(only_local=False): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list(Program.current().getDataTypeManager().getAllDataTypes()) if not only_local: managers = ( getState() .getTool() .getService(DataTypeManagerService) .getDataTypeManagers() ) for manager in managers: for datatype in manager.getAllDataTypes(): datatypes.append(datatype) return [DataType(raw) for raw in datatypes] @property def name(self): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' . \"\"\" return self.raw.getName() def get_name(self, value): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self.raw.getName(value) def length(self): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self.raw.getLength() __len__ = length @staticmethod def from_c(c_code, insert=True): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program.current().getDataTypeManager() parser = CParser(dtm) new_dt = parser.parse(c_code) if insert: transaction = dtm.startTransaction(\"Adding new data\") dtm.addDataType(new_dt, None) dtm.endTransaction(transaction, True) return new_dt","title":"DataType"},{"location":"reference/#ghidralib.DataType.__len__","text":"","title":"__len__"},{"location":"reference/#ghidralib.DataType.name","text":"Get a name of this data type >>> DataType('int').name 'int' .","title":"name"},{"location":"reference/#ghidralib.DataType.all","text":"Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py @staticmethod def all(only_local=False): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list(Program.current().getDataTypeManager().getAllDataTypes()) if not only_local: managers = ( getState() .getTool() .getService(DataTypeManagerService) .getDataTypeManagers() ) for manager in managers: for datatype in manager.getAllDataTypes(): datatypes.append(datatype) return [DataType(raw) for raw in datatypes]","title":"all"},{"location":"reference/#ghidralib.DataType.from_c","text":"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py @staticmethod def from_c(c_code, insert=True): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> DataType.from_c('typedef void* HINTERNET;') HINTERNET >>> DataType.from_c(\"struct test { short a; short b; short c;};\") pack() Structure test { 0 short 2 a \"\" 2 short 2 b \"\" 4 short 2 c \"\" } Length: 6 Alignment: 2 :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = Program.current().getDataTypeManager() parser = CParser(dtm) new_dt = parser.parse(c_code) if insert: transaction = dtm.startTransaction(\"Adding new data\") dtm.addDataType(new_dt, None) dtm.endTransaction(transaction, True) return new_dt","title":"from_c"},{"location":"reference/#ghidralib.DataType.get","text":"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name_or_raw \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py @staticmethod def get(name_or_raw): # type: (DataT) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name_or_raw: the name of the data type :return: the data type, or None if not found\"\"\" if not isinstance(name_or_raw, Str): return DataType(name_or_raw) for datatype in DataType.all(): if datatype.name == name_or_raw: return DataType(datatype) return None","title":"get"},{"location":"reference/#ghidralib.DataType.get_name","text":"If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py def get_name(self, value): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self.raw.getName(value)","title":"get_name"},{"location":"reference/#ghidralib.DataType.length","text":"Get the length of this data type in bytes >>> DataType('int').length() 4 . Source code in ghidralib.py def length(self): # type: () -> int \"\"\"Get the length of this data type in bytes >>> DataType('int').length() 4 . \"\"\" return self.raw.getLength()","title":"length"},{"location":"reference/#ghidralib.Emulator","text":"Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py class Emulator(GhidraWrapper): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__(self): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper(Program.current()) GhidraWrapper.__init__(self, raw) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset() max_pointer = max_pointer % 2**64 # Java signed ints everywhere strike again. stack_off = ((max_pointer + 1) >> 1) - 0x8000 self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off) # TODO: add a simple allocation manager self._hooks = {} # type: dict[int, Callable[[Emulator], str|None]] def add_hook( self, address, hook ): # type: (Addr, Callable[[Emulator], str|None]) -> None \"\"\"Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported.\"\"\" addr = resolve(address).getOffset() if addr in self._hooks: raise ValueError(\"Multiple hooks at the same address are not supported\") self._hooks[addr] = hook def has_hook_at(self, address): # type: (Addr) -> bool addr = resolve(address).getOffset() return addr in self._hooks def delete_hook_at(self, address): # type: (Addr) -> None addr = resolve(address).getOffset() del self._hooks[addr] @property def pc(self): # type: () -> int \"\"\"Get the program counter of the emulated program.\"\"\" return self.raw.getExecutionAddress().getOffset() @pc.setter def pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" self.set_pc(address) def set_pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self.raw.getPCRegister() self.raw.writeRegister(pc, resolve(address).getOffset()) @property def sp_register(self): # type: () -> str \"\"\"Get the stack pointer register name for the emulated architecture.\"\"\" return self.raw.getStackPointerRegister().getName() @property def sp(self): # type: () -> int \"\"\"Get the current stack pointer register value.\"\"\" return self.read_register(self.sp_register) @sp.setter def sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.set_sp(value) def set_sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.write_register(self.sp_register, resolve(value).getOffset()) def __getitem__(self, reg): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self.read_register(reg) def __setitem__(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self.write_register(reg, value) def read_register(self, reg): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return _python_int(self.raw.readRegister(reg)) def read_bytes(self, address, length): # type: (Addr, int) -> bytes \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self.raw.readMemory(resolve(address), length) return _bytes_from_bytelist(bytelist) def read_u8(self, address): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 1)) def read_u16(self, address): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 2)) def read_u32(self, address): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 4)) def read_u64(self, address): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 8)) def read_cstring(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string def read_unicode(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string def read_varnode(self, varnode): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: return varnode.offset elif varnode.is_address: rawnum = self.read_bytes(varnode.offset, varnode.size) return from_bytes(rawnum) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) rawnum = self.read_bytes(offset, varnode.size) return from_bytes(rawnum) elif varnode.is_stack: return self.raw.readStackValue(varnode.offset, varnode.size, False) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) return self.read_register(reg) raise RuntimeError(\"Unsupported varnode type\") def write_register(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self.raw.writeRegister(reg, value) def write_bytes(self, address, value): # type: (Addr, bytes) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self.raw.writeMemory(resolve(address), value) def write_u8(self, address, value): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**8, \"value out of range\" self.write_bytes(address, to_bytes(value, 1)) def write_u16(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**16, \"value out of range\" self.write_bytes(address, to_bytes(value, 2)) def write_u32(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**32, \"value out of range\" self.write_bytes(address, to_bytes(value, 4)) def write_u64(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**64, \"value out of range\" self.write_bytes(address, to_bytes(value, 8)) def write_varnode(self, varnode, value): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: raise ValueError(\"Can't set value of a constant varnodes\") elif varnode.is_address: self.write_bytes(varnode.offset, to_bytes(value, varnode.size)) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) self.write_bytes(offset, to_bytes(value, varnode.size)) elif varnode.is_stack: self.raw.writeStackValue(varnode.offset, varnode.size, value) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) self.raw.writeRegister(reg, value) else: raise RuntimeError(\"Unsupported varnode type\") def __run_with_hooks(self): # type: () -> bool \"\"\"Run the Ghidra emulator, and transparently handle all hooks. :return: True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break).\"\"\" while not getMonitor().isCancelled(): is_breakpoint = self.raw.run(getMonitor()) if self.pc not in self._hooks: return is_breakpoint result = self._hooks[self.pc](self) if self.__handle_hook_result(result): return True return False def add_breakpoint(self, address): # type: (Addr) -> None \"\"\"Add a breakpoint at the given address. :param address: the address to break on\"\"\" self.raw.setBreakpoint(resolve(address)) def clear_breakpoint(self, address): # type: (Addr) -> None \"\"\"Clear a breakpoint at the given address. :param address: the address to clear breakpoint from\"\"\" self.raw.clearBreakpoint(resolve(address)) def emulate_fast(self, start, ends): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] for end in ends: self.add_breakpoint(end) is_breakpoint = self.__run_with_hooks() for end in ends: self.clear_breakpoint(end) if not is_breakpoint: err = self.raw.getLastError() raise RuntimeError(\"Error when running: {}\".format(err)) def __handle_hook_result(self, result): # type: (str|None) -> bool \"\"\"Handle a hook return value and return True if emulation should stop.\"\"\" if result is None or result == \"continue\": return False elif result == \"skip\": self.pc = Instruction(self.pc).next.address return False elif result == \"break\": return True else: raise RuntimeError(\"Invalid hook return value: {}\".format(result)) def single_step(self): # type: () -> bool \"\"\"Do a single emulation step. This will step into calls. Note: This method *will* call hooks. :return: True if the emulation should be stopped, False otherwise.\"\"\" success = self.raw.step(getMonitor()) if not success: err = self.raw.getLastError() raise RuntimeError(\"Error at {}: {}\".format(self.pc, err)) if self.pc in self._hooks: result = self._hooks[self.pc](self) return self.__handle_hook_result(result) if self.is_at_breakpoint: return True return False @staticmethod def new( start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> Emulator \"\"\"Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See `emulate` documentation for info about this method parameters.\"\"\" emu = Emulator() emu.emulate(start, ends, callback, stop_when, maxsteps) return emu def emulate( self, start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> None \"\"\"Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction * 'retry' like continue, but call the callback again (useful after pc change) * 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). :param stop_when: the callback to call before each executed instruction. Return True here to stop emulation. :param maxsteps: the maximum number of steps to execute\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] ends = [resolve(e).getOffset() for e in ends] while maxsteps > 0: maxsteps -= 1 if self.pc in ends: break command = callback(self) if command == \"retry\": continue elif command == \"continue_then_break\": maxsteps = 0 elif self.__handle_hook_result(command): return if stop_when(self): return if self.single_step(): return @property def is_at_breakpoint(self): # type: () -> bool \"\"\"Check if the emulator is at a breakpoint\"\"\" return self.raw.getEmulator().isAtBreakpoint() # Basic unicorn compatibility, because why not # You may prefer these aliases if you already know Unicorn API. reg_write = write_register reg_read = read_register mem_write = write_bytes mem_read = read_bytes mem_map = ( lambda _1, _2, _3: None ) # This is a noop - all memory is already available. emu_start = lambda self, begin, until: self.emulate(begin, until)","title":"Emulator"},{"location":"reference/#ghidralib.Emulator.emu_start","text":"","title":"emu_start"},{"location":"reference/#ghidralib.Emulator.is_at_breakpoint","text":"Check if the emulator is at a breakpoint","title":"is_at_breakpoint"},{"location":"reference/#ghidralib.Emulator.mem_map","text":"","title":"mem_map"},{"location":"reference/#ghidralib.Emulator.mem_read","text":"","title":"mem_read"},{"location":"reference/#ghidralib.Emulator.mem_write","text":"","title":"mem_write"},{"location":"reference/#ghidralib.Emulator.pc","text":"Get the program counter of the emulated program.","title":"pc"},{"location":"reference/#ghidralib.Emulator.reg_read","text":"","title":"reg_read"},{"location":"reference/#ghidralib.Emulator.reg_write","text":"","title":"reg_write"},{"location":"reference/#ghidralib.Emulator.sp","text":"Get the current stack pointer register value.","title":"sp"},{"location":"reference/#ghidralib.Emulator.sp_register","text":"Get the stack pointer register name for the emulated architecture.","title":"sp_register"},{"location":"reference/#ghidralib.Emulator.__getitem__","text":"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 Parameters: reg \u2013 the register or address to read from Source code in ghidralib.py def __getitem__(self, reg): # type: (Reg|int) -> int \"\"\"Read the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 :param reg: the register or address to read from\"\"\" return self.read_register(reg)","title":"__getitem__"},{"location":"reference/#ghidralib.Emulator.__handle_hook_result","text":"Handle a hook return value and return True if emulation should stop. Source code in ghidralib.py def __handle_hook_result(self, result): # type: (str|None) -> bool \"\"\"Handle a hook return value and return True if emulation should stop.\"\"\" if result is None or result == \"continue\": return False elif result == \"skip\": self.pc = Instruction(self.pc).next.address return False elif result == \"break\": return True else: raise RuntimeError(\"Invalid hook return value: {}\".format(result))","title":"__handle_hook_result"},{"location":"reference/#ghidralib.Emulator.__init__","text":"Create a new Emulator object. Source code in ghidralib.py def __init__(self): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper(Program.current()) GhidraWrapper.__init__(self, raw) # Use max_addr/2-0x8000 as stack pointer - this is 0x7fff8000 on 32-bit CPU. max_pointer = toAddr(0).getAddressSpace().getMaxAddress().getOffset() max_pointer = max_pointer % 2**64 # Java signed ints everywhere strike again. stack_off = ((max_pointer + 1) >> 1) - 0x8000 self.raw.writeRegister(self.raw.getStackPointerRegister(), stack_off) # TODO: add a simple allocation manager self._hooks = {} # type: dict[int, Callable[[Emulator], str|None]]","title":"__init__"},{"location":"reference/#ghidralib.Emulator.__run_with_hooks","text":"Run the Ghidra emulator, and transparently handle all hooks. Returns: \u2013 True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break). Source code in ghidralib.py def __run_with_hooks(self): # type: () -> bool \"\"\"Run the Ghidra emulator, and transparently handle all hooks. :return: True if emulator stopped at a breakpoint, or hook asked emulator to stop (by returning break).\"\"\" while not getMonitor().isCancelled(): is_breakpoint = self.raw.run(getMonitor()) if self.pc not in self._hooks: return is_breakpoint result = self._hooks[self.pc](self) if self.__handle_hook_result(result): return True return False","title":"__run_with_hooks"},{"location":"reference/#ghidralib.Emulator.__setitem__","text":"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py def __setitem__(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 :param reg: the register to write to :param value: the value to write\"\"\" self.write_register(reg, value)","title":"__setitem__"},{"location":"reference/#ghidralib.Emulator.add_breakpoint","text":"Add a breakpoint at the given address. Parameters: address \u2013 the address to break on Source code in ghidralib.py def add_breakpoint(self, address): # type: (Addr) -> None \"\"\"Add a breakpoint at the given address. :param address: the address to break on\"\"\" self.raw.setBreakpoint(resolve(address))","title":"add_breakpoint"},{"location":"reference/#ghidralib.Emulator.add_hook","text":"Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: 'continue' or None, to continue execution normally 'break' to stop execution 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported. Source code in ghidralib.py def add_hook( self, address, hook ): # type: (Addr, Callable[[Emulator], str|None]) -> None \"\"\"Add a hook at a specified address. Hook is a function that gets emulator as parameter. It can return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction Note: multiple hooks at the same address are not currently supported.\"\"\" addr = resolve(address).getOffset() if addr in self._hooks: raise ValueError(\"Multiple hooks at the same address are not supported\") self._hooks[addr] = hook","title":"add_hook"},{"location":"reference/#ghidralib.Emulator.clear_breakpoint","text":"Clear a breakpoint at the given address. Parameters: address \u2013 the address to clear breakpoint from Source code in ghidralib.py def clear_breakpoint(self, address): # type: (Addr) -> None \"\"\"Clear a breakpoint at the given address. :param address: the address to clear breakpoint from\"\"\" self.raw.clearBreakpoint(resolve(address))","title":"clear_breakpoint"},{"location":"reference/#ghidralib.Emulator.delete_hook_at","text":"Source code in ghidralib.py def delete_hook_at(self, address): # type: (Addr) -> None addr = resolve(address).getOffset() del self._hooks[addr]","title":"delete_hook_at"},{"location":"reference/#ghidralib.Emulator.emulate","text":"Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: 'continue' or None, to continue execution normally 'break' to stop execution 'skip' to skip the next instruction 'retry' like continue, but call the callback again (useful after pc change) 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). stop_when \u2013 the callback to call before each executed instruction. Return True here to stop emulation. maxsteps \u2013 the maximum number of steps to execute Source code in ghidralib.py def emulate( self, start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> None \"\"\"Emulate from start to end address, with callback for each executed address. >>> emu = Emulator() >>> def callback(emu): >>> print(\"executing {:x}'.format(emu.pc)) >>> emu.emulate(Function(\"main\").entrypoint, callback=callback, maxsteps=3) SUB ESP,0x2d4 PUSH EBX PUSH EBP Callback should return one of: * 'continue' or None, to continue execution normally * 'break' to stop execution * 'skip' to skip the next instruction * 'retry' like continue, but call the callback again (useful after pc change) * 'continue_then_break' to execute one last instruction before stopping Returning another value will cause an exception Callback is executed before stop_when condition is checked. This method is very flexible, but because of that it may be slower than pure Ghidra implementation. Consider .emulate_fast() when this method is too slow for you. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call before each executed instruction. Return one of the predefined constants here (see the docs for more info). :param stop_when: the callback to call before each executed instruction. Return True here to stop emulation. :param maxsteps: the maximum number of steps to execute\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] ends = [resolve(e).getOffset() for e in ends] while maxsteps > 0: maxsteps -= 1 if self.pc in ends: break command = callback(self) if command == \"retry\": continue elif command == \"continue_then_break\": maxsteps = 0 elif self.__handle_hook_result(command): return if stop_when(self): return if self.single_step(): return","title":"emulate"},{"location":"reference/#ghidralib.Emulator.emulate_fast","text":"Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' Parameters: start \u2013 the start address to emulate ends \u2013 one or many end address Source code in ghidralib.py def emulate_fast(self, start, ends): # type: (Addr, Addr|list[Addr]) -> None \"\"\"Emulate from start to end address, using Ghidra for fast emulation. The main loop of this function is in Java, which makes it faster, but makes some features (like callbacks) impossible. This function stops on error, when PC reaches one of the ends, and will also call hooks. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_bytes(0x2000, \"1\") >>> emulator.emulate_fast(0x1000, 0x1005) >>> emulator.read_bytes(0x2000, 1) '0' :param start: the start address to emulate :param ends: one or many end address\"\"\" self.set_pc(start) if not isinstance(ends, (list, tuple)): ends = [ends] for end in ends: self.add_breakpoint(end) is_breakpoint = self.__run_with_hooks() for end in ends: self.clear_breakpoint(end) if not is_breakpoint: err = self.raw.getLastError() raise RuntimeError(\"Error when running: {}\".format(err))","title":"emulate_fast"},{"location":"reference/#ghidralib.Emulator.has_hook_at","text":"Source code in ghidralib.py def has_hook_at(self, address): # type: (Addr) -> bool addr = resolve(address).getOffset() return addr in self._hooks","title":"has_hook_at"},{"location":"reference/#ghidralib.Emulator.new","text":"Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See emulate documentation for info about this method parameters. Source code in ghidralib.py @staticmethod def new( start, ends=[], callback=lambda emu: None, stop_when=lambda emu: False, maxsteps=2**48, ): # type: (Addr, Addr|list[Addr], Callable[[Emulator], str|None], Callable[[Emulator], bool], int) -> Emulator \"\"\"Emulate from start to end address, with callback for each executed address. >>> Emulator.new(\"main\", maxsteps=100)[\"EAX\"] 128 This function is a convenience wrapper around emulate and can be always replaced by three lines of code. The above is equivalent to: >>> emu = Emulator() >>> emu.emulate(\"main\", maxsteps=100) >>> emu[\"EAX\"] 128 This function may be used for quickly doing one-off emulations. See `emulate` documentation for info about this method parameters.\"\"\" emu = Emulator() emu.emulate(start, ends, callback, stop_when, maxsteps) return emu","title":"new"},{"location":"reference/#ghidralib.Emulator.read_bytes","text":"Read length bytes at address from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py def read_bytes(self, address, length): # type: (Addr, int) -> bytes \"\"\"Read `length` bytes at `address` from the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self.raw.readMemory(resolve(address), length) return _bytes_from_bytelist(bytelist)","title":"read_bytes"},{"location":"reference/#ghidralib.Emulator.read_cstring","text":"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_cstring(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated string from the emulated program. This function reads bytes until a nullbyte is encountered. >>> emu.read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string","title":"read_cstring"},{"location":"reference/#ghidralib.Emulator.read_register","text":"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py def read_register(self, reg): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return _python_int(self.raw.readRegister(reg))","title":"read_register"},{"location":"reference/#ghidralib.Emulator.read_u16","text":"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u16(self, address): # type: (Addr) -> int \"\"\"Read a 16bit unsigned integer from the emulated program. >>> emulator.write_u16(0x1000, 123) >>> emulator.read_u16(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 2))","title":"read_u16"},{"location":"reference/#ghidralib.Emulator.read_u32","text":"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u32(self, address): # type: (Addr) -> int \"\"\"Read a 32bit unsigned integer from the emulated program. >>> emulator.write_u32(0x1000, 123) >>> emulator.read_u32(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 4))","title":"read_u32"},{"location":"reference/#ghidralib.Emulator.read_u64","text":"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u64(self, address): # type: (Addr) -> int \"\"\"Read a 64bit unsigned integer from the emulated program. >>> emulator.write_u64(0x1000, 123) >>> emulator.read_u64(0x1000) 123 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 8))","title":"read_u64"},{"location":"reference/#ghidralib.Emulator.read_u8","text":"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to read from Source code in ghidralib.py def read_u8(self, address): # type: (Addr) -> int \"\"\"Read a byte from the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to read from\"\"\" return from_bytes(self.read_bytes(address, 1))","title":"read_u8"},{"location":"reference/#ghidralib.Emulator.read_unicode","text":"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_unicode(self, address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from the emulated program. This function reads bytes until a null character is encountered. >>> emu.read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = self.read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string","title":"read_unicode"},{"location":"reference/#ghidralib.Emulator.read_varnode","text":"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py def read_varnode(self, varnode): # type: (Varnode) -> int \"\"\"Read from the varnode from the emulated program. This method can't read hash varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: return varnode.offset elif varnode.is_address: rawnum = self.read_bytes(varnode.offset, varnode.size) return from_bytes(rawnum) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) rawnum = self.read_bytes(offset, varnode.size) return from_bytes(rawnum) elif varnode.is_stack: return self.raw.readStackValue(varnode.offset, varnode.size, False) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) return self.read_register(reg) raise RuntimeError(\"Unsupported varnode type\")","title":"read_varnode"},{"location":"reference/#ghidralib.Emulator.set_pc","text":"Set the program counter of the emulated program. Source code in ghidralib.py def set_pc(self, address): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self.raw.getPCRegister() self.raw.writeRegister(pc, resolve(address).getOffset())","title":"set_pc"},{"location":"reference/#ghidralib.Emulator.set_sp","text":"Set the current stack pointer register value. Parameters: value \u2013 new stack pointer value. Source code in ghidralib.py def set_sp(self, value): # type: (Addr) -> None \"\"\"Set the current stack pointer register value. :param value: new stack pointer value.\"\"\" self.write_register(self.sp_register, resolve(value).getOffset())","title":"set_sp"},{"location":"reference/#ghidralib.Emulator.single_step","text":"Do a single emulation step. This will step into calls. Note: This method will call hooks. Returns: \u2013 True if the emulation should be stopped, False otherwise. Source code in ghidralib.py def single_step(self): # type: () -> bool \"\"\"Do a single emulation step. This will step into calls. Note: This method *will* call hooks. :return: True if the emulation should be stopped, False otherwise.\"\"\" success = self.raw.step(getMonitor()) if not success: err = self.raw.getLastError() raise RuntimeError(\"Error at {}: {}\".format(self.pc, err)) if self.pc in self._hooks: result = self._hooks[self.pc](self) return self.__handle_hook_result(result) if self.is_at_breakpoint: return True return False","title":"single_step"},{"location":"reference/#ghidralib.Emulator.write_bytes","text":"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py def write_bytes(self, address, value): # type: (Addr, bytes) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_bytes(0x1000, \"1\") >>> emulator.read_bytes(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self.raw.writeMemory(resolve(address), value)","title":"write_bytes"},{"location":"reference/#ghidralib.Emulator.write_register","text":"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py def write_register(self, reg, value): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self.raw.writeRegister(reg, value)","title":"write_register"},{"location":"reference/#ghidralib.Emulator.write_u16","text":"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u16(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 16bit unsigned integer to the emulated program. >>> emulator.write_u16(0x1000, 13) >>> emulator.read_u16(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**16, \"value out of range\" self.write_bytes(address, to_bytes(value, 2))","title":"write_u16"},{"location":"reference/#ghidralib.Emulator.write_u32","text":"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u32(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 32bit unsigned integer to the emulated program. >>> emulator.write_u32(0x1000, 13) >>> emulator.read_u32(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**32, \"value out of range\" self.write_bytes(address, to_bytes(value, 4))","title":"write_u32"},{"location":"reference/#ghidralib.Emulator.write_u64","text":"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u64(self, address, value): # type: (Addr, int) -> None \"\"\"Write a 64bit unsigned integer to the emulated program. >>> emulator.write_u64(0x1000, 13) >>> emulator.read_u64(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**64, \"value out of range\" self.write_bytes(address, to_bytes(value, 8))","title":"write_u64"},{"location":"reference/#ghidralib.Emulator.write_u8","text":"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 Parameters: address \u2013 the address to write to Source code in ghidralib.py def write_u8(self, address, value): # type: (Addr, int) -> None \"\"\"Write a byte to the emulated program. >>> emulator.write_u8(0x1000, 13) >>> emulator.read_u8(0x1000) 13 :param address: the address to write to\"\"\" assert 0 <= value < 2**8, \"value out of range\" self.write_bytes(address, to_bytes(value, 1))","title":"write_u8"},{"location":"reference/#ghidralib.Emulator.write_varnode","text":"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 Parameters: varnode \u2013 the varnode to read from. Source code in ghidralib.py def write_varnode(self, varnode, value): # type: (Varnode, int) -> None \"\"\"Set a varnode value in the emulated context. This method can't set hash and constant varnodes. >>> fnc = Function(\"AddNumbers\") >>> emu = Emulator() >>> emu.write_varnode(fnc.parameters[0].varnode, 2) >>> emu.write_varnode(fnc.parameters[1].varnode, 2) >>> emu.emulate(fnc.entrypoint, stop_when=lambda emu: emu.pc not in fnc.body) >>> emu.read_varnode(func.return_variable.varnode) 4 :param varnode: the varnode to read from.\"\"\" varnode = Varnode(varnode) if varnode.is_constant: raise ValueError(\"Can't set value of a constant varnodes\") elif varnode.is_address: self.write_bytes(varnode.offset, to_bytes(value, varnode.size)) elif varnode.is_unique: space = Program.current().getAddressFactory().getUniqueSpace() offset = space.getAddress(varnode.offset) self.write_bytes(offset, to_bytes(value, varnode.size)) elif varnode.is_stack: self.raw.writeStackValue(varnode.offset, varnode.size, value) elif varnode.is_register: language = Program.current().getLanguage() reg = language.getRegister(varnode.raw.getAddress(), varnode.size) self.raw.writeRegister(reg, value) else: raise RuntimeError(\"Unsupported varnode type\")","title":"write_varnode"},{"location":"reference/#ghidralib.FlowType","text":"Bases: GhidraWrapper Wraps a Ghidra FlowType object Source code in ghidralib.py class FlowType(GhidraWrapper): \"\"\"Wraps a Ghidra FlowType object\"\"\" # TODO is class this necessary? This is just a subclass of RefType. @property def is_call(self): # type: () -> bool \"\"\"Return True if this flow is a call.\"\"\" return self.raw.isCall() @property def is_jump(self): # type: () -> bool \"\"\"Return True if this flow is a jump.\"\"\" return self.raw.isJump() @property def is_computed(self): # type: () -> bool \"\"\"Return True if this flow is a computed jump.\"\"\" return self.raw.isComputed() @property def is_conditional(self): # type: () -> bool \"\"\"Return True if this flow is a conditional jump.\"\"\" return self.raw.isConditional() @property def is_unconditional(self): # type: () -> bool \"\"\"Return True if this flow is an unconditional jump.\"\"\" return not self.is_conditional @property def is_terminal(self): # type: () -> bool \"\"\"Return True if this flow is a terminator.\"\"\" return self.raw.isTerminal() @property def has_fallthrough(self): # type: () -> bool \"\"\"Return True if this flow has a fallthrough.\"\"\" return self.raw.hasFallthrough() @property def is_override(self): # type: () -> bool \"\"\"Return True if this flow is an override.\"\"\" return self.raw.isOverride()","title":"FlowType"},{"location":"reference/#ghidralib.FlowType.has_fallthrough","text":"Return True if this flow has a fallthrough.","title":"has_fallthrough"},{"location":"reference/#ghidralib.FlowType.is_call","text":"Return True if this flow is a call.","title":"is_call"},{"location":"reference/#ghidralib.FlowType.is_computed","text":"Return True if this flow is a computed jump.","title":"is_computed"},{"location":"reference/#ghidralib.FlowType.is_conditional","text":"Return True if this flow is a conditional jump.","title":"is_conditional"},{"location":"reference/#ghidralib.FlowType.is_jump","text":"Return True if this flow is a jump.","title":"is_jump"},{"location":"reference/#ghidralib.FlowType.is_override","text":"Return True if this flow is an override.","title":"is_override"},{"location":"reference/#ghidralib.FlowType.is_terminal","text":"Return True if this flow is a terminator.","title":"is_terminal"},{"location":"reference/#ghidralib.FlowType.is_unconditional","text":"Return True if this flow is an unconditional jump.","title":"is_unconditional"},{"location":"reference/#ghidralib.Function","text":"Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Function object. Source code in ghidralib.py class Function(GhidraWrapper, BodyTrait): \"\"\"Wraps a Ghidra Function object.\"\"\" UNDERLYING_CLASS = GhFunction @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance(addr, GhFunction): return Function(addr) if isinstance(addr, Function): return Function(addr.raw) addr = try_resolve(addr) if addr is None: return None raw = Program.current().getListing().getFunctionContaining(addr) if raw is None: return None return Function(raw) # type: ignore @staticmethod def all(): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program.current().getFunctionManager().getFunctions(True) return [Function(f) for f in raw_functions] @staticmethod def create(address, name): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction(resolve(address), name) return Function(func) @property def return_type(self): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType(self.raw.getReturnType()) @property def return_variable(self): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter(self.raw.getReturn()) @property def entrypoint(self): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self.raw.getEntryPoint().getOffset() @property def address(self): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self.entrypoint @property def exitpoints(self): # type: () -> list[int] \"\"\"Get a list of exit points for the function. This will return a list of addresses of function terminators. For example, if a function has two RETs, this function will return their addresses.\"\"\" return [i.address for i in self.instructions if i.flow_type.is_terminal] @property def name(self): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self.raw.getName() @property def comment(self): # type: () -> str|None \"\"\"Get the comment of this function, if any.\"\"\" return self.raw.getComment() def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self.raw.setComment(comment) @property def is_thunk(self): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self.raw.isThunk() @property def is_external(self): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self.raw.isExternal() @property def repeatable_comment(self): # type: () -> str|None \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self.raw.getRepeatableComment() def set_repeatable_comment(self, comment): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self.raw.setRepeatableComment(comment) @property def parameters(self): # type: () -> list[Parameter] \"\"\"Get the parameters of this function.\"\"\" return [Parameter(raw) for raw in self.raw.getParameters()] def add_named_parameter(self, datatype, name): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self.raw.hasCustomVariableStorage(): raise ValueError( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType(datatype) param = ParameterImpl(name, data.raw, 0, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) def add_register_parameter( self, datatype, register, name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self.raw.hasCustomVariableStorage(): self.raw.setCustomVariableStorage(True) reg = Register(register) data = DataType(datatype) param = ParameterImpl(name, data.raw, reg.raw, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED) def fixup_body(self): # type: () -> bool \"\"\"Fixup the function body: follow control flow and add thunks.\"\"\" return CreateFunctionCmd.fixupFunctionBody( Program.current(), self.raw, getMonitor() ) @property def local_variables(self): # type: () -> list[Variable] \"\"\"Get the local variables of this function.\"\"\" return [Variable(raw) for raw in self.raw.getLocalVariables()] @property def variables(self): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [Variable(raw) for raw in self.raw.getAllVariables()] @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with a variable in this function.\"\"\" varnodes = [] for var in self.variables: varnodes.extend(var.varnodes) return varnodes @property def high_variables(self): # type: () -> list[HighVariable] \"\"\"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.high_function.variables @property def stack(self): # type: () -> list[Variable] \"\"\"Get the defined stack variables (both parameters and locals).\"\"\" raw_vars = self.raw.getStackFrame().getStackVariables() return [Variable(raw) for raw in raw_vars] def rename(self, name): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self.raw.setName(name, SourceType.USER_DEFINED) @property def instructions(self): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = Program.current().getListing() raw_instructions = listing.getInstructions(self.raw.getBody(), True) return [Instruction(raw) for raw in raw_instructions] @property def xrefs(self): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo(resolve(self.entrypoint)) return [Reference(raw) for raw in raw_refs] xrefs_to = xrefs @property def xref_addrs(self): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [xref.from_address for xref in self.xrefs] @property def callers(self): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function(raw) for raw in self.raw.getCallingFunctions(TaskMonitor.DUMMY) ] @property def called(self): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [Function(raw) for raw in self.raw.getCalledFunctions(TaskMonitor.DUMMY)] @property def fixup(self): # type: () -> str|None \"\"\"Get the fixup of this function.\"\"\" return self.raw.getCallFixup() @fixup.setter def fixup(self, fixup): # type: (str|None) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self.raw.setCallFixup(fixup) @property def calls(self): # type: () -> list[FunctionCall] \"\"\"Get all function calls to this function.\"\"\" calls = [] for ref in self.xrefs: if ref.is_call: calls.append(FunctionCall(self, ref.from_address)) return calls @property def basicblocks(self): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel(Program.current()) blocks = block_model.getCodeBlocksContaining( self.raw.getBody(), TaskMonitor.DUMMY ) return [BasicBlock(block) for block in blocks] def _decompile(self, simplify=\"decompile\"): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface() decompiler.openProgram(Program.current()) decompiler.setSimplificationStyle(simplify) decompiled = decompiler.decompileFunction(self.raw, 5, TaskMonitor.DUMMY) decompiler.closeProgram() decompiler.dispose() if decompiled is None: raise RuntimeError(\"Failed to decompile function {}\".format(self.name)) return decompiled def decompile(self): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self._decompile() return decompiled.getDecompiledFunction().getC() @property def clang_tokens(self): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self._decompile() return ClangTokenGroup(decompiled.getCCodeMarkup()) @property def high_function(self): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function() def get_high_function(self, simplify=\"decompile\"): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self._decompile(simplify) return HighFunction(decompiled.getHighFunction()) def get_high_pcode(self, simplify=\"decompile\"): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self.get_high_function(simplify).pcode @property def pcode_tree(self): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function().pcode_tree @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self.basicblocks: result.extend(block.pcode) return result @property def high_pcode(self): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_pcode() @property def high_basicblocks(self): # type: () -> list[PcodeBlock] \"\"\"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.high_function.basicblocks def get_high_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self.get_high_function().get_pcode_at(address) @property def high_symbols(self): # type: () -> list[HighSymbol] \"\"\"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self.get_high_function().symbols @property def primary_symbols(self): # type: () -> list[Symbol] \"\"\"Get the primary symbols for this function.\"\"\" symtable = Program.current().getSymbolTable() syms = symtable.getPrimarySymbolIterator(self.raw.getBody(), True) return [Symbol(s) for s in syms] @property def symbols(self): # type: () -> list[Symbol] \"\"\"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.\"\"\" body = self.raw.getBody() symbols = [] symtable = Program.current().getSymbolTable() for rng in body: for addr in rng: symbols.extend(symtable.getSymbols(addr)) return [Symbol(raw) for raw in symbols] @property def body(self): # type: () -> AddressSet \"\"\"Get the set of addresses of this function.\"\"\" return AddressSet(self.raw.getBody()) @property def control_flow(self): # type: () -> Graph[BasicBlock] \"\"\"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.\"\"\" return Graph.construct(self.basicblocks, lambda v: v.destinations) def emulate(self, *args, **kwargs): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs: # Jython doesn't support keyword arguments after args, apparently emulator = kwargs[\"emulator\"] else: emulator = Emulator() if len(args) != len(self.raw.getParameters()): raise ValueError( \"Wrong number of arguments for {} - got {} expected {}\".format( self.name, len(args), len(self.raw.getParameters()) ) ) for param, value in zip(self.parameters, args): emulator.write_varnode(param.varnode, value) emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body) return emulator def emulate_simple(self, *args, **kwargs): # type: (int, Emulator) -> int \"\"\"Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" context = self.emulate(*args, **kwargs) return context.read_varnode(self.return_variable.varnode) def symbolic_context(self): # type: () -> SymbolicPropogator \"\"\"Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. :return: a SymbolicPropogator instance with this function context.\"\"\" propagator = SymbolicPropogator.create() evaluator = ConstantPropagationContextEvaluator(getMonitor()) propagator.flow_constants(self.entrypoint, self.body, evaluator) return propagator","title":"Function"},{"location":"reference/#ghidralib.Function.UNDERLYING_CLASS","text":"","title":"UNDERLYING_CLASS"},{"location":"reference/#ghidralib.Function.address","text":"Get the address of this function.","title":"address"},{"location":"reference/#ghidralib.Function.basicblocks","text":"Get the basic blocks of this function.","title":"basicblocks"},{"location":"reference/#ghidralib.Function.body","text":"Get the set of addresses of this function.","title":"body"},{"location":"reference/#ghidralib.Function.called","text":"Get all functions that are called by this function.","title":"called"},{"location":"reference/#ghidralib.Function.callers","text":"Get all functions that call this function.","title":"callers"},{"location":"reference/#ghidralib.Function.calls","text":"Get all function calls to this function.","title":"calls"},{"location":"reference/#ghidralib.Function.clang_tokens","text":"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.","title":"clang_tokens"},{"location":"reference/#ghidralib.Function.comment","text":"Get the comment of this function, if any.","title":"comment"},{"location":"reference/#ghidralib.Function.control_flow","text":"Get the control flow graph of this function. In other words, get a graph that represents how the control flow can move between basic blocks in this function.","title":"control_flow"},{"location":"reference/#ghidralib.Function.entrypoint","text":"Get the entrypoint of this function.","title":"entrypoint"},{"location":"reference/#ghidralib.Function.exitpoints","text":"Get a list of exit points for the function. This will return a list of addresses of function terminators. For example, if a function has two RETs, this function will return their addresses.","title":"exitpoints"},{"location":"reference/#ghidralib.Function.fixup","text":"Get the fixup of this function.","title":"fixup"},{"location":"reference/#ghidralib.Function.high_basicblocks","text":"Get the (high-level) Pcode basic blocks for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_basicblocks"},{"location":"reference/#ghidralib.Function.high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_function"},{"location":"reference/#ghidralib.Function.high_pcode","text":"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_pcode"},{"location":"reference/#ghidralib.Function.high_symbols","text":"Get the high-level symbols for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_symbols"},{"location":"reference/#ghidralib.Function.high_variables","text":"Get all variables defined in this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_variables"},{"location":"reference/#ghidralib.Function.instructions","text":"Get the assembler instructions for this function.","title":"instructions"},{"location":"reference/#ghidralib.Function.is_external","text":"Return True if this function is external.","title":"is_external"},{"location":"reference/#ghidralib.Function.is_thunk","text":"Return True if this function is a thunk.","title":"is_thunk"},{"location":"reference/#ghidralib.Function.local_variables","text":"Get the local variables of this function.","title":"local_variables"},{"location":"reference/#ghidralib.Function.name","text":"Get the name of this function.","title":"name"},{"location":"reference/#ghidralib.Function.parameters","text":"Get the parameters of this function.","title":"parameters"},{"location":"reference/#ghidralib.Function.pcode","text":"Get the (low-level) Pcode for this function.","title":"pcode"},{"location":"reference/#ghidralib.Function.pcode_tree","text":"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.","title":"pcode_tree"},{"location":"reference/#ghidralib.Function.primary_symbols","text":"Get the primary symbols for this function.","title":"primary_symbols"},{"location":"reference/#ghidralib.Function.repeatable_comment","text":"Get the repeatable comment of this function, if any.","title":"repeatable_comment"},{"location":"reference/#ghidralib.Function.return_type","text":"Get the return type of this function.","title":"return_type"},{"location":"reference/#ghidralib.Function.return_variable","text":"Get the variable representing a return value of this function.","title":"return_variable"},{"location":"reference/#ghidralib.Function.stack","text":"Get the defined stack variables (both parameters and locals).","title":"stack"},{"location":"reference/#ghidralib.Function.symbols","text":"Get the symbols for this function. Unfortunately, the implementation of this function has to iterate over all function addresses (because SymbolTable doesn't export the right method), so it may be quite slow when called frequently. Consider using primary_symbols if adequate.","title":"symbols"},{"location":"reference/#ghidralib.Function.variables","text":"Get all variables defined in this function.","title":"variables"},{"location":"reference/#ghidralib.Function.varnodes","text":"Get all varnodes associated with a variable in this function.","title":"varnodes"},{"location":"reference/#ghidralib.Function.xref_addrs","text":"Get the source addresses of references to this function.","title":"xref_addrs"},{"location":"reference/#ghidralib.Function.xrefs","text":"Get the references to this function.","title":"xrefs"},{"location":"reference/#ghidralib.Function.xrefs_to","text":"","title":"xrefs_to"},{"location":"reference/#ghidralib.Function.add_named_parameter","text":"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented Source code in ghidralib.py def add_named_parameter(self, datatype, name): # type: (DataT, str) -> None \"\"\"Add a parameter with a specified name to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage is not implemented\"\"\" if self.raw.hasCustomVariableStorage(): raise ValueError( \"Sorry, adding named parameters is not implemented \" \"for functions with custom storage\" ) data = DataType(datatype) param = ParameterImpl(name, data.raw, 0, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED)","title":"add_named_parameter"},{"location":"reference/#ghidralib.Function.add_register_parameter","text":"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore Source code in ghidralib.py def add_register_parameter( self, datatype, register, name ): # type: (DataT, Reg, str) -> None \"\"\"Add a parameter stored in a specified register to this function. Warning: adding a register parameter will switch the function into custom storage mode. Adding named parameters in custom storage will not work anymore\"\"\" if not self.raw.hasCustomVariableStorage(): self.raw.setCustomVariableStorage(True) reg = Register(register) data = DataType(datatype) param = ParameterImpl(name, data.raw, reg.raw, Program.current()) self.raw.addParameter(param, SourceType.USER_DEFINED)","title":"add_register_parameter"},{"location":"reference/#ghidralib.Function.all","text":"Return all functions in the current program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = Program.current().getFunctionManager().getFunctions(True) return [Function(f) for f in raw_functions]","title":"all"},{"location":"reference/#ghidralib.Function.create","text":"Create a new function at the given address with the given name. Source code in ghidralib.py @staticmethod def create(address, name): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction(resolve(address), name) return Function(func)","title":"create"},{"location":"reference/#ghidralib.Function.decompile","text":"Get decompiled C code for the function as string. Source code in ghidralib.py def decompile(self): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self._decompile() return decompiled.getDecompiledFunction().getC()","title":"decompile"},{"location":"reference/#ghidralib.Function.emulate","text":"Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py def emulate(self, *args, **kwargs): # type: (int, Emulator) -> Emulator \"\"\"Emulate the function call with given args, and return final emulation state. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. >>> fnc = Function(\"ResolveName\") >>> emu = fnc.emulate(1379010213) >>> emu.read_unicode(emu[\"eax\"]) \"HKEY_CLASSES_ROOT\" :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" if \"emulator\" in kwargs: # Jython doesn't support keyword arguments after args, apparently emulator = kwargs[\"emulator\"] else: emulator = Emulator() if len(args) != len(self.raw.getParameters()): raise ValueError( \"Wrong number of arguments for {} - got {} expected {}\".format( self.name, len(args), len(self.raw.getParameters()) ) ) for param, value in zip(self.parameters, args): emulator.write_varnode(param.varnode, value) emulator.emulate(self.entrypoint, stop_when=lambda emu: emu.pc not in self.body) return emulator","title":"emulate"},{"location":"reference/#ghidralib.Function.emulate_simple","text":"Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the emulator kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 Parameters: args \u2013 The arguments to pass to the function. kwargs \u2013 pass emulator kwarg to use the provided emulator (default: create a new one). Source code in ghidralib.py def emulate_simple(self, *args, **kwargs): # type: (int, Emulator) -> int \"\"\"Emulate the function call with given args, and return the return value. The arguments are passed using a calling convention defined in Ghidra. If you want to use a different calling convention, or do additional setup, you have to use the Emulator class directly. You can pass your own emulator using the `emulator` kwarg. You can use this to do a pre-call setup (for example, write string parameters to memory). But don't use this to change call parameters, as they are always overwriten. Note: the name is not great, but I can't think of a better name that is not also very long. >>> fnc = Function(\"CustomHash\") >>> fnc.emulate_simple(\"HKEY_CLASSES_ROOT\") 1379010213 :param args: The arguments to pass to the function. :param kwargs: pass `emulator` kwarg to use the provided emulator (default: create a new one).\"\"\" context = self.emulate(*args, **kwargs) return context.read_varnode(self.return_variable.varnode)","title":"emulate_simple"},{"location":"reference/#ghidralib.Function.fixup_body","text":"Fixup the function body: follow control flow and add thunks. Source code in ghidralib.py def fixup_body(self): # type: () -> bool \"\"\"Fixup the function body: follow control flow and add thunks.\"\"\" return CreateFunctionCmd.fixupFunctionBody( Program.current(), self.raw, getMonitor() )","title":"fixup_body"},{"location":"reference/#ghidralib.Function.get","text":"Return a function at the given address, or None if no function exists there. Source code in ghidralib.py @staticmethod def get(addr): # type: (JavaObject|str|Addr) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" if isinstance(addr, GhFunction): return Function(addr) if isinstance(addr, Function): return Function(addr.raw) addr = try_resolve(addr) if addr is None: return None raw = Program.current().getListing().getFunctionContaining(addr) if raw is None: return None return Function(raw) # type: ignore","title":"get"},{"location":"reference/#ghidralib.Function.get_high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py def get_high_function(self, simplify=\"decompile\"): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self._decompile(simplify) return HighFunction(decompiled.getHighFunction())","title":"get_high_function"},{"location":"reference/#ghidralib.Function.get_high_pcode","text":"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py def get_high_pcode(self, simplify=\"decompile\"): # type: (str) -> list[PcodeOp] \"\"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self.get_high_function(simplify).pcode","title":"get_high_pcode"},{"location":"reference/#ghidralib.Function.get_high_pcode_at","text":"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py def get_high_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self.get_high_function().get_pcode_at(address)","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.Function.rename","text":"Change the name of this function. Source code in ghidralib.py def rename(self, name): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self.raw.setName(name, SourceType.USER_DEFINED)","title":"rename"},{"location":"reference/#ghidralib.Function.set_comment","text":"Set the comment of this function. Source code in ghidralib.py def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment of this function.\"\"\" self.raw.setComment(comment)","title":"set_comment"},{"location":"reference/#ghidralib.Function.set_repeatable_comment","text":"Set the repeatable comment of this function. Source code in ghidralib.py def set_repeatable_comment(self, comment): # type: (str|None) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self.raw.setRepeatableComment(comment)","title":"set_repeatable_comment"},{"location":"reference/#ghidralib.Function.symbolic_context","text":"Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. Returns: \u2013 a SymbolicPropogator instance with this function context. Source code in ghidralib.py def symbolic_context(self): # type: () -> SymbolicPropogator \"\"\"Returns a SymbolicPropogator instance for this function. This can be used to get a known values of registers at various addresses. >>> fnc = Function(0x004061EC) >>> ctx = fnc.symbolic_context() >>> print(ctx.register(0x004061fb, \"eax\")) TODO: This method should implement a hack described in https://github.com/NationalSecurityAgency/ghidra/issues/3581 because built-in Ghidra symbolic propagator doesn't support memory accesses. :return: a SymbolicPropogator instance with this function context.\"\"\" propagator = SymbolicPropogator.create() evaluator = ConstantPropagationContextEvaluator(getMonitor()) propagator.flow_constants(self.entrypoint, self.body, evaluator) return propagator","title":"symbolic_context"},{"location":"reference/#ghidralib.FunctionCall","text":"Bases: BodyTrait Represents a function call at a given location in the program. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py class FunctionCall(BodyTrait): \"\"\"Represents a function call at a given location in the program. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__(self, function, address): # type: (Function, Addr) -> None self.called_function = function self._address = resolve(address) @property def address(self): # type: () -> int return self._address.getOffset() @property def caller(self): # type: () -> Function|None \"\"\"Get the function where this function call takes place.\"\"\" return Function.get(self._address) calling_function = caller @property def instruction(self): # type: () -> Instruction return Instruction(self._address) @property def callee(self): # type: () -> Function \"\"\"Get the function being called.\"\"\" return self.called_function def infer_context(self): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"].\"\"\" basicblock = BasicBlock(self._address) return Emulator.new(basicblock.start_address, self._address) @property def high_pcodeop(self): # type: () -> PcodeOp|None \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp.get_high_pcode_at(self._address): if pcode_op.opcode != pcode_op.CALL: continue return pcode_op raise RuntimeError(\"No CALL at {}\".format(self.address)) @property def high_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" op = self.high_pcodeop if not op: return [] return op.inputs[1:] # skip function addr def infer_args(self): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" args = [] for varnode in self.high_varnodes: if varnode.value is not None: args.append(varnode.value) else: args.append(None) return args @property def body(self): return self.instruction.body","title":"FunctionCall"},{"location":"reference/#ghidralib.FunctionCall.address","text":"","title":"address"},{"location":"reference/#ghidralib.FunctionCall.body","text":"","title":"body"},{"location":"reference/#ghidralib.FunctionCall.called_function","text":"","title":"called_function"},{"location":"reference/#ghidralib.FunctionCall.callee","text":"Get the function being called.","title":"callee"},{"location":"reference/#ghidralib.FunctionCall.caller","text":"Get the function where this function call takes place.","title":"caller"},{"location":"reference/#ghidralib.FunctionCall.calling_function","text":"","title":"calling_function"},{"location":"reference/#ghidralib.FunctionCall.high_pcodeop","text":"Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_pcodeop"},{"location":"reference/#ghidralib.FunctionCall.high_varnodes","text":"Get a list of the arguments passed to this function call, as high varnodes. In other words, decompile the function, and return the varnodes associated with the function parameters, as seen by Ghidra decompiler. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_varnodes"},{"location":"reference/#ghidralib.FunctionCall.instruction","text":"","title":"instruction"},{"location":"reference/#ghidralib.FunctionCall.__init__","text":"Source code in ghidralib.py def __init__(self, function, address): # type: (Function, Addr) -> None self.called_function = function self._address = resolve(address)","title":"__init__"},{"location":"reference/#ghidralib.FunctionCall.infer_args","text":"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py def infer_args(self): # type: () -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method tries to get arguments of this function, as seen by Ghidra decompiler. A limited symbolic execution is performed to resolve the pointers. If it's not possible to get an argument, None is stored in its place. Warning: this works on decompiled functions only, so it will work if the call is done from a region not recognised as function. Warning: this method needs to decompile the function, and is therefore slow. \"\"\" args = [] for varnode in self.high_varnodes: if varnode.value is not None: args.append(varnode.value) else: args.append(None) return args","title":"infer_args"},{"location":"reference/#ghidralib.FunctionCall.infer_context","text":"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"]. Source code in ghidralib.py def infer_context(self): # type: () -> Emulator \"\"\"Emulate the code before this function call, and return the state. The goal of this function is to recover the state of the CPU before the function call, as well as possible. This will work well when parameters are constants written just before the call, for example: mov eax, 30 mov ebx, DAT_encrypted_string call decrypt_string Then recovering eax is as simple as call.infer_context()[\"eax\"].\"\"\" basicblock = BasicBlock(self._address) return Emulator.new(basicblock.start_address, self._address)","title":"infer_context"},{"location":"reference/#ghidralib.GenericT","text":"Source code in ghidralib.py class GenericT: pass","title":"GenericT"},{"location":"reference/#ghidralib.GhidraWrapper","text":"Bases: object The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py class GhidraWrapper(object): \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__(self, raw): # type: (JavaObject|int|str|GhidraWrapper) -> None \"\"\"Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: * If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. * If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). * If \"raw\" is None at this point, raise an exception. * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. * Save the final \"raw\" value.\"\"\" if isinstance(raw, (int, long, str, unicode, GenericAddress)): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr(self, \"get\"): new_raw = self.get(raw) # type: ignore if new_raw is None: # Show original data for better error messages raise RuntimeError(\"Unable to wrap \" + str(raw)) raw = new_raw else: raise RuntimeError(\"Unable to wrap a primitive: \" + str(raw)) while isinstance(raw, GhidraWrapper): # In case someone tries to Function(Function(\"main\")) us raw = raw.raw if raw is None: raise RuntimeError(\"Object doesn't exist (refusing to wrap None)\") # TODO - remove the conditional checks and implement this everywhere if hasattr(self, \"UNDERLYING_CLASS\"): wrapped_type = getattr(self, \"UNDERLYING_CLASS\") if not isinstance(raw, wrapped_type): raise RuntimeError( \"You are trying to wrap {} as {}\".format( raw.__class__.__name__, self.__class__.__name__ ) ) def _java_cast(raw): # type: (Any) -> JavaObject \"\"\"This function exists only to make type-checker happy\"\"\" return raw self.raw = _java_cast(raw) def __str__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__str__() def __repr__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__repr__() def __tojava__(self, klass): \"\"\"Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet.\"\"\" return self.raw def __hash__(self): # type: () -> int \"\"\"Return the hash of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.hashCode() def __eq__(self, other): # type: (object) -> bool \"\"\"Check if this object is equal to another. This just forwards the call to the underlying object.\"\"\" if isinstance(other, GhidraWrapper): return self.raw.equals(other.raw) return self.raw.equals(other)","title":"GhidraWrapper"},{"location":"reference/#ghidralib.GhidraWrapper.raw","text":"","title":"raw"},{"location":"reference/#ghidralib.GhidraWrapper.__eq__","text":"Check if this object is equal to another. This just forwards the call to the underlying object. Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Check if this object is equal to another. This just forwards the call to the underlying object.\"\"\" if isinstance(other, GhidraWrapper): return self.raw.equals(other.raw) return self.raw.equals(other)","title":"__eq__"},{"location":"reference/#ghidralib.GhidraWrapper.__hash__","text":"Return the hash of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __hash__(self): # type: () -> int \"\"\"Return the hash of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.hashCode()","title":"__hash__"},{"location":"reference/#ghidralib.GhidraWrapper.__init__","text":"Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). If \"raw\" is None at this point, raise an exception. If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. Save the final \"raw\" value. Source code in ghidralib.py def __init__(self, raw): # type: (JavaObject|int|str|GhidraWrapper) -> None \"\"\"Initialize the wrapper. This function will try to resolve the given object to a Ghidra object. The algorithm is as follows: * If \"raw\" is a primitive type (int, long, str, unicode, Address), try to resolve it with a static \"get\" method of the subclass. * If \"raw\" is a GhidraWrapper, unwrap it (so GhidraWrapper(GhidraWrapper(x)) is always the same as GhidraWrapper(x). * If \"raw\" is None at this point, raise an exception. * If the subclass has attribute UNDERLYING_CLASS, assert that the wrapped type is of the expected type. * Save the final \"raw\" value.\"\"\" if isinstance(raw, (int, long, str, unicode, GenericAddress)): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr(self, \"get\"): new_raw = self.get(raw) # type: ignore if new_raw is None: # Show original data for better error messages raise RuntimeError(\"Unable to wrap \" + str(raw)) raw = new_raw else: raise RuntimeError(\"Unable to wrap a primitive: \" + str(raw)) while isinstance(raw, GhidraWrapper): # In case someone tries to Function(Function(\"main\")) us raw = raw.raw if raw is None: raise RuntimeError(\"Object doesn't exist (refusing to wrap None)\") # TODO - remove the conditional checks and implement this everywhere if hasattr(self, \"UNDERLYING_CLASS\"): wrapped_type = getattr(self, \"UNDERLYING_CLASS\") if not isinstance(raw, wrapped_type): raise RuntimeError( \"You are trying to wrap {} as {}\".format( raw.__class__.__name__, self.__class__.__name__ ) ) def _java_cast(raw): # type: (Any) -> JavaObject \"\"\"This function exists only to make type-checker happy\"\"\" return raw self.raw = _java_cast(raw)","title":"__init__"},{"location":"reference/#ghidralib.GhidraWrapper.__repr__","text":"Return a string representation of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __repr__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__repr__()","title":"__repr__"},{"location":"reference/#ghidralib.GhidraWrapper.__str__","text":"Return a string representation of this object. This just forwards the call to the underlying object. Source code in ghidralib.py def __str__(self): # type: () -> str \"\"\"Return a string representation of this object. This just forwards the call to the underlying object.\"\"\" return self.raw.__str__()","title":"__str__"},{"location":"reference/#ghidralib.GhidraWrapper.__tojava__","text":"Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet. Source code in ghidralib.py def __tojava__(self, klass): \"\"\"Make it possible to pass this object to Java methods. This only works in Jython, I didn't find a way to do this in JPype yet.\"\"\" return self.raw","title":"__tojava__"},{"location":"reference/#ghidralib.Graph","text":"Bases: GenericT , GhidraWrapper Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see _get_unique_string() method. Source code in ghidralib.py class Graph(GenericT, GhidraWrapper): \"\"\"Wraps a Ghidra AttributedGraph object. We'd like to store arbitrary object in the graph, but it only supports strings for keys (and names). We have a way to convert objects we are interested in to strings - see _get_unique_string() method.\"\"\" # TODO: maybe this should be a GDirectedGraph, so we get some algorithms # for free, and we can just convert it for display. def __init__(self, raw): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper.__init__(self, raw) self.data = {} @staticmethod def create(name=None, description=None): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType(name, description, ArrayList([]), ArrayList([])) return Graph(AttributedGraph(name, graphtype, description)) @staticmethod def construct( vertexlist, getedges ): # type: (list[T], Callable[[T], list[T]]) -> Graph[T] \"\"\"Create a new Graph from a list of vertices and a function to get edges. :param vertexlist: The list of vertices. :param getedges: A function that gets a list of destinations from a vertex.\"\"\" g = Graph.create() for v in vertexlist: g.vertex(v) for v in vertexlist: for dest in getedges(v): if dest in g: g.edge(v, dest) return g def __contains__(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = _get_unique_string(vtx) vobj = self.raw.getVertex(vid) return self.raw.containsVertex(vobj) def has_vertex(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self def vertex(self, vtx, name=None): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = _get_unique_string(vtx) name = name or str(vtx) self.raw.addVertex(vid, name) self.data[vid] = vtx return vtx def edge(self, src, dst): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = _get_unique_string(src) dstid = _get_unique_string(dst) srcobj = self.raw.getVertex(srcid) dstobj = self.raw.getVertex(dstid) self.raw.addEdge(srcobj, dstobj) @property def vertices(self): # type: () -> list[T] \"\"\"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.\"\"\" return [self.__resolve(vid.getId()) for vid in self.raw.vertexSet()] @property def vertex_count(self): # type: () -> int \"\"\"Return the number of vertices in this graph.\"\"\" return self.raw.vertexSet().size() def __len__(self): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self.vertex_count @property def edges(self): # type: () -> list[tuple[T, T]] \"\"\"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.\"\"\" result = [] for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) frmobj = self.data.get(frm, frm) toobj = self.data.get(to, to) result.append((frmobj, toobj)) return result @property def edge_count(self): # type: () -> int \"\"\"Return the number of edges in this graph.\"\"\" return self.raw.edgeSet().size() @property def name(self): # type: () -> str \"\"\"Return the name of this graph.\"\"\" return self.raw.getName() @property def description(self): # type: () -> str \"\"\"Return the description of this graph.\"\"\" return self.raw.getDescription() def to_dot(self): # type: () -> str \"\"\"Return a DOT representation of this graph.\"\"\" result = [] result.append(\"digraph {} {{\".format(self.name)) for v in self.raw.vertexSet(): result.append(' \"{}\" [label=\"{}\"];'.format(v.getId(), v.getName())) for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) result.append(' \"{}\" -> \"{}\";'.format(frm.getId(), to.getId())) result.append(\"}\") return \"\\n\".join(result) def show(self): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self.raw.getGraphType() description = graphtype.getDescription() options = GraphDisplayOptions(graphtype) broker = getState().tool.getService(GraphDisplayBroker) display = broker.getDefaultGraphDisplay(False, getMonitor()) display.setGraph(self.raw, options, description, False, getMonitor()) def __resolve(self, vid): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self.data: return self.data[vid] else: return vid # type: ignore graph created outside of ghidralib? def dfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop() if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents def toposort(self, origin): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] :param origin: The ID of the origin vertex to start the sort from. :returns: a list of vertex IDs in topological order.\"\"\" visited = set() result = [] def dfs(vid): visited.add(vid) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): target = self.raw.getEdgeTarget(edge) if target.getId() not in visited: dfs(target.getId()) result.append(self.__resolve(vid)) dfs(_get_unique_string(origin)) for vid in self.raw.vertexSet(): if vid.getId() not in visited: dfs(vid.getId()) return result def bfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop(0) if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents","title":"Graph"},{"location":"reference/#ghidralib.Graph.data","text":"","title":"data"},{"location":"reference/#ghidralib.Graph.description","text":"Return the description of this graph.","title":"description"},{"location":"reference/#ghidralib.Graph.edge_count","text":"Return the number of edges in this graph.","title":"edge_count"},{"location":"reference/#ghidralib.Graph.edges","text":"Get all edges in this graph. Warning: this constructs the list every time, so it's not a light operation. Use edge_count for counting.","title":"edges"},{"location":"reference/#ghidralib.Graph.name","text":"Return the name of this graph.","title":"name"},{"location":"reference/#ghidralib.Graph.vertex_count","text":"Return the number of vertices in this graph.","title":"vertex_count"},{"location":"reference/#ghidralib.Graph.vertices","text":"Get all vertices in this graph. Warning: this constructs the list every time, so it's not a light operation. Use vertex_count for counting.","title":"vertices"},{"location":"reference/#ghidralib.Graph.__contains__","text":"Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py def __contains__(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" vid = _get_unique_string(vtx) vobj = self.raw.getVertex(vid) return self.raw.containsVertex(vobj)","title":"__contains__"},{"location":"reference/#ghidralib.Graph.__init__","text":"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. Parameters: raw \u2013 The AttributedGraph object to wrap. Source code in ghidralib.py def __init__(self, raw): # type: (AttributedGraph) -> None \"\"\"Create a new Graph wrapper. We have to keep track of additional data, since AttributedGraph is a bit clunky and can only store string IDs and string values. :param raw: The AttributedGraph object to wrap.\"\"\" GhidraWrapper.__init__(self, raw) self.data = {}","title":"__init__"},{"location":"reference/#ghidralib.Graph.__len__","text":"Return the number of vertices in this graph. To get the number of edges, use edge_count. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Return the number of vertices in this graph. To get the number of edges, use edge_count.\"\"\" return self.vertex_count","title":"__len__"},{"location":"reference/#ghidralib.Graph.__resolve","text":"Resolve a vertex ID to a vertex object. Parameters: vid \u2013 The ID of the vertex to resolve. Source code in ghidralib.py def __resolve(self, vid): # type: (str) -> T \"\"\"Resolve a vertex ID to a vertex object. :param vid: The ID of the vertex to resolve.\"\"\" if vid in self.data: return self.data[vid] else: return vid # type: ignore graph created outside of ghidralib?","title":"__resolve"},{"location":"reference/#ghidralib.Graph.bfs","text":"Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Source code in ghidralib.py def bfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a breadth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.bfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop(0) if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents","title":"bfs"},{"location":"reference/#ghidralib.Graph.construct","text":"Create a new Graph from a list of vertices and a function to get edges. Parameters: vertexlist \u2013 The list of vertices. getedges \u2013 A function that gets a list of destinations from a vertex. Source code in ghidralib.py @staticmethod def construct( vertexlist, getedges ): # type: (list[T], Callable[[T], list[T]]) -> Graph[T] \"\"\"Create a new Graph from a list of vertices and a function to get edges. :param vertexlist: The list of vertices. :param getedges: A function that gets a list of destinations from a vertex.\"\"\" g = Graph.create() for v in vertexlist: g.vertex(v) for v in vertexlist: for dest in getedges(v): if dest in g: g.edge(v, dest) return g","title":"construct"},{"location":"reference/#ghidralib.Graph.create","text":"Create a new Graph. Parameters: name \u2013 The name of the graph. If None, a default name will be used. description \u2013 The description of the graph. If None, a default description will be used. Returns: \u2013 a new Graph object. Source code in ghidralib.py @staticmethod def create(name=None, description=None): # type: (str|None, str|None) -> Graph[Any] \"\"\"Create a new Graph. :param name: The name of the graph. If None, a default name will be used. :param description: The description of the graph. If None, a default description will be used. :returns: a new Graph object. \"\"\" name = name or \"Graph\" description = description or \"Graph\" graphtype = GraphType(name, description, ArrayList([]), ArrayList([])) return Graph(AttributedGraph(name, graphtype, description))","title":"create"},{"location":"reference/#ghidralib.Graph.dfs","text":"Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. Parameters: origin \u2013 The ID of the vertex to start the search from. callback \u2013 A callback function to call for each vertex visited. Returns: \u2013 A dictionary of parent vertices for each visited vertex. Source code in ghidralib.py def dfs( self, origin, callback=lambda _: None ): # type: (T, Callable[[T], None]) -> dict[T, T|None] \"\"\"Perform a depth-first search on this graph, starting from the given vertex. The callback will be called for each vertex visited when first visited, and the returned value is a dictionary of parent vertices for each visited vertex. >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.dfs(a) {'a': None, 'b': 'a', 'c': 'b'} Warning: This won't reach every node in the graph, if it's not connected. :param origin: The ID of the vertex to start the search from. :param callback: A callback function to call for each vertex visited. :returns: A dictionary of parent vertices for each visited vertex. \"\"\" tovisit = [(None, _get_unique_string(origin))] visited = set() parents = {origin: None} # type: dict[T, T|None] while tovisit: parent, vid = tovisit.pop() if vid in visited: continue visited.add(vid) vobj = self.__resolve(vid) parents[vobj] = parent callback(vobj) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): tovisit.append((vobj, self.raw.getEdgeTarget(edge).getId())) return parents","title":"dfs"},{"location":"reference/#ghidralib.Graph.edge","text":"Create an edge between two vertices in this graph. Parameters: src \u2013 The source vertex ID. dst \u2013 The destination vertex ID. Source code in ghidralib.py def edge(self, src, dst): # type: (T, T) -> None \"\"\"Create an edge between two vertices in this graph. :param src: The source vertex ID. :param dst: The destination vertex ID.\"\"\" srcid = _get_unique_string(src) dstid = _get_unique_string(dst) srcobj = self.raw.getVertex(srcid) dstobj = self.raw.getVertex(dstid) self.raw.addEdge(srcobj, dstobj)","title":"edge"},{"location":"reference/#ghidralib.Graph.has_vertex","text":"Check if a given vertex exists in this graph. Parameters: vtx \u2013 The ID of the vertex to check. Source code in ghidralib.py def has_vertex(self, vtx): # type: (T) -> bool \"\"\"Check if a given vertex exists in this graph. :param vtx: The ID of the vertex to check.\"\"\" return vtx in self","title":"has_vertex"},{"location":"reference/#ghidralib.Graph.show","text":"Display this graph in the Ghidra GUI. Source code in ghidralib.py def show(self): # type: () -> None \"\"\"Display this graph in the Ghidra GUI.\"\"\" graphtype = self.raw.getGraphType() description = graphtype.getDescription() options = GraphDisplayOptions(graphtype) broker = getState().tool.getService(GraphDisplayBroker) display = broker.getDefaultGraphDisplay(False, getMonitor()) display.setGraph(self.raw, options, description, False, getMonitor())","title":"show"},{"location":"reference/#ghidralib.Graph.to_dot","text":"Return a DOT representation of this graph. Source code in ghidralib.py def to_dot(self): # type: () -> str \"\"\"Return a DOT representation of this graph.\"\"\" result = [] result.append(\"digraph {} {{\".format(self.name)) for v in self.raw.vertexSet(): result.append(' \"{}\" [label=\"{}\"];'.format(v.getId(), v.getName())) for e in self.raw.edgeSet(): frm = self.raw.getEdgeSource(e) to = self.raw.getEdgeTarget(e) result.append(' \"{}\" -> \"{}\";'.format(frm.getId(), to.getId())) result.append(\"}\") return \"\\n\".join(result)","title":"to_dot"},{"location":"reference/#ghidralib.Graph.toposort","text":"Perform a topological sort on this graph, starting from the given vertex. Parameters: origin \u2013 The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] Returns: \u2013 a list of vertex IDs in topological order. Source code in ghidralib.py def toposort(self, origin): # type: (T) -> list[T] \"\"\"Perform a topological sort on this graph, starting from the given vertex. :param origin: The ID of the vertex to start the sort from. The order is such that if there is an edge from A to B, then A will come before B in the list. This means that if the graph is connected and acyclic then \"origin\" will be the last element in the list. On a practical example, for a call graph, this means that if A calls B, then B will be before A in the list - so if you want to process from the bottom up, you should use the entry point of the program as the origin. In the example below, the entry point is \"a\", \"a\" calls \"b\", and \"b\" calls \"c\": >>> g = Graph.create() >>> a, b, c = g.vertex(\"a\"), g.vertex(\"b\"), g.vertex(\"c\") >>> g.edge(a, b) >>> g.edge(b, c) >>> g.toposort(a) ['c', 'b', 'a'] :param origin: The ID of the origin vertex to start the sort from. :returns: a list of vertex IDs in topological order.\"\"\" visited = set() result = [] def dfs(vid): visited.add(vid) for edge in self.raw.edgesOf(self.raw.getVertex(vid)): target = self.raw.getEdgeTarget(edge) if target.getId() not in visited: dfs(target.getId()) result.append(self.__resolve(vid)) dfs(_get_unique_string(origin)) for vid in self.raw.vertexSet(): if vid.getId() not in visited: dfs(vid.getId()) return result","title":"toposort"},{"location":"reference/#ghidralib.Graph.vertex","text":"Get or create a vertex in this graph. Parameters: vtx \u2013 The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. name \u2013 The name of the vertex. If not provided, the ID will be used as the name. Returns: \u2013 vtx parameter is returned Source code in ghidralib.py def vertex(self, vtx, name=None): # type: (T, str|None) -> T \"\"\"Get or create a vertex in this graph. :param vtx: The ID of the new vertex, or any \"Vertexable\" object that can be used to identify the vertex. :param name: The name of the vertex. If not provided, the ID will be used as the name. :returns: vtx parameter is returned\"\"\" vid = _get_unique_string(vtx) name = name or str(vtx) self.raw.addVertex(vid, name) self.data[vid] = vtx return vtx","title":"vertex"},{"location":"reference/#ghidralib.HighFunction","text":"Bases: GhidraWrapper Source code in ghidralib.py class HighFunction(GhidraWrapper): @staticmethod def get(address): # type: (JavaObject|str|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance(address, GhHighFunction): return HighFunction(address) func = Function.get(address) if func is None: return None return func.high_function @property def function(self): # type: () -> Function \"\"\"Get the underlying function of this high function.\"\"\" return Function(self.raw.getFunction()) def get_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve(address) return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)] @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.\"\"\" return [PcodeOp(raw) for raw in self.raw.getPcodeOps()] @property def data_flow(self): # type: () -> Graph[PcodeOp] \"\"\"Get a data flow graph of varnodes in this function. Note: I don't think this method is currently very useful, but you can use it to easily get information about all varnodes that impact a value of another varnode :returns: A graph where vertexes are varnodes, and edges mean that target varnode is a result of operation on source varnodes.\"\"\" g = Graph.create() for op in self.pcode: if op.output: for inp in op.inputs: g.vertex(op.output) g.vertex(inp) g.edge(inp, op.output) return g @property def basicblocks(self): # type: () -> list[PcodeBlock] \"\"\"Get a list of basic blocks in this high function.\"\"\" return [PcodeBlock(raw) for raw in self.raw.getBasicBlocks()] @property def pcode_tree(self): # type: () -> BlockGraph \"\"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" edge_map = {} ingraph = GhBlockGraph() for block in self.basicblocks: gb = BlockCopy(block.raw, block.raw.getStart()) ingraph.addBlock(gb) edge_map[block.raw] = gb for block in self.basicblocks: for edge in block.outgoing_edges: ingraph.addEdge(edge_map[block.raw], edge_map[edge.raw]) ingraph.setIndices() decompiler = DecompInterface() decompiler.openProgram(Program.current()) outgraph = decompiler.structureGraph(ingraph, 0, getMonitor()) return BlockGraph(outgraph) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes used in this function.\"\"\" return [Varnode(raw) for raw in self.raw.locRange()] @property def symbols(self): # type: () -> list[HighSymbol] \"\"\"Get high symbols used in this function (including parameters).\"\"\" sm = self.raw.getLocalSymbolMap() return [HighSymbol(symbol) for symbol in sm.getSymbols()] @property def variables(self): # type: () -> list[HighVariable] \"\"\"Get high variables defined in this function.\"\"\" result = [] for sym in self.symbols: var = sym.variable if var is not None: result.append(var) return result def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance(other, HighFunction): return False return self.function == other.function","title":"HighFunction"},{"location":"reference/#ghidralib.HighFunction.basicblocks","text":"Get a list of basic blocks in this high function.","title":"basicblocks"},{"location":"reference/#ghidralib.HighFunction.data_flow","text":"Get a data flow graph of varnodes in this function. Note: I don't think this method is currently very useful, but you can use it to easily get information about all varnodes that impact a value of another varnode Returns: \u2013 A graph where vertexes are varnodes, and edges mean that target varnode is a result of operation on source varnodes.","title":"data_flow"},{"location":"reference/#ghidralib.HighFunction.function","text":"Get the underlying function of this high function.","title":"function"},{"location":"reference/#ghidralib.HighFunction.pcode","text":"Get a list of all high PcodeOps in this function. Note: high PcodeOps are called PcodeOpAST internally.","title":"pcode"},{"location":"reference/#ghidralib.HighFunction.pcode_tree","text":"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.","title":"pcode_tree"},{"location":"reference/#ghidralib.HighFunction.symbols","text":"Get high symbols used in this function (including parameters).","title":"symbols"},{"location":"reference/#ghidralib.HighFunction.variables","text":"Get high variables defined in this function.","title":"variables"},{"location":"reference/#ghidralib.HighFunction.varnodes","text":"Get all varnodes used in this function.","title":"varnodes"},{"location":"reference/#ghidralib.HighFunction.__eq__","text":"Compare two high functions. Fun fact - Ghidra doesn't know how to do this. Source code in ghidralib.py def __eq__(self, other): # type: (object) -> bool \"\"\"Compare two high functions. Fun fact - Ghidra doesn't know how to do this.\"\"\" if not isinstance(other, HighFunction): return False return self.function == other.function","title":"__eq__"},{"location":"reference/#ghidralib.HighFunction.get","text":"Get a HighFunction at a given address, or None if there is none. Source code in ghidralib.py @staticmethod def get(address): # type: (JavaObject|str|Addr) -> HighFunction|None \"\"\"Get a HighFunction at a given address, or None if there is none.\"\"\" if isinstance(address, GhHighFunction): return HighFunction(address) func = Function.get(address) if func is None: return None return func.high_function","title":"get"},{"location":"reference/#ghidralib.HighFunction.get_pcode_at","text":"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address. Source code in ghidralib.py def get_pcode_at(self, address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a list of PcodeOps at a given address. This list may be empty even if there are instructions at that address.\"\"\" address = resolve(address) return [PcodeOp(raw) for raw in self.raw.getPcodeOps(address)]","title":"get_pcode_at"},{"location":"reference/#ghidralib.HighSymbol","text":"Bases: GhidraWrapper Source code in ghidralib.py class HighSymbol(GhidraWrapper): def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source) @property def size(self): # type: () -> int \"\"\"Return the size of this symbol in bytes\"\"\" return self.raw.getSize() @property def data_type(self): # type: () -> DataType \"\"\"Return the data type of this symbol\"\"\" return DataType(self.raw.getDataType()) @property def variable(self): # type: () -> HighVariable|None \"\"\"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.\"\"\" raw = self.raw.getHighVariable() if raw is None: return None return HighVariable(raw) @property def name(self): # type: () -> str \"\"\"Return the name of this symbol\"\"\" return self.raw.getName() @property def symbol(self): # type: () -> Symbol|None \"\"\"Get the corresponding symbol, if it exists.\"\"\" raw = self.raw.getSymbol() if raw is None: return None return Symbol(raw) @property def is_this_pointer(self): # type: () -> bool \"\"\"Return True if this symbol is a \"this\" pointer for a class\"\"\" return self.raw.isThisPointer()","title":"HighSymbol"},{"location":"reference/#ghidralib.HighSymbol.data_type","text":"Return the data type of this symbol","title":"data_type"},{"location":"reference/#ghidralib.HighSymbol.is_this_pointer","text":"Return True if this symbol is a \"this\" pointer for a class","title":"is_this_pointer"},{"location":"reference/#ghidralib.HighSymbol.name","text":"Return the name of this symbol","title":"name"},{"location":"reference/#ghidralib.HighSymbol.size","text":"Return the size of this symbol in bytes","title":"size"},{"location":"reference/#ghidralib.HighSymbol.symbol","text":"Get the corresponding symbol, if it exists.","title":"symbol"},{"location":"reference/#ghidralib.HighSymbol.variable","text":"Return the high variable associated with this symbol, if any. The symbol may have multiple HighVariables associated with it. This method returns the biggest one.","title":"variable"},{"location":"reference/#ghidralib.HighSymbol.rename","text":"Rename this high symbol. Parameters: new_name \u2013 The new name of the symbol source \u2013 The source of the symbol Source code in ghidralib.py def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this high symbol. :param new_name: The new name of the symbol :param source: The source of the symbol\"\"\" HighFunctionDBUtil.updateDBVariable(self.raw, new_name, None, source)","title":"rename"},{"location":"reference/#ghidralib.HighVariable","text":"Bases: GhidraWrapper Source code in ghidralib.py class HighVariable(GhidraWrapper): @property def symbol(self): # type: () -> HighSymbol return HighSymbol(self.raw.getSymbol()) def rename(self, new_name): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self.symbol.rename(new_name) @property def size(self): # type: () -> int \"\"\"Return the size of this variable in bytes\"\"\" return self.raw.getSize() @property def data_type(self): # type: () -> DataType \"\"\"Return the data type of this variable\"\"\" return DataType(self.raw.getDataType()) @property def name(self): # type: () -> str \"\"\"Return the name of this variable\"\"\" return self.raw.getName() @property def varnode(self): # type: () -> Varnode \"\"\"Return the Varnode that represents this variable\"\"\" return Varnode(self.raw.getRepresentative()) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Return all Varnodes that represent this variable at some point\"\"\" return [Varnode(vn) for vn in self.raw.getInstances()] @property def is_unaffected(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are is unaffected.\"\"\" return any(vn.is_unaffected for vn in self.varnodes) @property def is_persistent(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are persistent.\"\"\" return any(vn.is_persistent for vn in self.varnodes) @property def is_addr_tied(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are addr tied.\"\"\" return any(vn.is_addr_tied for vn in self.varnodes) @property def is_input(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are input.\"\"\" return any(vn.is_input for vn in self.varnodes) @property def is_free(self): # type: () -> bool \"\"\"Return True if ALL varnodes of this variable are free.\"\"\" return all(vn.is_free for vn in self.varnodes)","title":"HighVariable"},{"location":"reference/#ghidralib.HighVariable.data_type","text":"Return the data type of this variable","title":"data_type"},{"location":"reference/#ghidralib.HighVariable.is_addr_tied","text":"Return True if ALL varnodes of this variable are addr tied.","title":"is_addr_tied"},{"location":"reference/#ghidralib.HighVariable.is_free","text":"Return True if ALL varnodes of this variable are free.","title":"is_free"},{"location":"reference/#ghidralib.HighVariable.is_input","text":"Return True if ALL varnodes of this variable are input.","title":"is_input"},{"location":"reference/#ghidralib.HighVariable.is_persistent","text":"Return True if ALL varnodes of this variable are persistent.","title":"is_persistent"},{"location":"reference/#ghidralib.HighVariable.is_unaffected","text":"Return True if ALL varnodes of this variable are is unaffected.","title":"is_unaffected"},{"location":"reference/#ghidralib.HighVariable.name","text":"Return the name of this variable","title":"name"},{"location":"reference/#ghidralib.HighVariable.size","text":"Return the size of this variable in bytes","title":"size"},{"location":"reference/#ghidralib.HighVariable.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.HighVariable.varnode","text":"Return the Varnode that represents this variable","title":"varnode"},{"location":"reference/#ghidralib.HighVariable.varnodes","text":"Return all Varnodes that represent this variable at some point","title":"varnodes"},{"location":"reference/#ghidralib.HighVariable.rename","text":"Rename this high variable. Source code in ghidralib.py def rename(self, new_name): # type: (str) -> None \"\"\"Rename this high variable.\"\"\" self.symbol.rename(new_name)","title":"rename"},{"location":"reference/#ghidralib.Instruction","text":"Bases: GhidraWrapper , BodyTrait Wraps a Ghidra Instruction object Source code in ghidralib.py class Instruction(GhidraWrapper, BodyTrait): \"\"\"Wraps a Ghidra Instruction object\"\"\" @staticmethod def get(address): # type: (JavaObject|str|Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve(address): raw = getInstructionAt(resolve(address)) else: raw = address if raw is None: return None return Instruction(raw) @staticmethod def all(): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program.current().getListing().getInstructions(True) return [Instruction(raw) for raw in raw_instructions] @staticmethod def create(address): # type: (Addr) -> Instruction \"\"\"Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use `assemble_at` instead. If you want to just create an instruction object, use `assemble` method. :param address: The address where instruction should be created. \"\"\" addr = resolve(address) disassemble(addr) return Instruction(addr) @property def mnemonic(self): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self.raw.getMnemonicString() @property def next(self): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction(self.raw.getNext()) @property def previous(self): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction(self.raw.getPrevious()) prev = previous @property def flows(self): # type: () -> list[int] \"\"\"Get a set of possible flows (next executed addresses). Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO, but I'm being faithful to Ghidra API.\"\"\" return [addr.getOffset() for addr in self.raw.getFlows()] @property def all_flows(self): # type: () -> list[int] \"\"\"Get a set of possible flows (next executed addresses). Note: this INCLUDES fallthrough.\"\"\" fallthrough = self.fallthrough return self.flows + ([fallthrough] if fallthrough else []) @property def pcode(self): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [PcodeOp(raw) for raw in self.raw.getPcode()] @property def output_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of output (LOW) varnodes for this instruction.\"\"\" return [op.output for op in self.pcode if op.output] @property def input_varnodes(self): # type: () -> list[Varnode] \"\"\"Get a list of output (LOW) varnodes for this instruction.\"\"\" return [inp for op in self.pcode if op.output for inp in op.inputs] @property def high_pcode(self): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp.get_high_pcode_at(self.address) @property def xrefs_from(self): # type: () -> list[Reference] \"\"\"Get a list of references from this instruction.\"\"\" return [Reference(raw) for raw in self.raw.getReferencesFrom()] @property def xrefs_to(self): # type: () -> list[Reference] \"\"\"Get a list of references to this instruction.\"\"\" return [Reference(raw) for raw in self.raw.getReferenceIteratorTo()] @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return _bytes_from_bytelist(self.raw.getBytes()) @property def length(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.raw.getLength() def __len__(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.length def __convert_operand(self, operand): # type: (JavaObject) -> Operand \"\"\"Convert an operand to a scalar or address.\"\"\" from ghidra.program.model.address import Address # type: ignore from ghidra.program.model.scalar import Scalar # type: ignore if isinstance(operand, GhRegister): return Operand(_python_str(operand.getName())) elif isinstance(operand, Address): return Operand(operand.getOffset()) elif isinstance(operand, Scalar): return Operand(operand.getValue()) elif _is_array(operand): operands = [self.__convert_operand(o).raw for o in operand] # type: ignore if len(operands) == 1: # Unwrap the operands if there is only one operand return Operand(operands[0]) return Operand(operands) # type: ignore (we know there are no nested lists) else: raise RuntimeError(\"Don't know how to read operand {}\".format(operand)) def operand(self, ndx): # type: (int) -> Operand \"\"\"Get the nth operand of this instruction as an object.\"\"\" operand = self.raw.getOpObjects(ndx) return self.__convert_operand(operand) @property def address(self): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self.raw.getAddress().getOffset() @property def operands(self): # type: () -> list[Operand] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. If you know operand type, call .scalar(), .register() or .list() instead.\"\"\" return [self.operand(i) for i in range(self.raw.getNumOperands())] @property def operand_values(self): # type: () -> list[int|str|list[int|str]] \"\"\"Return operands as primitive values (int or a string representation). This is equivalent to calling .operands() and then calling .value() on each operand.\"\"\" return [operand.value for operand in self.operands] @property def flow_type(self): # type: () -> FlowType \"\"\"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return FlowType(self.raw.getFlowType()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference( self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type) @property def body(self): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet.create(self.address, self.length) @property def has_fallthrough(self): # type: () -> bool \"\"\"Return true if this instruction has a fallthrough.\"\"\" return self.raw.hasFallthrough() @property def fallthrough(self): # type: () -> int|None \"\"\"Get the fallthrough address (next address executed), if any. For normal instruction, this is the next instruction address. For jumps, this is None. Can be overriden by fallthrough override.\"\"\" fall = self.raw.getFallThrough() if not fall: return None return fall.getOffset() def set_fallthrough_override(self, value): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override :param value: new fallthrough address\"\"\" self.raw.setFallThrough(resolve(value)) def clear_fallthrough_override(self): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" self.raw.clearFallThroughOverride() @property def has_fallthrough_override(self): # type: () -> bool \"\"\"Return true if this instruction fallthrough was overriden.\"\"\" return self.raw.isFallThroughOverridden() def write_jumptable(self, targets): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [resolve(addr) for addr in targets] for dest in targets: disassemble(dest) self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP) func = Function.get(self.address) if func is None: raise RuntimeError(\"Instruction is not part of a function\") targetlist = ArrayList([dest for dest in targets]) jumpTab = JumpTable(toAddr(self.address), targetlist, True) jumpTab.writeOverride(func.raw) CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor())","title":"Instruction"},{"location":"reference/#ghidralib.Instruction.address","text":"Get the address of this instruction.","title":"address"},{"location":"reference/#ghidralib.Instruction.all_flows","text":"Get a set of possible flows (next executed addresses). Note: this INCLUDES fallthrough.","title":"all_flows"},{"location":"reference/#ghidralib.Instruction.body","text":"Get the address range this instruction.","title":"body"},{"location":"reference/#ghidralib.Instruction.bytes","text":"Get the bytes of this instruction.","title":"bytes"},{"location":"reference/#ghidralib.Instruction.fallthrough","text":"Get the fallthrough address (next address executed), if any. For normal instruction, this is the next instruction address. For jumps, this is None. Can be overriden by fallthrough override.","title":"fallthrough"},{"location":"reference/#ghidralib.Instruction.flow_type","text":"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP","title":"flow_type"},{"location":"reference/#ghidralib.Instruction.flows","text":"Get a set of possible flows (next executed addresses). Note: this DOES NOT INCLUDE a fallthrough. A strange design decision IMO, but I'm being faithful to Ghidra API.","title":"flows"},{"location":"reference/#ghidralib.Instruction.has_fallthrough","text":"Return true if this instruction has a fallthrough.","title":"has_fallthrough"},{"location":"reference/#ghidralib.Instruction.has_fallthrough_override","text":"Return true if this instruction fallthrough was overriden.","title":"has_fallthrough_override"},{"location":"reference/#ghidralib.Instruction.high_pcode","text":"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.","title":"high_pcode"},{"location":"reference/#ghidralib.Instruction.input_varnodes","text":"Get a list of output (LOW) varnodes for this instruction.","title":"input_varnodes"},{"location":"reference/#ghidralib.Instruction.length","text":"Get the length of this instruction in bytes.","title":"length"},{"location":"reference/#ghidralib.Instruction.mnemonic","text":"Get the mnemonic of this instruction.","title":"mnemonic"},{"location":"reference/#ghidralib.Instruction.next","text":"Get the next instruction.","title":"next"},{"location":"reference/#ghidralib.Instruction.operand_values","text":"Return operands as primitive values (int or a string representation). This is equivalent to calling .operands() and then calling .value() on each operand.","title":"operand_values"},{"location":"reference/#ghidralib.Instruction.operands","text":"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. If you know operand type, call .scalar(), .register() or .list() instead.","title":"operands"},{"location":"reference/#ghidralib.Instruction.output_varnodes","text":"Get a list of output (LOW) varnodes for this instruction.","title":"output_varnodes"},{"location":"reference/#ghidralib.Instruction.pcode","text":"Get a list of Pcode operations that this instruction was parsed to","title":"pcode"},{"location":"reference/#ghidralib.Instruction.prev","text":"","title":"prev"},{"location":"reference/#ghidralib.Instruction.previous","text":"Get the previous instruction.","title":"previous"},{"location":"reference/#ghidralib.Instruction.xrefs_from","text":"Get a list of references from this instruction.","title":"xrefs_from"},{"location":"reference/#ghidralib.Instruction.xrefs_to","text":"Get a list of references to this instruction.","title":"xrefs_to"},{"location":"reference/#ghidralib.Instruction.__convert_operand","text":"Convert an operand to a scalar or address. Source code in ghidralib.py def __convert_operand(self, operand): # type: (JavaObject) -> Operand \"\"\"Convert an operand to a scalar or address.\"\"\" from ghidra.program.model.address import Address # type: ignore from ghidra.program.model.scalar import Scalar # type: ignore if isinstance(operand, GhRegister): return Operand(_python_str(operand.getName())) elif isinstance(operand, Address): return Operand(operand.getOffset()) elif isinstance(operand, Scalar): return Operand(operand.getValue()) elif _is_array(operand): operands = [self.__convert_operand(o).raw for o in operand] # type: ignore if len(operands) == 1: # Unwrap the operands if there is only one operand return Operand(operands[0]) return Operand(operands) # type: ignore (we know there are no nested lists) else: raise RuntimeError(\"Don't know how to read operand {}\".format(operand))","title":"__convert_operand"},{"location":"reference/#ghidralib.Instruction.__len__","text":"Get the length of this instruction in bytes. Source code in ghidralib.py def __len__(self): # type: () -> int \"\"\"Get the length of this instruction in bytes.\"\"\" return self.length","title":"__len__"},{"location":"reference/#ghidralib.Instruction.add_operand_reference","text":"Add a reference to an operand of this instruction. Source code in ghidralib.py def add_operand_reference( self, op_ndx, ref_addr, ref_type, src_type=SourceType.USER_DEFINED ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" self.raw.addOperandReference(op_ndx, resolve(ref_addr), ref_type.raw, src_type)","title":"add_operand_reference"},{"location":"reference/#ghidralib.Instruction.all","text":"Get all instruction defined in the current program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Instruction] \"\"\"Get all instruction defined in the current program.\"\"\" raw_instructions = Program.current().getListing().getInstructions(True) return [Instruction(raw) for raw in raw_instructions]","title":"all"},{"location":"reference/#ghidralib.Instruction.clear_fallthrough_override","text":"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override Source code in ghidralib.py def clear_fallthrough_override(self): # type: () -> None \"\"\"This clears the fallthrough override for this instruction. Alias for del self.fallthrough_override\"\"\" self.raw.clearFallThroughOverride()","title":"clear_fallthrough_override"},{"location":"reference/#ghidralib.Instruction.create","text":"Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use assemble_at instead. If you want to just create an instruction object, use assemble method. Parameters: address \u2013 The address where instruction should be created. Source code in ghidralib.py @staticmethod def create(address): # type: (Addr) -> Instruction \"\"\"Create an instruction at the given address. Note: this will force ghidra to disassemble at the given address, and return the created instruction. If you want to actually change the instruction at the given address, use `assemble_at` instead. If you want to just create an instruction object, use `assemble` method. :param address: The address where instruction should be created. \"\"\" addr = resolve(address) disassemble(addr) return Instruction(addr)","title":"create"},{"location":"reference/#ghidralib.Instruction.get","text":"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func: disassemble_at instead. Parameters: address \u2013 The address of the instruction. Returns: \u2013 The instruction at the address, or None if not found. Source code in ghidralib.py @staticmethod def get(address): # type: (JavaObject|str|Addr) -> Instruction|None \"\"\"Get an instruction at the address, or None if not found. Note: This will return None if the instruction is not defined in Ghidra at the given address. If you want to disassemble an address, not necessarily defined in Ghidra, try :func:`disassemble_at` instead. :param address: The address of the instruction. :return: The instruction at the address, or None if not found.\"\"\" if can_resolve(address): raw = getInstructionAt(resolve(address)) else: raw = address if raw is None: return None return Instruction(raw)","title":"get"},{"location":"reference/#ghidralib.Instruction.operand","text":"Get the nth operand of this instruction as an object. Source code in ghidralib.py def operand(self, ndx): # type: (int) -> Operand \"\"\"Get the nth operand of this instruction as an object.\"\"\" operand = self.raw.getOpObjects(ndx) return self.__convert_operand(operand)","title":"operand"},{"location":"reference/#ghidralib.Instruction.set_fallthrough_override","text":"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override Parameters: value \u2013 new fallthrough address Source code in ghidralib.py def set_fallthrough_override(self, value): # type: (Addr) -> None \"\"\"Override the fallthrough address for this instruction. This sets the next instruction that will be executed after this instruction, assuming the current instruction doesn't jump anywhere. You can clear this with clear_fallthrough_override :param value: new fallthrough address\"\"\" self.raw.setFallThrough(resolve(value))","title":"set_fallthrough_override"},{"location":"reference/#ghidralib.Instruction.write_jumptable","text":"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?). Source code in ghidralib.py def write_jumptable(self, targets): # type: (list[Addr]) -> None \"\"\"Provide a list of addresses where this instruction may jump. Warning: For this to work, the instruction must be a part of a function. This is useful for fixing unrecognised switches, for example. Note: the new switch instruction will use all references of type COMPUTED_JUMP already defined for the instruction (maybe we should clear them first?).\"\"\" targets = [resolve(addr) for addr in targets] for dest in targets: disassemble(dest) self.add_operand_reference(0, dest, RefType.COMPUTED_JUMP) func = Function.get(self.address) if func is None: raise RuntimeError(\"Instruction is not part of a function\") targetlist = ArrayList([dest for dest in targets]) jumpTab = JumpTable(toAddr(self.address), targetlist, True) jumpTab.writeOverride(func.raw) CreateFunctionCmd.fixupFunctionBody(Program.current(), func.raw, getMonitor())","title":"write_jumptable"},{"location":"reference/#ghidralib.JavaObject","text":"A fake class, used for static type hints. Source code in ghidralib.py class JavaObject: \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__(self, name): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"JavaObject"},{"location":"reference/#ghidralib.JavaObject.__getattribute__","text":"This attribute exists to make mypy happy. Source code in ghidralib.py def __getattribute__(self, name): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"__getattribute__"},{"location":"reference/#ghidralib.MemoryBlock","text":"Bases: GhidraWrapper , BodyTrait A Ghidra wrapper for a Ghidra MemoryBlock Source code in ghidralib.py class MemoryBlock(GhidraWrapper, BodyTrait): \"\"\"A Ghidra wrapper for a Ghidra MemoryBlock\"\"\" @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> MemoryBlock|None \"\"\"Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address :param raw_or_name: name or address of MemoryBlock to get :return: the MemoryBlock, or None if not found \"\"\" memory = Program.current().getMemory() if isinstance(raw_or_name, str): raw = memory.getBlock(raw_or_name) if raw is not None: return MemoryBlock(raw) addr = try_resolve(raw_or_name) if addr is None: return None return MemoryBlock(memory.getBlock(addr)) @staticmethod def all(): # type: () -> list[MemoryBlock] \"\"\"Get all MemoryBlocks in the current program\"\"\" raw_blocks = Program.current().getMemory().getBlocks() return [MemoryBlock(raw) for raw in raw_blocks] @property def comment(self): # type: () -> str \"\"\"Get the comment associated with this MemoryBlock\"\"\" return self.raw.getComment() @property def start(self): # type: () -> int \"\"\"Get the first address of this MemoryBlock\"\"\" return self.raw.getStart().getOffset() @property def name(self): # type: () -> str \"\"\"Get the name of this MemoryBlock\"\"\" return self.raw.getName() address = start @property def end(self): # type: () -> int return self.raw.getEnd().getOffset() @property def size(self): # type: () -> int \"\"\"Get the size of this MemoryBlock\"\"\" return int(self.raw.getSize()) length = size @property def body(self): # type: () -> AddressSet \"\"\"Get the address range this instruction.\"\"\" return AddressSet.create(self.address, self.length) @property def bytes(self): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return read_bytes(self.address, self.length)","title":"MemoryBlock"},{"location":"reference/#ghidralib.MemoryBlock.address","text":"","title":"address"},{"location":"reference/#ghidralib.MemoryBlock.body","text":"Get the address range this instruction.","title":"body"},{"location":"reference/#ghidralib.MemoryBlock.bytes","text":"Get the bytes of this instruction.","title":"bytes"},{"location":"reference/#ghidralib.MemoryBlock.comment","text":"Get the comment associated with this MemoryBlock","title":"comment"},{"location":"reference/#ghidralib.MemoryBlock.end","text":"","title":"end"},{"location":"reference/#ghidralib.MemoryBlock.length","text":"","title":"length"},{"location":"reference/#ghidralib.MemoryBlock.name","text":"Get the name of this MemoryBlock","title":"name"},{"location":"reference/#ghidralib.MemoryBlock.size","text":"Get the size of this MemoryBlock","title":"size"},{"location":"reference/#ghidralib.MemoryBlock.start","text":"Get the first address of this MemoryBlock","title":"start"},{"location":"reference/#ghidralib.MemoryBlock.all","text":"Get all MemoryBlocks in the current program Source code in ghidralib.py @staticmethod def all(): # type: () -> list[MemoryBlock] \"\"\"Get all MemoryBlocks in the current program\"\"\" raw_blocks = Program.current().getMemory().getBlocks() return [MemoryBlock(raw) for raw in raw_blocks]","title":"all"},{"location":"reference/#ghidralib.MemoryBlock.get","text":"Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address Parameters: raw_or_name \u2013 name or address of MemoryBlock to get Returns: \u2013 the MemoryBlock, or None if not found Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> MemoryBlock|None \"\"\"Gets a MemoryBlock by name or containing the given address. Note: for a string argument, this will try to get memoryblock by name, and if it fails, it will fall back to the regular behaviour of \"resolve the symbol to the address, and get element by address :param raw_or_name: name or address of MemoryBlock to get :return: the MemoryBlock, or None if not found \"\"\" memory = Program.current().getMemory() if isinstance(raw_or_name, str): raw = memory.getBlock(raw_or_name) if raw is not None: return MemoryBlock(raw) addr = try_resolve(raw_or_name) if addr is None: return None return MemoryBlock(memory.getBlock(addr))","title":"get"},{"location":"reference/#ghidralib.Operand","text":"Operand helper for instruction, may be a register, const or a list Source code in ghidralib.py class Operand: \"\"\"Operand helper for instruction, may be a register, const or a list\"\"\" def __init__(self, operand): # type: (str|int|list[int|str]) -> None self.raw = operand @property def is_register(self): # type: () -> bool \"\"\"Return True if this operand is a register.\"\"\" return isinstance(self.raw, Str) @property def is_scalar(self): # type: () -> bool \"\"\"Return True if this operand is a scalar.\"\"\" return isinstance(self.raw, (int, long)) @property def is_list(self): # type: () -> bool \"\"\"Return True if this operand is a list.\"\"\" return isinstance(self.raw, list) @property def register(self): # type: () -> str \"\"\"Gets this operand value as a register name\"\"\" if not isinstance(self.raw, (str)): raise RuntimeError(\"Operand {} is not a register\".format(self.raw)) return self.raw @property def scalar(self): # type: () -> int \"\"\"Gets this operand value as a scalar\"\"\" if not isinstance(self.raw, (int, long)): raise RuntimeError(\"Operand {} is not a scalar\".format(self.raw)) return self.raw @property def list(self): # type: () -> list \"\"\"Gets this operand value as a list\"\"\" if not isinstance(self.raw, list): raise RuntimeError(\"Operand {} is not a list\".format(self.raw)) return self.raw @property def value(self): # type: () -> str|int|list[int|str] \"\"\"Return internal representation of this operand - string, int or a list\"\"\" return self.raw","title":"Operand"},{"location":"reference/#ghidralib.Operand.is_list","text":"Return True if this operand is a list.","title":"is_list"},{"location":"reference/#ghidralib.Operand.is_register","text":"Return True if this operand is a register.","title":"is_register"},{"location":"reference/#ghidralib.Operand.is_scalar","text":"Return True if this operand is a scalar.","title":"is_scalar"},{"location":"reference/#ghidralib.Operand.list","text":"Gets this operand value as a list","title":"list"},{"location":"reference/#ghidralib.Operand.raw","text":"","title":"raw"},{"location":"reference/#ghidralib.Operand.register","text":"Gets this operand value as a register name","title":"register"},{"location":"reference/#ghidralib.Operand.scalar","text":"Gets this operand value as a scalar","title":"scalar"},{"location":"reference/#ghidralib.Operand.value","text":"Return internal representation of this operand - string, int or a list","title":"value"},{"location":"reference/#ghidralib.Operand.__init__","text":"Source code in ghidralib.py def __init__(self, operand): # type: (str|int|list[int|str]) -> None self.raw = operand","title":"__init__"},{"location":"reference/#ghidralib.Parameter","text":"Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py class Parameter(Variable): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal(self): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self.raw.getOrdinal() @property def formal_data_type(self): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType(self.raw.getFormalDataType())","title":"Parameter"},{"location":"reference/#ghidralib.Parameter.formal_data_type","text":"Returns the formal data type of this parameter.","title":"formal_data_type"},{"location":"reference/#ghidralib.Parameter.ordinal","text":"Returns the ordinal of this parameter.","title":"ordinal"},{"location":"reference/#ghidralib.PcodeBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py class PcodeBlock(GhidraWrapper): @property def outgoing_edges(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getOut(i)) for i in range(self.raw.getOutSize())] @property def incoming_edges(self): # type: () -> list[PcodeBlock] return [_pcode_node(self.raw.getIn(i)) for i in range(self.raw.getInSize())] @property def has_children(self): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance(self.raw, GhBlockGraph) @property def pcode(self): # type: () -> list[PcodeOp] raw_pcode = collect_iterator(self.raw.getRef().getIterator()) return [PcodeOp(raw) for raw in raw_pcode]","title":"PcodeBlock"},{"location":"reference/#ghidralib.PcodeBlock.has_children","text":"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.","title":"has_children"},{"location":"reference/#ghidralib.PcodeBlock.incoming_edges","text":"","title":"incoming_edges"},{"location":"reference/#ghidralib.PcodeBlock.outgoing_edges","text":"","title":"outgoing_edges"},{"location":"reference/#ghidralib.PcodeBlock.pcode","text":"","title":"pcode"},{"location":"reference/#ghidralib.PcodeOp","text":"Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py class PcodeOp(GhidraWrapper): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at(address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function(address).get_high_pcode_at(address) @property def address(self): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self.raw.getSeqnum().getTarget().getOffset() @property def opcode(self): # type: () -> int return self.raw.getOpcode() @property def mnemonic(self): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self.raw.getMnemonic() @property def inputs(self): # type: () -> list[Varnode] return [Varnode(raw) for raw in self.raw.getInputs()] @property def inputs_simple(self): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [varnode.simple for varnode in self.inputs] @property def output(self): # type: () -> Varnode|None if self.raw.getOutput() is None: return None return Varnode(self.raw.getOutput()) @property def result(self): # type: () -> int|None \"\"\"Try to evaluate the pcode operation to a constant value. Right now this is very poor and doesn't try to implement most of the opcodes. Mostly because I suspect I'm reinventing the wheel, and there is code to do this already in Ghidra. :return: Result of this operation, or None if can't be evaluated as const.\"\"\" if self.opcode == PcodeOp.COPY: return self.inputs[0].value return None","title":"PcodeOp"},{"location":"reference/#ghidralib.PcodeOp.BOOL_AND","text":"","title":"BOOL_AND"},{"location":"reference/#ghidralib.PcodeOp.BOOL_NEGATE","text":"","title":"BOOL_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.BOOL_OR","text":"","title":"BOOL_OR"},{"location":"reference/#ghidralib.PcodeOp.BOOL_XOR","text":"","title":"BOOL_XOR"},{"location":"reference/#ghidralib.PcodeOp.BRANCH","text":"","title":"BRANCH"},{"location":"reference/#ghidralib.PcodeOp.BRANCHIND","text":"","title":"BRANCHIND"},{"location":"reference/#ghidralib.PcodeOp.CALL","text":"","title":"CALL"},{"location":"reference/#ghidralib.PcodeOp.CALLIND","text":"","title":"CALLIND"},{"location":"reference/#ghidralib.PcodeOp.CALLOTHER","text":"","title":"CALLOTHER"},{"location":"reference/#ghidralib.PcodeOp.CAST","text":"","title":"CAST"},{"location":"reference/#ghidralib.PcodeOp.CBRANCH","text":"","title":"CBRANCH"},{"location":"reference/#ghidralib.PcodeOp.COPY","text":"","title":"COPY"},{"location":"reference/#ghidralib.PcodeOp.CPOOLREF","text":"","title":"CPOOLREF"},{"location":"reference/#ghidralib.PcodeOp.EXTRACT","text":"","title":"EXTRACT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ABS","text":"","title":"FLOAT_ABS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ADD","text":"","title":"FLOAT_ADD"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_CEIL","text":"","title":"FLOAT_CEIL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_DIV","text":"","title":"FLOAT_DIV"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_EQUAL","text":"","title":"FLOAT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT","text":"","title":"FLOAT_FLOAT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOOR","text":"","title":"FLOAT_FLOOR"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_INT2FLOAT","text":"","title":"FLOAT_INT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESS","text":"","title":"FLOAT_LESS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESSEQUAL","text":"","title":"FLOAT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_MULT","text":"","title":"FLOAT_MULT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NAN","text":"","title":"FLOAT_NAN"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NEG","text":"","title":"FLOAT_NEG"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NOTEQUAL","text":"","title":"FLOAT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ROUND","text":"","title":"FLOAT_ROUND"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SQRT","text":"","title":"FLOAT_SQRT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SUB","text":"","title":"FLOAT_SUB"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_TRUNC","text":"","title":"FLOAT_TRUNC"},{"location":"reference/#ghidralib.PcodeOp.INDIRECT","text":"","title":"INDIRECT"},{"location":"reference/#ghidralib.PcodeOp.INSERT","text":"","title":"INSERT"},{"location":"reference/#ghidralib.PcodeOp.INT_2COMP","text":"","title":"INT_2COMP"},{"location":"reference/#ghidralib.PcodeOp.INT_ADD","text":"","title":"INT_ADD"},{"location":"reference/#ghidralib.PcodeOp.INT_AND","text":"","title":"INT_AND"},{"location":"reference/#ghidralib.PcodeOp.INT_CARRY","text":"","title":"INT_CARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_DIV","text":"","title":"INT_DIV"},{"location":"reference/#ghidralib.PcodeOp.INT_EQUAL","text":"","title":"INT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_LEFT","text":"","title":"INT_LEFT"},{"location":"reference/#ghidralib.PcodeOp.INT_LESS","text":"","title":"INT_LESS"},{"location":"reference/#ghidralib.PcodeOp.INT_LESSEQUAL","text":"","title":"INT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_MULT","text":"","title":"INT_MULT"},{"location":"reference/#ghidralib.PcodeOp.INT_NEGATE","text":"","title":"INT_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.INT_NOTEQUAL","text":"","title":"INT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_OR","text":"","title":"INT_OR"},{"location":"reference/#ghidralib.PcodeOp.INT_REM","text":"","title":"INT_REM"},{"location":"reference/#ghidralib.PcodeOp.INT_RIGHT","text":"","title":"INT_RIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SBORROW","text":"","title":"INT_SBORROW"},{"location":"reference/#ghidralib.PcodeOp.INT_SCARRY","text":"","title":"INT_SCARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_SDIV","text":"","title":"INT_SDIV"},{"location":"reference/#ghidralib.PcodeOp.INT_SEXT","text":"","title":"INT_SEXT"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESS","text":"","title":"INT_SLESS"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESSEQUAL","text":"","title":"INT_SLESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_SREM","text":"","title":"INT_SREM"},{"location":"reference/#ghidralib.PcodeOp.INT_SRIGHT","text":"","title":"INT_SRIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SUB","text":"","title":"INT_SUB"},{"location":"reference/#ghidralib.PcodeOp.INT_XOR","text":"","title":"INT_XOR"},{"location":"reference/#ghidralib.PcodeOp.INT_ZEXT","text":"","title":"INT_ZEXT"},{"location":"reference/#ghidralib.PcodeOp.LOAD","text":"","title":"LOAD"},{"location":"reference/#ghidralib.PcodeOp.LZCOUNT","text":"","title":"LZCOUNT"},{"location":"reference/#ghidralib.PcodeOp.MULTIEQUAL","text":"","title":"MULTIEQUAL"},{"location":"reference/#ghidralib.PcodeOp.NEW","text":"","title":"NEW"},{"location":"reference/#ghidralib.PcodeOp.PCODE_MAX","text":"","title":"PCODE_MAX"},{"location":"reference/#ghidralib.PcodeOp.PIECE","text":"","title":"PIECE"},{"location":"reference/#ghidralib.PcodeOp.POPCOUNT","text":"","title":"POPCOUNT"},{"location":"reference/#ghidralib.PcodeOp.PTRADD","text":"","title":"PTRADD"},{"location":"reference/#ghidralib.PcodeOp.PTRSUB","text":"","title":"PTRSUB"},{"location":"reference/#ghidralib.PcodeOp.RETURN","text":"","title":"RETURN"},{"location":"reference/#ghidralib.PcodeOp.SEGMENTOP","text":"","title":"SEGMENTOP"},{"location":"reference/#ghidralib.PcodeOp.STORE","text":"","title":"STORE"},{"location":"reference/#ghidralib.PcodeOp.SUBPIECE","text":"","title":"SUBPIECE"},{"location":"reference/#ghidralib.PcodeOp.UNIMPLEMENTED","text":"","title":"UNIMPLEMENTED"},{"location":"reference/#ghidralib.PcodeOp.address","text":"Get an address in the program where this instruction is located","title":"address"},{"location":"reference/#ghidralib.PcodeOp.inputs","text":"","title":"inputs"},{"location":"reference/#ghidralib.PcodeOp.inputs_simple","text":"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).","title":"inputs_simple"},{"location":"reference/#ghidralib.PcodeOp.mnemonic","text":"Get a string representation of the operation, for example \"COPY\"","title":"mnemonic"},{"location":"reference/#ghidralib.PcodeOp.opcode","text":"","title":"opcode"},{"location":"reference/#ghidralib.PcodeOp.output","text":"","title":"output"},{"location":"reference/#ghidralib.PcodeOp.result","text":"Try to evaluate the pcode operation to a constant value. Right now this is very poor and doesn't try to implement most of the opcodes. Mostly because I suspect I'm reinventing the wheel, and there is code to do this already in Ghidra. Returns: \u2013 Result of this operation, or None if can't be evaluated as const.","title":"result"},{"location":"reference/#ghidralib.PcodeOp.get_high_pcode_at","text":"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py @staticmethod def get_high_pcode_at(address): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function(address).get_high_pcode_at(address)","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.Program","text":"Bases: GhidraWrapper A static class that represents the current program Source code in ghidralib.py class Program(GhidraWrapper): \"\"\"A static class that represents the current program\"\"\" @staticmethod def create_data(address, datatype): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType(datatype) addr = resolve(address) try: createData(addr, unwrap(typeobj)) except: clearListing(addr, addr.add(len(typeobj) - 1)) createData(addr, unwrap(typeobj)) @staticmethod def location(): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return getState().getCurrentLocation().getAddress().getOffset() @staticmethod def call_graph(): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" return Graph.construct(Function.all(), lambda f: f.called) @staticmethod def control_flow(): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" return Graph.construct(BasicBlock.all(), lambda b: b.destinations) @staticmethod def basicblocks(): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock.all() @staticmethod def memory_blocks(): # type: () -> list[MemoryBlock] \"\"\"Get memory blocks defined for the current program.\"\"\" return MemoryBlock.all() @staticmethod def functions(): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function.all() @staticmethod def instructions(): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction.all() @staticmethod def body(): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program.current().getNamespaceManager().getGlobalNamespace().getBody() return AddressSet(body) @staticmethod def current(): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram() @staticmethod def analyze(): # type: () -> None \"\"\"Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script.\"\"\" analyzeChanges(Program.current())","title":"Program"},{"location":"reference/#ghidralib.Program.analyze","text":"Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script. Source code in ghidralib.py @staticmethod def analyze(): # type: () -> None \"\"\"Analyze changes. This will block when autoanalysis changes place. Run this when you did changes that you will need to proceed with the rest of the script.\"\"\" analyzeChanges(Program.current())","title":"analyze"},{"location":"reference/#ghidralib.Program.basicblocks","text":"Get all the basic blocks defined in the program. Source code in ghidralib.py @staticmethod def basicblocks(): # type: () -> list[BasicBlock] \"\"\"Get all the basic blocks defined in the program.\"\"\" return BasicBlock.all()","title":"basicblocks"},{"location":"reference/#ghidralib.Program.body","text":"Get the set of all addresses of the program. Source code in ghidralib.py @staticmethod def body(): # type: () -> AddressSet \"\"\"Get the set of all addresses of the program.\"\"\" body = Program.current().getNamespaceManager().getGlobalNamespace().getBody() return AddressSet(body)","title":"body"},{"location":"reference/#ghidralib.Program.call_graph","text":"Get the call graph for this program. Source code in ghidralib.py @staticmethod def call_graph(): # type: () -> Graph[Function] \"\"\"Get the call graph for this program.\"\"\" return Graph.construct(Function.all(), lambda f: f.called)","title":"call_graph"},{"location":"reference/#ghidralib.Program.control_flow","text":"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it. Source code in ghidralib.py @staticmethod def control_flow(): # type: () -> Graph[BasicBlock] \"\"\"Get a graph representing the whole program control flow. Warning: This graph may be big, so don't try to display it.\"\"\" return Graph.construct(BasicBlock.all(), lambda b: b.destinations)","title":"control_flow"},{"location":"reference/#ghidralib.Program.create_data","text":"Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py @staticmethod def create_data(address, datatype): # type: (Addr, DataT) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" typeobj = DataType(datatype) addr = resolve(address) try: createData(addr, unwrap(typeobj)) except: clearListing(addr, addr.add(len(typeobj) - 1)) createData(addr, unwrap(typeobj))","title":"create_data"},{"location":"reference/#ghidralib.Program.current","text":"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool). Source code in ghidralib.py @staticmethod def current(): # type: () -> JavaObject \"\"\"Get the current program. Equivalent to getCurrentProgram() This method must be used instead of currentProgram, because the latter won't work well if user is using multiple programs at the same time (for example, many tabs in the same tool).\"\"\" return getCurrentProgram()","title":"current"},{"location":"reference/#ghidralib.Program.functions","text":"Get all the functions defined in the program. Source code in ghidralib.py @staticmethod def functions(): # type: () -> list[Function] \"\"\"Get all the functions defined in the program.\"\"\" return Function.all()","title":"functions"},{"location":"reference/#ghidralib.Program.instructions","text":"Get all the instructions defined in the program. Source code in ghidralib.py @staticmethod def instructions(): # type: () -> list[Instruction] \"\"\"Get all the instructions defined in the program.\"\"\" return Instruction.all()","title":"instructions"},{"location":"reference/#ghidralib.Program.location","text":"Get the current location in the program. >>> current_location() 0x1000 Returns: \u2013 the current location in the program Source code in ghidralib.py @staticmethod def location(): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 :return: the current location in the program \"\"\" return getState().getCurrentLocation().getAddress().getOffset()","title":"location"},{"location":"reference/#ghidralib.Program.memory_blocks","text":"Get memory blocks defined for the current program. Source code in ghidralib.py @staticmethod def memory_blocks(): # type: () -> list[MemoryBlock] \"\"\"Get memory blocks defined for the current program.\"\"\" return MemoryBlock.all()","title":"memory_blocks"},{"location":"reference/#ghidralib.RefType","text":"Bases: GhidraWrapper Source code in ghidralib.py class RefType(GhidraWrapper): @property def has_fallthrough(self): # type: () -> bool return self.raw.hasFallthrough() @has_fallthrough.setter def has_fallthrough(self, value): # type: (bool) -> None self.raw.setHasFall(value) @property def is_call(self): # type: () -> bool return self.raw.isCall() @is_call.setter def is_call(self, value): # type: (bool) -> None self.raw.setIsCall(value) @property def is_jump(self): # type: () -> bool return self.raw.isJump() @is_jump.setter def is_jump(self, value): # type: (bool) -> None self.raw.setIsJump(value) @property def is_computed(self): # type: () -> bool return self.raw.isComputed() @is_computed.setter def is_computed(self, value): # type: (bool) -> None self.raw.setIsComputed(value) @property def is_conditional(self): # type: () -> bool return self.raw.isConditional() @is_conditional.setter def is_conditional(self, value): # type: (bool) -> None self.raw.setIsConditional(value) @property def is_unconditional(self): # type: () -> bool return not self.is_conditional @property def is_terminal(self): # type: () -> bool return self.raw.isTerminal() @property def is_data(self): # type: () -> bool return self.raw.isData() @property def is_read(self): # type: () -> bool return self.raw.isRead() @property def is_write(self): # type: () -> bool return self.raw.isWrite() @property def is_flow(self): # type: () -> bool return self.raw.isFlow() @property def is_override(self): # type: () -> bool return self.raw.isOverride() INVALID = _reftype_placeholder() FLOW = _reftype_placeholder() FALL_THROUGH = _reftype_placeholder() UNCONDITIONAL_JUMP = _reftype_placeholder() CONDITIONAL_JUMP = _reftype_placeholder() UNCONDITIONAL_CALL = _reftype_placeholder() CONDITIONAL_CALL = _reftype_placeholder() TERMINATOR = _reftype_placeholder() COMPUTED_JUMP = _reftype_placeholder() CONDITIONAL_TERMINATOR = _reftype_placeholder() COMPUTED_CALL = _reftype_placeholder() CALL_TERMINATOR = _reftype_placeholder() COMPUTED_CALL_TERMINATOR = _reftype_placeholder() CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder() CONDITIONAL_COMPUTED_CALL = _reftype_placeholder() CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder() JUMP_TERMINATOR = _reftype_placeholder() INDIRECTION = _reftype_placeholder() CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder() CALLOTHER_OVERRIDE_CALL = _reftype_placeholder() CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder()","title":"RefType"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_CALL","text":"","title":"CALLOTHER_OVERRIDE_CALL"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP","text":"","title":"CALLOTHER_OVERRIDE_JUMP"},{"location":"reference/#ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL","text":"","title":"CALL_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.CALL_TERMINATOR","text":"","title":"CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL","text":"","title":"COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL_TERMINATOR","text":"","title":"COMPUTED_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_JUMP","text":"","title":"COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL","text":"","title":"CONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR","text":"","title":"CONDITIONAL_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_CALL","text":"","title":"CONDITIONAL_COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP","text":"","title":"CONDITIONAL_COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_JUMP","text":"","title":"CONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_TERMINATOR","text":"","title":"CONDITIONAL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.FALL_THROUGH","text":"","title":"FALL_THROUGH"},{"location":"reference/#ghidralib.RefType.FLOW","text":"","title":"FLOW"},{"location":"reference/#ghidralib.RefType.INDIRECTION","text":"","title":"INDIRECTION"},{"location":"reference/#ghidralib.RefType.INVALID","text":"","title":"INVALID"},{"location":"reference/#ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL","text":"","title":"JUMP_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.JUMP_TERMINATOR","text":"","title":"JUMP_TERMINATOR"},{"location":"reference/#ghidralib.RefType.TERMINATOR","text":"","title":"TERMINATOR"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_CALL","text":"","title":"UNCONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_JUMP","text":"","title":"UNCONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.has_fallthrough","text":"","title":"has_fallthrough"},{"location":"reference/#ghidralib.RefType.is_call","text":"","title":"is_call"},{"location":"reference/#ghidralib.RefType.is_computed","text":"","title":"is_computed"},{"location":"reference/#ghidralib.RefType.is_conditional","text":"","title":"is_conditional"},{"location":"reference/#ghidralib.RefType.is_data","text":"","title":"is_data"},{"location":"reference/#ghidralib.RefType.is_flow","text":"","title":"is_flow"},{"location":"reference/#ghidralib.RefType.is_jump","text":"","title":"is_jump"},{"location":"reference/#ghidralib.RefType.is_override","text":"","title":"is_override"},{"location":"reference/#ghidralib.RefType.is_read","text":"","title":"is_read"},{"location":"reference/#ghidralib.RefType.is_terminal","text":"","title":"is_terminal"},{"location":"reference/#ghidralib.RefType.is_unconditional","text":"","title":"is_unconditional"},{"location":"reference/#ghidralib.RefType.is_write","text":"","title":"is_write"},{"location":"reference/#ghidralib.Reference","text":"Bases: GhidraWrapper Source code in ghidralib.py class Reference(GhidraWrapper): @property def is_call(self): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self.reftype.is_call @property def is_jump(self): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self.reftype.is_jump @property def reftype(self): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType(self.raw.getReferenceType()) @property def from_address(self): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self.raw.getFromAddress().getOffset() @property def to_address(self): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self.raw.getToAddress().getOffset() @property def source(self): # type: () -> SourceType return SourceType(self.raw.getSource())","title":"Reference"},{"location":"reference/#ghidralib.Reference.from_address","text":"Return the address of the source of the reference.","title":"from_address"},{"location":"reference/#ghidralib.Reference.is_call","text":"Return True if the reference is a call.","title":"is_call"},{"location":"reference/#ghidralib.Reference.is_jump","text":"Return True if the reference is a jump.","title":"is_jump"},{"location":"reference/#ghidralib.Reference.reftype","text":"Return the type of reference.","title":"reftype"},{"location":"reference/#ghidralib.Reference.source","text":"","title":"source"},{"location":"reference/#ghidralib.Reference.to_address","text":"Return the address of the target of the reference.","title":"to_address"},{"location":"reference/#ghidralib.Register","text":"Bases: GhidraWrapper Source code in ghidralib.py class Register(GhidraWrapper): @staticmethod def get(raw_or_name): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance(raw_or_name, Str): raw_or_name = Program.current().getLanguage().getRegister(raw_or_name) if raw_or_name is None: return None return Register(raw_or_name) @property def name(self): # type: () -> str \"\"\"Return the name of this register\"\"\" return self.raw.getName() @property def size(self): # type: () -> int \"\"\"Return the size of this register in bytes This will tell the total number of bytes this register contains - because register values don't have to be byte-aligned\"\"\" return self.raw.getNumBytes() @property def varnode(self): # type: () -> Varnode \"\"\"Return the varnode associated with this register Warning: this doesn't support registers that are not byte-aligned (for example, flag registers). It will round the address down to byte. \"\"\" raw = GhVarnode(self.raw.getAddress(), self.raw.getNumBytes()) return Varnode(raw)","title":"Register"},{"location":"reference/#ghidralib.Register.name","text":"Return the name of this register","title":"name"},{"location":"reference/#ghidralib.Register.size","text":"Return the size of this register in bytes This will tell the total number of bytes this register contains - because register values don't have to be byte-aligned","title":"size"},{"location":"reference/#ghidralib.Register.varnode","text":"Return the varnode associated with this register Warning: this doesn't support registers that are not byte-aligned (for example, flag registers). It will round the address down to byte.","title":"varnode"},{"location":"reference/#ghidralib.Register.get","text":"Get a register by name Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (str|JavaObject) -> Register|None \"\"\"Get a register by name\"\"\" if isinstance(raw_or_name, Str): raw_or_name = Program.current().getLanguage().getRegister(raw_or_name) if raw_or_name is None: return None return Register(raw_or_name)","title":"get"},{"location":"reference/#ghidralib.Symbol","text":"Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py class Symbol(GhidraWrapper): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def resolve_thunk_if_exists(external_symbol): # type: (JavaObject) -> JavaObject \"\"\"Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls `printf` it jumps to the appropriate `printf` thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. :param external_symbol: Symbol to find thunk for (if it exists). \"\"\" xrefs = list(external_symbol.getReferences()) for xref in xrefs: if xref.getReferenceType() == GhRefType.THUNK: addr = xref.getFromAddress() thunk = Program.current().getSymbolTable().getPrimarySymbol(addr) if thunk is not None: return thunk return external_symbol @staticmethod def resolve_external(external_symbol): # type: (JavaObject) -> int \"\"\"Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. :param external_symbol: External symbol to resolve.\"\"\" external_manager = Program.current().getExternalManager() ram_addr = external_manager.getExternalLocation(external_symbol).getAddress() if ram_addr: return ram_addr.getOffset() return external_symbol.getAddress().getOffset() @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance(raw_or_name, str): symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name) symbols = collect_iterator(symbol_iterator) if not symbols: return None raw = symbols[0] if raw.isExternal(): raw = Symbol.resolve_thunk_if_exists(raw) elif can_resolve(raw_or_name): raw = ( Program.current() .getSymbolTable() .getPrimarySymbol(resolve(raw_or_name)) ) if not raw: return None else: raw = raw_or_name return Symbol(raw) @staticmethod def all(): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True) symbols = collect_iterator(symbol_iterator) return [Symbol(s) for s in symbols] @staticmethod def create( address, name, source=SourceType.USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel(resolve(address), name, False, source) return Symbol(raw) @staticmethod def remove(address, name): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol(resolve(address), name) @property def address(self): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" if self.is_external: return Symbol.resolve_external(self.raw) return self.raw.getAddress().getOffset() @property def name(self): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self.raw.getName() @property def name_with_namespace(self): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self.raw.getName(True) @property def xrefs(self): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [Reference(raw) for raw in self.raw.getReferences()] xrefs_to = xrefs @property def xref_addrs(self): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [xref.from_address for xref in self.xrefs] def set_type(self, datatype): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program.create_data(self.address, datatype) def delete(self): # type: () -> None \"\"\"Delete this symbol.\"\"\" self.raw.delete() def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self.raw.setName(new_name, source) @property def is_external(self): # type: () -> bool \"\"\"Return true if this symbol is external, otherwise false. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :return: true if the symbol is external\"\"\" return self.raw.isExternal()","title":"Symbol"},{"location":"reference/#ghidralib.Symbol.address","text":"Get the address of this symbol.","title":"address"},{"location":"reference/#ghidralib.Symbol.is_external","text":"Return true if this symbol is external, otherwise false. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). Returns: \u2013 true if the symbol is external","title":"is_external"},{"location":"reference/#ghidralib.Symbol.name","text":"Get the name of this symbol.","title":"name"},{"location":"reference/#ghidralib.Symbol.name_with_namespace","text":"Get the fully qualified name of this symbol.","title":"name_with_namespace"},{"location":"reference/#ghidralib.Symbol.xref_addrs","text":"Get the addresses of all references to this symbol.","title":"xref_addrs"},{"location":"reference/#ghidralib.Symbol.xrefs","text":"Get a list of references to this symbol.","title":"xrefs"},{"location":"reference/#ghidralib.Symbol.xrefs_to","text":"","title":"xrefs_to"},{"location":"reference/#ghidralib.Symbol.all","text":"Get all symbols defined in the program. Source code in ghidralib.py @staticmethod def all(): # type: () -> list[Symbol] \"\"\"Get all symbols defined in the program.\"\"\" symbol_iterator = Program.current().getSymbolTable().getAllSymbols(True) symbols = collect_iterator(symbol_iterator) return [Symbol(s) for s in symbols]","title":"all"},{"location":"reference/#ghidralib.Symbol.create","text":"Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py @staticmethod def create( address, name, source=SourceType.USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel(resolve(address), name, False, source) return Symbol(raw)","title":"create"},{"location":"reference/#ghidralib.Symbol.delete","text":"Delete this symbol. Source code in ghidralib.py def delete(self): # type: () -> None \"\"\"Delete this symbol.\"\"\" self.raw.delete()","title":"delete"},{"location":"reference/#ghidralib.Symbol.get","text":"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py @staticmethod def get(raw_or_name): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Note: when resolving by name, local symbols take precedence over external ones (in particular for function thunks - in contrast to Ghidra default behaviour). :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance(raw_or_name, str): symbol_iterator = Program.current().getSymbolTable().getSymbols(raw_or_name) symbols = collect_iterator(symbol_iterator) if not symbols: return None raw = symbols[0] if raw.isExternal(): raw = Symbol.resolve_thunk_if_exists(raw) elif can_resolve(raw_or_name): raw = ( Program.current() .getSymbolTable() .getPrimarySymbol(resolve(raw_or_name)) ) if not raw: return None else: raw = raw_or_name return Symbol(raw)","title":"get"},{"location":"reference/#ghidralib.Symbol.remove","text":"Remove the symbol with the given name at the given address. Parameters: address \u2013 the address of the symbol to remove. name \u2013 the name of the symbol to remove. Source code in ghidralib.py @staticmethod def remove(address, name): # type: (Addr, str) -> None \"\"\"Remove the symbol with the given name at the given address. :param address: the address of the symbol to remove. :param name: the name of the symbol to remove.\"\"\" removeSymbol(resolve(address), name)","title":"remove"},{"location":"reference/#ghidralib.Symbol.rename","text":"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py def rename( self, new_name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self.raw.setName(new_name, source)","title":"rename"},{"location":"reference/#ghidralib.Symbol.resolve_external","text":"Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. Parameters: external_symbol \u2013 External symbol to resolve. Source code in ghidralib.py @staticmethod def resolve_external(external_symbol): # type: (JavaObject) -> int \"\"\"Resolves an external address to a RAM location, if possible. If the symbol has no RAM location, just return its offset. Why is this ugly thing here? Again, we want to support external symbols, and we are interested in their RAM address in the program address space. In some cases, Ghidra will give an external address a \"location\" in the RAM space. So, for example, if current program jumps to that external function (or read that external variable etc), it will read that location as far as Ghidra is concerned (for example, Emulator will use it for calls). This is important for emulating Windows binaries, that use address tables for imports. :param external_symbol: External symbol to resolve.\"\"\" external_manager = Program.current().getExternalManager() ram_addr = external_manager.getExternalLocation(external_symbol).getAddress() if ram_addr: return ram_addr.getOffset() return external_symbol.getAddress().getOffset()","title":"resolve_external"},{"location":"reference/#ghidralib.Symbol.resolve_thunk_if_exists","text":"Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls printf it jumps to the appropriate printf thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. Parameters: external_symbol \u2013 Symbol to find thunk for (if it exists). Source code in ghidralib.py @staticmethod def resolve_thunk_if_exists(external_symbol): # type: (JavaObject) -> JavaObject \"\"\"Returns a function thunk leading to a passed external symbol, if it exists. If there is no function thunk, original symbol is returned. Why is this ugly thing here? Well, we want to support external symbols, especially external functions. Thunks are much more useful for us when thinking in context of the analysed program - when Linux program calls `printf` it jumps to the appropriate `printf` thunk, not to libc directly. So this is the location that we want to patch/hook/trace/etc when thinking about printf. But the thing is that Ghidra SymbolTable API will not even return thunks! So we trace the external function references, and return the first (almost certainly only) Thunk reference. :param external_symbol: Symbol to find thunk for (if it exists). \"\"\" xrefs = list(external_symbol.getReferences()) for xref in xrefs: if xref.getReferenceType() == GhRefType.THUNK: addr = xref.getFromAddress() thunk = Program.current().getSymbolTable().getPrimarySymbol(addr) if thunk is not None: return thunk return external_symbol","title":"resolve_thunk_if_exists"},{"location":"reference/#ghidralib.Symbol.set_type","text":"Set the data type of this symbol. Source code in ghidralib.py def set_type(self, datatype): # type: (DataT) -> None \"\"\"Set the data type of this symbol.\"\"\" Program.create_data(self.address, datatype)","title":"set_type"},{"location":"reference/#ghidralib.SymbolicPropogator","text":"Bases: GhidraWrapper Wraps SymbolicPropogator. Can be used to get known values at various locations in a given function (or outside of a function) Source code in ghidralib.py class SymbolicPropogator(GhidraWrapper): \"\"\"Wraps SymbolicPropogator. Can be used to get known values at various locations in a given function (or outside of a function)\"\"\" @staticmethod def create(): return SymbolicPropogator(GhSymbolicPropogator(Program.current())) def flow_constants( self, addr, body, evaluator ): # type: (Addr, AddressSet, JavaObject) -> None \"\"\"Flow constants from the given address in the given body :param addr: The address to start from :param body: The body where constants should be propagated :param evaluator: The evaluator to use for the propagation\"\"\" addr = resolve(addr) self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor()) def register_at(self, addr, register): # type: (Addr, Reg) -> int|None \"\"\"Get a known register value at the given address (or None) Warning: this value is signed. :param addr: The address to get a register value at :param register: The register to get a value for :return: The value of the register at the given address, or None if the register is not known at that address\"\"\" addr = resolve(addr) reg = Register(register) value = self.raw.getRegisterValue(addr, reg.raw) if not value or value.isRegisterRelativeValue(): # This never happens in my tests, so I just won't handle register-relative # values. I don't know when this can ever happen. return None return value.value","title":"SymbolicPropogator"},{"location":"reference/#ghidralib.SymbolicPropogator.create","text":"Source code in ghidralib.py @staticmethod def create(): return SymbolicPropogator(GhSymbolicPropogator(Program.current()))","title":"create"},{"location":"reference/#ghidralib.SymbolicPropogator.flow_constants","text":"Flow constants from the given address in the given body Parameters: addr \u2013 The address to start from body \u2013 The body where constants should be propagated evaluator \u2013 The evaluator to use for the propagation Source code in ghidralib.py def flow_constants( self, addr, body, evaluator ): # type: (Addr, AddressSet, JavaObject) -> None \"\"\"Flow constants from the given address in the given body :param addr: The address to start from :param body: The body where constants should be propagated :param evaluator: The evaluator to use for the propagation\"\"\" addr = resolve(addr) self.raw.flowConstants(addr, body.raw, evaluator, False, getMonitor())","title":"flow_constants"},{"location":"reference/#ghidralib.SymbolicPropogator.register_at","text":"Get a known register value at the given address (or None) Warning: this value is signed. Parameters: addr \u2013 The address to get a register value at register \u2013 The register to get a value for Returns: \u2013 The value of the register at the given address, or None if the register is not known at that address Source code in ghidralib.py def register_at(self, addr, register): # type: (Addr, Reg) -> int|None \"\"\"Get a known register value at the given address (or None) Warning: this value is signed. :param addr: The address to get a register value at :param register: The register to get a value for :return: The value of the register at the given address, or None if the register is not known at that address\"\"\" addr = resolve(addr) reg = Register(register) value = self.raw.getRegisterValue(addr, reg.raw) if not value or value.isRegisterRelativeValue(): # This never happens in my tests, so I just won't handle register-relative # values. I don't know when this can ever happen. return None return value.value","title":"register_at"},{"location":"reference/#ghidralib.Variable","text":"Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py class Variable(GhidraWrapper): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name(self): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self.raw.getName() @name.setter def name(self, name): # type: (str) -> None \"\"\"Rename this variable\"\"\" self.rename(name, SourceType.USER_DEFINED) def rename( self, name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self.raw.setName(name, source) @property def data_type(self): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType(self.raw.getDataType()) @data_type.setter def data_type( self, data_type, source=SourceType.USER_DEFINED ): # type: (DataType, SourceType) -> None \"\"\"Set the data type of this variable\"\"\" self.raw.setDataType(data_type.raw, source) @property def is_valid(self): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self.raw.isValid() @property def comment(self): # type: () -> str|None \"\"\" \"Get the comment for this variable\"\"\" return self.raw.getComment() @comment.setter def comment(self, name): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.set_comment(name) def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.raw.setComment(comment) @property def is_auto(self): # type: () -> bool \"\"\"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.\"\"\" return self.raw.getVariableStorage().isAutoStorage() @property def is_forced_indirect(self): # type: () -> bool \"\"\"Check if this variable was forced to be a pointer by calling convention\"\"\" return self.raw.getVariableStorage().isForcedIndirect() @property def has_bad_storage(self): # type: () -> bool \"\"\"Check if this variable has bad storage (could not be resolved)\"\"\" return self.raw.getVariableStorage().isBadStorage() @property def is_unassigned_storage(self): # type: () -> bool \"\"\"Check if this variable has no assigned storage (varnodes)\"\"\" return self.raw.getVariableStorage().isUnassignedStorage() @property def is_void(self): # type: () -> bool \"\"\"Check if this variable is of type void\"\"\" return self.raw.getVariableStorage().isVoidStorage() @property def stack_offfset(self): # type: () -> int \"\"\"Get the stack offset of this variable.\"\"\" return self.raw.getVariableStorage().getStackOffset() @property def is_constant(self): # type: () -> bool \"\"\"Check if this variable consists of a single constant-space varnode\"\"\" return self.raw.getVariableStorage().isConstantStorage() @property def is_hash(self): # type: () -> bool \"\"\"Check if this variable consists of a single hash-space varnode.\"\"\" return self.raw.getVariableStorage().isHashStorage() @property def is_stack(self): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self.raw.isStackVariable() @property def is_memory(self): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self.raw.isMemoryVariable() @property def is_unique(self): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self.raw.isUniqueVariable() @property def is_compound(self): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self.raw.isCompoundVariable() @property def symbol(self): # type: () -> Symbol \"\"\"Get the symbol for this variable\"\"\" return Symbol(self.raw.getSymbol()) @property def source(self): # type: () -> SourceType \"\"\"Get the source type of this variable\"\"\" return SourceType(self.raw.getSource()) @property def varnode(self): # type: () -> Varnode \"\"\"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.\"\"\" return Varnode(self.raw.getFirstStorageVarnode()) @property def varnodes(self): # type: () -> list[Varnode] \"\"\"Get all varnodes associated with this variable.\"\"\" storage = self.raw.getVariableStorage() return [Varnode(x) for x in storage.getVarnodes()] @property def is_register(self): # type: () -> bool \"\"\"Check if this variable consists of a single register.\"\"\" return self.raw.isRegisterVariable() @property def register(self): # type: () -> str \"\"\"Get the register associated with this variable. Raises an exception if this variable is not a register variable.\"\"\" reg = self.raw.getRegister() if not reg: raise ValueError(\"Variable is not a register variable\") return reg.getName() @property def function(self): # type: () -> Function \"\"\"Get the function associated with this variable.\"\"\" return Function(self.raw.getFunction())","title":"Variable"},{"location":"reference/#ghidralib.Variable.comment","text":"\"Get the comment for this variable","title":"comment"},{"location":"reference/#ghidralib.Variable.data_type","text":"Get the data type of this variable","title":"data_type"},{"location":"reference/#ghidralib.Variable.function","text":"Get the function associated with this variable.","title":"function"},{"location":"reference/#ghidralib.Variable.has_bad_storage","text":"Check if this variable has bad storage (could not be resolved)","title":"has_bad_storage"},{"location":"reference/#ghidralib.Variable.is_auto","text":"Check if this variable is an automatic parameter. Some parameters are \"hidden parameters\" dictated by the calling convention. This method returns true for such paramteters.","title":"is_auto"},{"location":"reference/#ghidralib.Variable.is_compound","text":"Check if this variable is a compound variable","title":"is_compound"},{"location":"reference/#ghidralib.Variable.is_constant","text":"Check if this variable consists of a single constant-space varnode","title":"is_constant"},{"location":"reference/#ghidralib.Variable.is_forced_indirect","text":"Check if this variable was forced to be a pointer by calling convention","title":"is_forced_indirect"},{"location":"reference/#ghidralib.Variable.is_hash","text":"Check if this variable consists of a single hash-space varnode.","title":"is_hash"},{"location":"reference/#ghidralib.Variable.is_memory","text":"Check if this variable is stored in memory","title":"is_memory"},{"location":"reference/#ghidralib.Variable.is_register","text":"Check if this variable consists of a single register.","title":"is_register"},{"location":"reference/#ghidralib.Variable.is_stack","text":"Check if this variable is a stack variable","title":"is_stack"},{"location":"reference/#ghidralib.Variable.is_unassigned_storage","text":"Check if this variable has no assigned storage (varnodes)","title":"is_unassigned_storage"},{"location":"reference/#ghidralib.Variable.is_unique","text":"Check if this variable is of type unique","title":"is_unique"},{"location":"reference/#ghidralib.Variable.is_valid","text":"Check if this variable is valid","title":"is_valid"},{"location":"reference/#ghidralib.Variable.is_void","text":"Check if this variable is of type void","title":"is_void"},{"location":"reference/#ghidralib.Variable.name","text":"Get the name of this variable","title":"name"},{"location":"reference/#ghidralib.Variable.register","text":"Get the register associated with this variable. Raises an exception if this variable is not a register variable.","title":"register"},{"location":"reference/#ghidralib.Variable.source","text":"Get the source type of this variable","title":"source"},{"location":"reference/#ghidralib.Variable.stack_offfset","text":"Get the stack offset of this variable.","title":"stack_offfset"},{"location":"reference/#ghidralib.Variable.symbol","text":"Get the symbol for this variable","title":"symbol"},{"location":"reference/#ghidralib.Variable.varnode","text":"Get the first varnode associated with this variable. Warning: there may be more than one varnode associated with a variable.","title":"varnode"},{"location":"reference/#ghidralib.Variable.varnodes","text":"Get all varnodes associated with this variable.","title":"varnodes"},{"location":"reference/#ghidralib.Variable.rename","text":"Rename this variable Source code in ghidralib.py def rename( self, name, source=SourceType.USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this variable\"\"\" self.raw.setName(name, source)","title":"rename"},{"location":"reference/#ghidralib.Variable.set_comment","text":"Set the comment for this variable Source code in ghidralib.py def set_comment(self, comment): # type: (str|None) -> None \"\"\"Set the comment for this variable\"\"\" self.raw.setComment(comment)","title":"set_comment"},{"location":"reference/#ghidralib.Varnode","text":"Bases: GhidraWrapper Source code in ghidralib.py class Varnode(GhidraWrapper): @property def has_value(self): # type: () -> bool \"\"\"Return true if this varnode can be converted to a integer value. In particular, this will return true for Address and Constant varnodes\"\"\" return self.value is not None @property def value(self): # type: () -> int|None \"\"\"Get the value of this varnode. Traverse defining pcodeops if necessary.\"\"\" if self.is_address or self.is_constant: return self.offset if self.defining_pcodeop is None: return None return self.defining_pcodeop.result @property def offset(self): # type: () -> int return int(self.raw.getOffset()) @property def size(self): # type: () -> int return self.raw.getSize() @property def high(self): # type: () -> HighVariable return HighVariable(self.raw.getHigh()) @property def symbol(self): # type: () -> HighSymbol return self.high.symbol @property def is_constant(self): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self.raw.isConstant() @property def is_register(self): # type: () -> bool \"\"\"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.\"\"\" return self.raw.isRegister() @property def is_named_register(self): # type: () -> bool \"\"\" \"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.\"\"\" language = Program.current().getLanguage() raw = language.getRegister(self.raw.getAddress(), self.size) return raw is not None @property def as_register(self): # type: () -> str \"\"\"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.\"\"\" language = Program.current().getLanguage() raw = language.getRegister(self.raw.getAddress(), self.size) return raw.getName() @property def is_address(self): # type: () -> bool return self.raw.isAddress() @property def is_unique(self): # type: () -> bool return self.raw.isUnique() @property def is_hash(self): # type: () -> bool return self.raw.isHash() @property def is_stack(self): # type: () -> bool spaceid = self.raw.getSpace() spacetype = AddressSpace.ID_TYPE_MASK & spaceid return spacetype == AddressSpace.TYPE_STACK def rename(self, new_name): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self.symbol.rename(new_name) @property def free(self): # type: () -> Varnode return Varnode(GhVarnode(self.raw.getAddress(), self.raw.getSize())) @property def simple(self): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" value = self.value if value is not None: return value elif self.is_register: if self.is_named_register: return self.as_register return \"reg:{:x}:{:x}\".format(self.offset, self.size) elif self.is_unique: return \"uniq:{:x}:{:x}\".format(self.offset, self.size) elif self.is_hash: return \"hash:{:x}:{:x}\".format(self.offset, self.size) elif self.is_stack: return \"stack:{:x}:{:x}\".format(self.offset, self.size) raise RuntimeError(\"Unknown varnode type\") @property def is_unaffected(self): # type: () -> bool return self.raw.isUnaffected() @property def is_persistent(self): # type: () -> bool return self.raw.isPersistent() @property def is_addr_tied(self): # type: () -> bool return self.raw.isAddrTied() @property def is_input(self): # type: () -> bool return self.raw.isInput() @property def is_free(self): # type: () -> bool return self.raw.isFree() @property def defining_pcodeop(self): # type: () -> PcodeOp|None \"\"\"Return a PcodeOp that defined this varnode\"\"\" raw = self.raw.getDef() if raw is None: return None return PcodeOp(raw) @property def descendants(self): # type: () -> list[PcodeOp] \"\"\"Return a list of all descendants of this varnode\"\"\" if self.raw.getDescendants() is None: return [] return [PcodeOp(x) for x in self.raw.getDescendants()] def intersects(self, other): # type: (Varnode) -> list[PcodeOp] \"\"\"Return true if this varnode intersects other\"\"\" return self.raw.intersects(other.raw)","title":"Varnode"},{"location":"reference/#ghidralib.Varnode.as_register","text":"Return the name of the register this varnode is stored in. Warning: even if is_register returns true, this does not mean you can use this method safely. Use is_named_register to make sure.","title":"as_register"},{"location":"reference/#ghidralib.Varnode.defining_pcodeop","text":"Return a PcodeOp that defined this varnode","title":"defining_pcodeop"},{"location":"reference/#ghidralib.Varnode.descendants","text":"Return a list of all descendants of this varnode","title":"descendants"},{"location":"reference/#ghidralib.Varnode.free","text":"","title":"free"},{"location":"reference/#ghidralib.Varnode.has_value","text":"Return true if this varnode can be converted to a integer value. In particular, this will return true for Address and Constant varnodes","title":"has_value"},{"location":"reference/#ghidralib.Varnode.high","text":"","title":"high"},{"location":"reference/#ghidralib.Varnode.is_addr_tied","text":"","title":"is_addr_tied"},{"location":"reference/#ghidralib.Varnode.is_address","text":"","title":"is_address"},{"location":"reference/#ghidralib.Varnode.is_constant","text":"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.","title":"is_constant"},{"location":"reference/#ghidralib.Varnode.is_free","text":"","title":"is_free"},{"location":"reference/#ghidralib.Varnode.is_hash","text":"","title":"is_hash"},{"location":"reference/#ghidralib.Varnode.is_input","text":"","title":"is_input"},{"location":"reference/#ghidralib.Varnode.is_named_register","text":"\"Return True if this varnode is stored entirely in a named register. \"Named\" in this context means that it has a conventional name, like RAX. Not all register varnodes are named, for example, the upper 32 bits of RAX have no commonly used name.","title":"is_named_register"},{"location":"reference/#ghidralib.Varnode.is_persistent","text":"","title":"is_persistent"},{"location":"reference/#ghidralib.Varnode.is_register","text":"Return True if this varnode is stored entirely in a register. Warning: this does not mean that it can be cast to a register! This may be, for example, upper 32 bits of RAX. Use is_named_register instead.","title":"is_register"},{"location":"reference/#ghidralib.Varnode.is_stack","text":"","title":"is_stack"},{"location":"reference/#ghidralib.Varnode.is_unaffected","text":"","title":"is_unaffected"},{"location":"reference/#ghidralib.Varnode.is_unique","text":"","title":"is_unique"},{"location":"reference/#ghidralib.Varnode.offset","text":"","title":"offset"},{"location":"reference/#ghidralib.Varnode.simple","text":"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.","title":"simple"},{"location":"reference/#ghidralib.Varnode.size","text":"","title":"size"},{"location":"reference/#ghidralib.Varnode.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.Varnode.value","text":"Get the value of this varnode. Traverse defining pcodeops if necessary.","title":"value"},{"location":"reference/#ghidralib.Varnode.intersects","text":"Return true if this varnode intersects other Source code in ghidralib.py def intersects(self, other): # type: (Varnode) -> list[PcodeOp] \"\"\"Return true if this varnode intersects other\"\"\" return self.raw.intersects(other.raw)","title":"intersects"},{"location":"reference/#ghidralib.Varnode.rename","text":"Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py def rename(self, new_name): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self.symbol.rename(new_name)","title":"rename"},{"location":"reference/#ghidralib.unicode","text":"A fake stub class, to keep type-checker relatively happy Source code in ghidralib.py class unicode: \"\"\"A fake stub class, to keep type-checker relatively happy\"\"\" def encode(self): # type: () -> str \"\"\"A fake method, to keep type-checker relatively happy\"\"\" raise NotImplementedError(\"This method should never be called\")","title":"unicode"},{"location":"reference/#ghidralib.unicode.encode","text":"A fake method, to keep type-checker relatively happy Source code in ghidralib.py def encode(self): # type: () -> str \"\"\"A fake method, to keep type-checker relatively happy\"\"\" raise NotImplementedError(\"This method should never be called\")","title":"encode"},{"location":"reference/#ghidralib.assemble","text":"Assemble the given instructions and return them as a list of instructions. Note: Address is important, because instruction meaning may depend on the location. Parameters: address \u2013 the address where the instructious would be written instructions \u2013 a list of instructions, or a single instruction to assemble Returns: \u2013 the newly assembled instructions Source code in ghidralib.py def assemble( instructions, address=0 ): # type: (str|list[str], Addr) -> list[Instruction] \"\"\"Assemble the given instructions and return them as a list of instructions. Note: Address is important, because instruction meaning may depend on the location. :param address: the address where the instructious would be written :param instructions: a list of instructions, or a single instruction to assemble :return: the newly assembled instructions\"\"\" data = assemble_to_bytes(instructions, address) return disassemble_bytes(data, address)","title":"assemble"},{"location":"reference/#ghidralib.assemble_at","text":"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". >>> assemble_at(Function(\"exit\").entrypoint, \"RET\") Parameters: address \u2013 the address where to write the instructions instructions \u2013 a list of instructions, or a single instruction to assemble pad_to \u2013 optionally, pad the code with NOPs to reach this size Returns: \u2013 the newly assembled instructions Source code in ghidralib.py def assemble_at( address, instructions, pad_to=0 ): # type: (Addr, str|list[str], int) -> list[Instruction] \"\"\"Assemble the given instructions and write them at the given address. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". >>> assemble_at(Function(\"exit\").entrypoint, \"RET\") :param address: the address where to write the instructions :param instructions: a list of instructions, or a single instruction to assemble :param pad_to: optionally, pad the code with NOPs to reach this size :return: the newly assembled instructions\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr = resolve(address) asm = Assemblers.getAssembler(Program.current()) result = [Instruction(i) for i in asm.assemble(addr, instructions)] # Append NOPs at the end, if length is shorter than pad_to. # This is purely to make the assembled code look nicer. if result: last = result[-1] end_addr = last.address + last.length code_size = end_addr - addr.getOffset() if pad_to > code_size: asm.assemble(addr.add(code_size), [\"NOP\"] * (pad_to - code_size)) # Do what Ghidra should do automaticaly, and automatically try to disassemble # jump targets from the newly assembled instructions for instr in result: for xref in instr.xrefs_from: if xref.is_call or xref.is_jump: disassemble(toAddr(xref.to_address)) return result","title":"assemble_at"},{"location":"reference/#ghidralib.assemble_to_bytes","text":"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is important, because instruction bytes may depend on the location. >>> assemble_to_bytes(\"ADD EAX, EAX\") \"\u0001\u00c0\" >>> assemble_to_bytes([\"ADD EAX, EAX\", \"ADD EAX, EAX\"]) \"\u0001\u00c0\u0001\u00c0\" Parameters: address \u2013 the address to use as a base for instructions instructions \u2013 a list of instructions, or a single instruction to assemble Source code in ghidralib.py def assemble_to_bytes(instructions, address=0): # type: (str|list[str], Addr) -> bytes \"\"\"Assemble the given instructions and return them as an array of bytes. Note: Ghidra is a bit picky, and case-sensitive when it comes to opcodes. For example, use \"MOV EAX, EBX\" instead of \"mov eax, ebx\". Note: Address is important, because instruction bytes may depend on the location. >>> assemble_to_bytes(\"ADD EAX, EAX\") \"\\x01\\xc0\" >>> assemble_to_bytes([\"ADD EAX, EAX\", \"ADD EAX, EAX\"]) \"\\x01\\xc0\\x01\\xc0\" :param address: the address to use as a base for instructions :param instructions: a list of instructions, or a single instruction to assemble\"\"\" # Note: Assembler API is actually quite user-friendly and doesn't require # wrapping. But let's wrap it for consistency. addr_obj = resolve(address) asm = Assemblers.getAssembler(Program.current()) if isinstance(instructions, Str): return _bytes_from_bytelist(asm.assembleLine(addr_obj, instructions)) result = _asbytes(\"\") for instr in instructions: result += _bytes_from_bytelist( asm.assembleLine(addr_obj.add(len(result)), instr) ) return result","title":"assemble_to_bytes"},{"location":"reference/#ghidralib.can_resolve","text":"Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py def can_resolve(addr): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance(addr, (GenericAddress, int, long, unicode, str))","title":"can_resolve"},{"location":"reference/#ghidralib.collect_iterator","text":"Collect a Java iterator to a Python list. Source code in ghidralib.py def collect_iterator(iterator): # type: (JavaObject) -> list \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator.hasNext(): result.append(iterator.next()) return result","title":"collect_iterator"},{"location":"reference/#ghidralib.disassemble_at","text":"Disassemble the bytes from the program memory at the given address. If neither max_bytes nor max_instr are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. >>> disassemble_at(0x0403ED0) [INC ESI] Parameters: address \u2013 the address where to start disassembling max_bytes \u2013 maximum number of bytes to disassemble (None for no limit) max_instr \u2013 maximum number of instructions to disassemble (None for no limit) Returns: \u2013 a list of Instruction objects Source code in ghidralib.py def disassemble_at( address, max_instr=None, max_bytes=None ): # type: (Addr, int|None, int|None) -> list[Instruction] \"\"\"Disassemble the bytes from the program memory at the given address. If neither `max_bytes` nor `max_instr` are specified, this function will disassemble one instruction. If at least one of them is specified, this function will disassemble until one of the conditions occurs. >>> disassemble_at(0x0403ED0) [INC ESI] :param address: the address where to start disassembling :param max_bytes: maximum number of bytes to disassemble (None for no limit) :param max_instr: maximum number of instructions to disassemble (None for no limit) :return: a list of Instruction objects\"\"\" addr = resolve(address) if max_instr is None: _max_instr = 1 if max_bytes is None else max_bytes else: _max_instr = max_instr if max_bytes is None: to_block_end = MemoryBlock(addr).end - addr.getOffset() # Hacky and inefficient, but good enough for now (and correct) _max_bytes = min(to_block_end, _max_instr * 16) else: _max_bytes = max_bytes data = read_bytes(addr, _max_bytes) return disassemble_bytes(data, addr, _max_instr)","title":"disassemble_at"},{"location":"reference/#ghidralib.disassemble_bytes","text":"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. >>> disassemble_bytes('F') [INC ESI] Note: Address is important, because instruction meaning may depend on the location. Parameters: data \u2013 the bytes to disassemble addr \u2013 the (virtual) address of the first instruction max_instr \u2013 the maximum number of instructions to disassemble, or to disassemble until the end of the data Returns: \u2013 a list of Instruction objects Source code in ghidralib.py def disassemble_bytes( data, addr=0, max_instr=None ): # type: (bytes, Addr, int|None) -> list[Instruction] \"\"\"Disassemble the given bytes and return a list of Instructions. This function will return early if an exception during disassembly occurs. >>> disassemble_bytes('F') [INC ESI] Note: Address is important, because instruction meaning may depend on the location. :param data: the bytes to disassemble :param addr: the (virtual) address of the first instruction :param max_instr: the maximum number of instructions to disassemble, or to disassemble until the end of the data :return: a list of Instruction objects\"\"\" dis = PseudoDisassembler(Program.current()) offset = 0 result = [] address = resolve(addr) if max_instr is None: max_instr = 100000000 for _ in range(0, max_instr): try: arr = data[offset : offset + 16] rawinstr = dis.disassemble(address.add(offset), arr) instr = Instruction(rawinstr) if offset + instr.length > len(data): break result.append(instr) offset += instr.length if offset + instr.length == len(data): break except: break return result","title":"disassemble_bytes"},{"location":"reference/#ghidralib.enhex","text":"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py def enhex(s): # type: (bytes | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if not isinstance(s, Str): return _enhex(_asbytes(\"\".join(chr(c) for c in s))) return _enhex(s)","title":"enhex"},{"location":"reference/#ghidralib.findall_pattern","text":"Find all occurrences of a byte pattern in the program. >>> findall_pattern(\"01 02 ?? 04\") [0x1000, 0x1004] Parameters: byte_pattern \u2013 the pattern string. Returns: \u2013 iterator over all addresses of all occurrences. Source code in ghidralib.py def findall_pattern(byte_pattern): # type: (str) -> Iterator[int] \"\"\"Find all occurrences of a byte pattern in the program. >>> findall_pattern(\"01 02 ?? 04\") [0x1000, 0x1004] :param byte_pattern: the pattern string. :return: iterator over all addresses of all occurrences.\"\"\" addr = -1 while True: addr = findone_pattern(byte_pattern, start=addr + 1) if addr is None: break yield addr","title":"findall_pattern"},{"location":"reference/#ghidralib.findone_pattern","text":"Find the first occurrence of a byte pattern in the program (or None). >>> findone_pattern(\"01 02 ?? 04\") 0x1000 Parameters: byte_pattern \u2013 the pattern string. start \u2013 the address to start searching from. Returns: \u2013 address of the first occurrence, or None if not found. Source code in ghidralib.py def findone_pattern(byte_pattern, start=0): # type: (str, Addr) -> int|None \"\"\"Find the first occurrence of a byte pattern in the program (or None). >>> findone_pattern(\"01 02 ?? 04\") 0x1000 :param byte_pattern: the pattern string. :param start: the address to start searching from. :return: address of the first occurrence, or None if not found.\"\"\" start = resolve(start) bytes = _pattern_to_bytes(byte_pattern) mask = _pattern_to_mask(byte_pattern) addr = ( Program.current().getMemory().findBytes(start, bytes, mask, True, getMonitor()) ) if not addr: return None return addr.getOffset()","title":"findone_pattern"},{"location":"reference/#ghidralib.from_bytes","text":"Decode a bytes as a little-endian integer. >>> from_bytes('ab') 25185 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py def from_bytes(b): # type: (bytes) -> int \"\"\"Decode a bytes as a little-endian integer. >>> from_bytes('ab') 25185 :param b: byte stream to decode.\"\"\" bl = _bytes_as_list(b) return sum(v << (i * 8) for i, v in enumerate(bl))","title":"from_bytes"},{"location":"reference/#ghidralib.get_string","text":"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py def get_string(address): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt(resolve(address)) if string and string.hasStringValue(): return string.getValue() return None","title":"get_string"},{"location":"reference/#ghidralib.read_bytes","text":"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py def read_bytes(address, length): # type: (Addr, int) -> bytes \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve(address) return _bytes_from_bytelist(getBytes(address, length))","title":"read_bytes"},{"location":"reference/#ghidralib.read_cstring","text":"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_cstring(address): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyte is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = read_u8(addr) if c == 0: break string += chr(c) addr = addr.add(1) return string","title":"read_cstring"},{"location":"reference/#ghidralib.read_u16","text":"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u16(address): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 2))","title":"read_u16"},{"location":"reference/#ghidralib.read_u32","text":"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u32(address): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 4))","title":"read_u32"},{"location":"reference/#ghidralib.read_u64","text":"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u64(address): # type: (Addr) -> int \"\"\"Read a 64bit integer from program at address. >>> read_u32(0x1000) 0x0102030405060708 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 8))","title":"read_u64"},{"location":"reference/#ghidralib.read_u8","text":"Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py def read_u8(address): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes(read_bytes(address, 1))","title":"read_u8"},{"location":"reference/#ghidralib.read_unicode","text":"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py def read_unicode(address): # type: (Addr) -> str \"\"\"Read a null-terminated utf-16 string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a null character is encountered. >>> read_unicode(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" addr = resolve(address) string = \"\" while True: c = read_u16(addr) if c == 0: break string += chr(c) addr = addr.add(2) return string","title":"read_unicode"},{"location":"reference/#ghidralib.resolve","text":"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py def resolve(addr): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance(addr, unicode): # Why, Ghidra? addr = addr.encode() if isinstance(addr, GenericAddress): return addr if isinstance(addr, (int, long)): # Why convert to string? Java cannot handle large (unsigned) integers :/ return toAddr(\"{:x}\".format(addr)) if isinstance(addr, str): return toAddr(Symbol(addr).address) raise TypeError(\"Address must be a ghidra Address, int, or str\")","title":"resolve"},{"location":"reference/#ghidralib.to_bytes","text":"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\x01\\x02' Parameters: value \u2013 integer to encode. length \u2013 number of bytes of the result. Source code in ghidralib.py def to_bytes(value, length): # type: (int, int) -> bytes \"\"\"Encode an integer as a little-endian byte stream. >>> to_bytes(0x0102, 2) '\\\\x01\\\\x02' :param value: integer to encode. :param length: number of bytes of the result.\"\"\" out = \"\" for i in range(length): out += chr(value & 0xFF) value >>= 8 return _asbytes(out)","title":"to_bytes"},{"location":"reference/#ghidralib.try_resolve","text":"Convert an arbitrary addressable value to a Ghidra Address object. See resolve documentation for more details. Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress representing the value, or None resolving failed. Source code in ghidralib.py def try_resolve(addr): # type: (Addr) -> GenericAddress | None \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. See `resolve` documentation for more details. :param addr: An addressable value. :return: A GenericAddress representing the value, or None resolving failed.\"\"\" try: return resolve(addr) except: return None","title":"try_resolve"},{"location":"reference/#ghidralib.unhex","text":"Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py def unhex(s): # type: (str) -> bytes \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return _unhex(s)","title":"unhex"},{"location":"reference/#ghidralib.unwrap","text":"If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py def unwrap(wrapper_or_java_type): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance(wrapper_or_java_type, GhidraWrapper): return wrapper_or_java_type.raw return wrapper_or_java_type","title":"unwrap"},{"location":"reference/#ghidralib.write_bytes","text":"Write the provided bytes at a given address. >>> write_bytes(0x1000, \"test) >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address where bytes should be written. data \u2013 bytes to write. Source code in ghidralib.py def write_bytes(address, data): # type: (Addr, bytes) -> None \"\"\"Write the provided bytes at a given address. >>> write_bytes(0x1000, \"test) >>> read_bytes(0x1000, 4) 'test' :param address: address where bytes should be written. :param data: bytes to write.\"\"\" addr = resolve(address) try: setBytes(addr, data) except: clearListing(addr, addr.add(len(data) - 1)) setBytes(addr, data)","title":"write_bytes"},{"location":"reference/#ghidralib.xor","text":"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py def xor(a, b): # type: (bytes, bytes) -> bytes \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\\\x01\\\\x02\", \"\\\\x03\\\\x04\") '\\\\x02\\\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" al = _bytes_as_list(a) bl = _bytes_as_list(b) return _asbytes(\"\".join(chr(x ^ y) for x, y in zip(al, bl)))","title":"xor"}]}