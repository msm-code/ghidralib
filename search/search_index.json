{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ghidralib Welcome to ghidralib documentation! This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args)) Basic Usage To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. For a showcase of useful API functions, check out the Getting Started section ( recommended ). For a few more practical examples, check out the examples directory on Github. Read the autogenerated API documentation here . Check the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it?","title":"Ghidralib"},{"location":"#ghidralib","text":"","title":"Ghidralib"},{"location":"#welcome-to-ghidralib-documentation","text":"This library is an attempt to provide an unofficial Pythonic standard library for Ghidra. The Ghidra scripting API, while extremely powerful, is not well suited for writing quick one-off scripts when reverse-engineering something at 3AM. Scripts usually end up verbose, fragile (since there's no type-checking) and with camelCaseEverywhere. The goal of this library is to make Ghidra scripting faster, easier and... more fun. from ghidralib import * for block in Function(\"main\").basicblocks: for instr in block.instructions: for pcode in instr.pcode: args = \", \".join(map(str, pcode.inputs_simple)) print(\"{:x} {} {}\".format(pcode.address, pcode.mnemonic, args))","title":"Welcome to ghidralib documentation!"},{"location":"#basic-usage","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. For a showcase of useful API functions, check out the Getting Started section ( recommended ). For a few more practical examples, check out the examples directory on Github. Read the autogenerated API documentation here . Check the source code at Github A fair warning: ghidralib is still actively developed and the API may change in the future. But this doesn't matter for your one-off scripts, does it?","title":"Basic Usage"},{"location":"getting_started/","text":"Getting Started This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier. Installation To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link. Main actors Function Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Print a value of eax and edx at each call of this function for call in Function(\"MyCustomCrypto\").calls: ctx = call.emulate() key, data = ctx.read_register(\"eax\"), ctx.read_register(\"edx\") print(key, data) # Print parameters of each call to this function, as seen by # the decompiler for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) Read more in the Function object documentation . Instruction Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation . BasicBlock Check these usage examples: # TODO: DFS example Read more in the BasicBlock object documentation . DataType Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) Read more in the DataType object documentation . Symbol Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(f\"funniner_{symbol.name}\") Read more in the Symbol object documentation . Working at various abstraction levels TODO Assembly instructions Pcode instructions High Pcode instructions Pcode AST graph Clang tokens Conventions There are a few conventions that this library follows, and which may be useful when learning: Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"This document contains an introduction to the most important objects wrapped by this library, and a few more motivational segments. Main Actors - description of the most important ghidralib objects Working at various abstraction levels description of the various abstraction levels wrapped (and made easy!) by ghidralib. Conventions this library follows some design rules. They are hopefully intuitive, but understanding them may make your first steps easier.","title":"Getting Started"},{"location":"getting_started/#installation","text":"To use ghidralib, just drop this file into your ghidra_scripts directory . Click here for a direct download link.","title":"Installation"},{"location":"getting_started/#main-actors","text":"","title":"Main actors"},{"location":"getting_started/#function","text":"Check these usage examples: from ghidralib import * # Get a function at address 0x8ca3f0 Function(0x8ca3f0) # Get a function named \"main\" Function(\"main\") # Print all assembly instructions in main function for instr in Function(\"main\").instructions: print(instr) # Print all pcode instructions in main function for instr in Function(\"main\").pcode: print(instr) # Print all high-level pcode instructions in main function # Or you can do it in 100 lines of Java: # https://github.com/evm-sec/high-pcode/blob/main/HighPCode.java for instr in Function(\"main\").high_pcode: print(instr) # Print all basic blocks in main function for block in Function(\"main\").basicblocks: print(block) # Decompile the main function and print the C code. print(Function(\"main\").decompile()) # Define a function at address 0x400300 Function.create(0x400300, \"main\") # Print a value of eax and edx at each call of this function for call in Function(\"MyCustomCrypto\").calls: ctx = call.emulate() key, data = ctx.read_register(\"eax\"), ctx.read_register(\"edx\") print(key, data) # Print parameters of each call to this function, as seen by # the decompiler for call in Function(\"MyCustomCrypto\").calls: key, data = call.get_args() print(key, data) Read more in the Function object documentation .","title":"Function"},{"location":"getting_started/#instruction","text":"Check these usage examples: # Get an instruction at address 0x8ca3f0 Instruction(0x8ca3f0) # Get the first instruction in main function Instruction(\"main\") # Print the instruction mnemonic and operands instr = Instruction(0x8ca3f0) print(instr.mnemonic, instr.operands) # Print the instruction pcode: for op in instr.pcode: print(op) # Print the instruction high-level pcode: for op in instr.high_pcode: print(op) Read more in the Instruction object documentation .","title":"Instruction"},{"location":"getting_started/#basicblock","text":"Check these usage examples: # TODO: DFS example Read more in the BasicBlock object documentation .","title":"BasicBlock"},{"location":"getting_started/#datatype","text":"Check these usage examples: # Get a datatype called \"int\" DataType(\"int\") # Parse a datatype from C string HINTERNET = DataType.from_c('typedef void* HINTERNET;') # Change a datatype at location create_data(0x1234, HINTERNET) Read more in the DataType object documentation .","title":"DataType"},{"location":"getting_started/#symbol","text":"Sometimes called a label. Check these usage examples: # Get a symbol (label) at address 0x8ca3f0 Symbol(0x8ca3f0) # Get a symbol (label) named \"main\" Symbol(\"main\") # Create a label \"foo\" at address 0x1234 Symbol.create(0x1234, \"foo\") # Change the symbol's data type Symbol(\"DAT_1234\").set_type(HINTERNET) # Print all symbols in the program for symbol in Symbol.all(): print(symbol) # Rename all unknown data to something funniner for symbol in Symbol.all(): if symbol.name.startswith(\"DAT_\"): symbol.rename(f\"funniner_{symbol.name}\") Read more in the Symbol object documentation .","title":"Symbol"},{"location":"getting_started/#working-at-various-abstraction-levels","text":"TODO Assembly instructions Pcode instructions High Pcode instructions Pcode AST graph Clang tokens","title":"Working at various abstraction levels"},{"location":"getting_started/#conventions","text":"There are a few conventions that this library follows, and which may be useful when learning: Every object that wraps a Ghidra object has a .raw property that can be used to get the unwrapped object. So you can always \"escape\" ghidralib: Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 Objects that have an address can be addressed in many different ways - by name, by address, or by Ghidra address object. All of these are equivalent: Function(\"main\") Function(0x669d1e) Function(toAddr(0x669d1e)) Additionaly, wrappers are \"tolerant\" and try to drop unnecessary layers. All of these are resolved to the same object: Instruction(getInstructionAt(toAddr(0x0669d2a))) # from raw object Instruction(0x669d2a) # from integer Instruction(Instruction(0x669d2a)) # wrapped two times Same goes in the other direction btw - Java API will accept wrappers getInstructionBefore(getInstructionAt(toAddr(0x0669d2a))) # pure java getInstructionBefore(Instruction(0x0669d2a)) # mixup library object Many objects expose a static constructor methods, where it makes sense. Possible methods are \"get\", \"create\", \"all\", \"create\". So for example instead of getAllSymbols() use Symbols.all() . The difference between Function.get(addr) and Function(addr) is that Function.get returns None instead of raising an exception when the desired object was not found.","title":"Conventions"},{"location":"reference/","text":"API reference ghidralib This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/. Addr = GenericAddress | int | str module-attribute Reg = GhRegister | str module-attribute long = int module-attribute BasicBlock Bases: GhidraWrapper Source code in ghidralib.py 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 class BasicBlock ( GhidraWrapper ): @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ] destinations property Get a list of basic blocks that this basic block jumps to end_address property Get the address of the last instruction in this basic block. instructions property Get a list of instructions in this basic block. pcode property Get a list of Pcode operations that this basic block was parsed to sources property Get a list of basic blocks that jump to this basic block start_address property Get the address of the first instruction in this basic block. get ( raw_or_address ) staticmethod Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) BlockGraph Bases: PcodeBlock Source code in ghidralib.py 486 487 488 489 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())] blocks property ClangTokenGroup Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 class ClangTokenGroup ( GhidraWrapper ): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup ( self , token ): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup ( token . Parent ()) for token in list ( token . iterator ()): if isinstance ( token , ( ClangCommentToken , ClangBreak )): continue if isinstance ( token , ClangSyntaxToken ): if not token . getText () or token . getText () . isspace (): continue if isinstance ( token , GhClangTokenGroup ): token = self . _cleanup ( token ) new . AddTokenGroup ( token ) return new @property def cleaned ( self ): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup ( self . _cleanup ( self . raw )) def _dump ( self , token , indent = 0 ): # type: (JavaObject, int) -> None if isinstance ( token , GhClangTokenGroup ): print ( \" {} [group]\" . format ( indent * \" \" , token . __class__ . __name__ )) for child in token . iterator (): self . _dump ( child , indent + 1 ) else : print ( \" {}{} ( {} )\" . format ( indent * \" \" , token , token . __class__ . __name__ )) def dump ( self ): # type: () -> None self . _dump ( self . raw ) cleaned property Remove all whitespace and comments from this token group, recursively. dump () Source code in ghidralib.py 1014 1015 def dump ( self ): # type: () -> None self . _dump ( self . raw ) DataType Bases: GhidraWrapper Source code in ghidralib.py 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 class DataType ( GhidraWrapper ): @staticmethod def get ( name ): # type: (str) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name: the name of the data type :return: the data type, or None if not found\"\"\" for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' \"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> from_c('typedef void* HINTERNET;') HINTERNET :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt name property Get a name of this data type DataType('int').name 'int' all ( only_local = False ) staticmethod Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes from_c ( c_code , insert = True ) staticmethod Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> from_c('typedef void* HINTERNET;') HINTERNET Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> from_c('typedef void* HINTERNET;') HINTERNET :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt get ( name ) staticmethod Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 @staticmethod def get ( name ): # type: (str) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name: the name of the data type :return: the data type, or None if not found\"\"\" for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None get_name ( value ) If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py 1393 1394 1395 1396 1397 def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) Emulator Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 class Emulator ( GhidraWrapper ): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr \"\"\"Get the program counter of the emulated program.\"\"\" return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def __getitem__ ( self , reg_or_addr ): # type: (Reg|int) -> int \"\"\"Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to read from\"\"\" if isinstance ( reg_or_addr , ( int , long )): return ord ( self . read_memory ( reg_or_addr , 1 )) elif isinstance ( reg_or_addr , str ): return self . read_register ( reg_or_addr ) else : raise TypeError ( \"Invalid type for reg_or_addr\" ) def __setitem__ ( self , reg_or_addr , value ): # type: (Reg|int, int|str) -> None \"\"\"Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to write to :param value: the value to write\"\"\" if isinstance ( reg_or_addr , ( int , long )): if isinstance ( value , str ): self . write_memory ( reg_or_addr , value ) else : assert - 127 <= value < 256 # <3 signed bytes value = value % 256 self . write_memory ( reg_or_addr , chr ( value )) elif isinstance ( reg_or_addr , str ): assert isinstance ( value , ( int , long )) self . write_register ( reg_or_addr , value ) def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"An alias for `read_memory`. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' :param start: the start address to emulate :param end: the end address to emulate\"\"\" self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode of the emulated program. This method can't read hash and unique varnodes\"\"\" if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed Pcode\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state pc property Get the program counter of the emulated program. __getitem__ ( reg_or_addr ) Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. Parameters: reg_or_addr \u2013 the register or address to read from Source code in ghidralib.py 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 def __getitem__ ( self , reg_or_addr ): # type: (Reg|int) -> int \"\"\"Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to read from\"\"\" if isinstance ( reg_or_addr , ( int , long )): return ord ( self . read_memory ( reg_or_addr , 1 )) elif isinstance ( reg_or_addr , str ): return self . read_register ( reg_or_addr ) else : raise TypeError ( \"Invalid type for reg_or_addr\" ) __init__ () Create a new Emulator object. Source code in ghidralib.py 1428 1429 1430 1431 def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) __setitem__ ( reg_or_addr , value ) Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. Parameters: reg_or_addr \u2013 the register or address to write to value \u2013 the value to write Source code in ghidralib.py 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 def __setitem__ ( self , reg_or_addr , value ): # type: (Reg|int, int|str) -> None \"\"\"Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to write to :param value: the value to write\"\"\" if isinstance ( reg_or_addr , ( int , long )): if isinstance ( value , str ): self . write_memory ( reg_or_addr , value ) else : assert - 127 <= value < 256 # <3 signed bytes value = value % 256 self . write_memory ( reg_or_addr , chr ( value )) elif isinstance ( reg_or_addr , str ): assert isinstance ( value , ( int , long )) self . write_register ( reg_or_addr , value ) emulate ( start , end ) Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate Source code in ghidralib.py 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 def emulate ( self , start , end ): # type: (Addr, Addr) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' :param start: the start address to emulate :param end: the end address to emulate\"\"\" self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) get_bytes ( address , length ) An alias for read_memory . >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 def get_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"An alias for `read_memory`. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) propagate_varnodes ( start , end ) Source code in ghidralib.py 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state read_memory ( address , length ) Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 def read_memory ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" return self . get_bytes ( address , length ) read_register ( reg ) Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py 1493 1494 1495 1496 1497 1498 1499 1500 1501 def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) read_varnode ( varnode ) Read from the varnode of the emulated program. This method can't read hash and unique varnodes Source code in ghidralib.py 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode of the emulated program. This method can't read hash and unique varnodes\"\"\" if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) set_pc ( address ) Set the program counter of the emulated program. Source code in ghidralib.py 1438 1439 1440 1441 def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) trace_pcode ( start , end , callback ) Emulate from start to end address, with callback for each executed PcodeOp. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed Pcode Source code in ghidralib.py 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed Pcode\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () write_memory ( address , value ) Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 def write_memory ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( address , value ) write_register ( reg , value ) Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) Function Bases: GhidraWrapper Wraps a Ghidra Function object. Source code in ghidralib.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 class Function ( GhidraWrapper ): \"\"\"Wraps a Ghidra Function object.\"\"\" @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self . entrypoint @property def name ( self ): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self . raw . getName () @property def comment ( self ): # type: () -> str \"\"\"Get the comment of this function, if any.\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] \"\"\" \"Get the parameters of this function.\"\"\" return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] \"\"\" \"Get the local variables of this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str \"\"\" \"Get the fixup of this function.\"\"\" return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] \"\"\" \"Get all function calls to this function.\"\"\" calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ()) @property def high_function ( self ): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\" \"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_pcode_tree () def get_pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . get_pcode_tree () @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\" \"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self . basicblocks : result . extend ( block . pcode ) return result @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address ) address property Get the address of this function. basicblocks property Get the basic blocks of this function. called property Get all functions that are called by this function. callers property Get all functions that call this function. calls property \"Get all function calls to this function. comment property Get the comment of this function, if any. entrypoint property Get the entrypoint of this function. fixup property writable \"Get the fixup of this function. high_function property Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. high_pcode property Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow. instructions property Get the assembler instructions for this function. is_external property Return True if this function is external. is_thunk property Return True if this function is a thunk. local_variables property \"Get the local variables of this function. name property Get the name of this function. parameters property \"Get the parameters of this function. pcode property \"Get the (low-level) Pcode for this function. pcode_tree property \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. repeatable_comment property Get the repeatable comment of this function, if any. return_type property Get the return type of this function. return_variable property Get the variable representing a return value of this function. variables property Get all variables defined in this function. xref_addrs property Get the source addresses of references to this function. xrefs property Get the references to this function. all () staticmethod Return all functions in the current program. Source code in ghidralib.py 1030 1031 1032 1033 1034 @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] create ( address , name ) staticmethod Create a new function at the given address with the given name. Source code in ghidralib.py 1036 1037 1038 1039 1040 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) decompile () Get decompiled C code for the function as string. Source code in ghidralib.py 1186 1187 1188 1189 def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () get ( addr ) staticmethod Return a function at the given address, or None if no function exists there. Source code in ghidralib.py 1021 1022 1023 1024 1025 1026 1027 1028 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore get_high_function ( simplify = 'decompile' ) Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 1205 1206 1207 1208 1209 1210 1211 1212 1213 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) get_high_pcode ( simplify = 'decompile' ) \"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 1215 1216 1217 1218 1219 1220 1221 1222 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\" \"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode get_high_pcode_at ( address ) Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py 1252 1253 1254 1255 1256 1257 1258 1259 1260 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address ) get_pcode_tree () \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 1231 1232 1233 1234 1235 def get_pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . get_pcode_tree () rename ( name ) Change the name of this function. Source code in ghidralib.py 1110 1111 1112 def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) set_comment ( comment ) Set the comment of this function. Source code in ghidralib.py 1072 1073 1074 def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) set_repeatable_comment ( comment ) Set the repeatable comment of this function. Source code in ghidralib.py 1091 1092 1093 def set_repeatable_comment ( self , comment ): # type: (str) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) tokens () Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value. Source code in ghidralib.py 1191 1192 1193 1194 1195 1196 def tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ()) FunctionCall Represents an abstract function call. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 class FunctionCall : \"\"\"Represents an abstract function call. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] \"\"\"Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values.\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator \"\"\"Emulate the basic block of this function call, and return the state\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args address = resolve ( address ) instance-attribute function = function instance-attribute __init__ ( function , address ) Source code in ghidralib.py 914 915 916 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) emulate () Emulate the basic block of this function call, and return the state Source code in ghidralib.py 941 942 943 944 945 946 def emulate ( self ): # type: () -> Emulator \"\"\"Emulate the basic block of this function call, and return the state\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu get_args ( emulate = True ) Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def get_args ( self , emulate = True ): # type: (bool) -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args get_args_as_varnodes () Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 948 949 950 951 952 953 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr get_high_pcode () Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 918 919 920 921 922 923 924 925 926 927 928 929 930 def get_high_pcode ( self ): # type: () -> PcodeOp \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) get_varnodes () Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values. Source code in ghidralib.py 932 933 934 935 936 937 938 939 def get_varnodes ( self ): # type: () -> dict[Varnode, int] \"\"\"Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values.\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) GhidraWrapper The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class GhidraWrapper : \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __repr__ = raw . __repr__ instance-attribute __str__ = raw . __str__ instance-attribute raw = _as_javaobject ( raw ) instance-attribute __eq__ ( other ) Source code in ghidralib.py 203 204 205 206 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other ) __hash__ () Source code in ghidralib.py 200 201 def __hash__ ( self ): # type: () -> int return self . raw . hashCode () __init__ ( raw ) Source code in ghidralib.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject __tojava__ ( klass ) Make it possible to pass this object to Java methods Source code in ghidralib.py 196 197 198 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw HighFunction Bases: GhidraWrapper Source code in ghidralib.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basic_blocks ( self ): # type: () -> list[PcodeBlock] return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] def get_pcode_tree ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) basic_blocks property pcode property get_pcode_at ( address ) Source code in ghidralib.py 493 494 495 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] get_pcode_tree () Source code in ghidralib.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def get_pcode_tree ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph ) HighSymbol Bases: GhidraWrapper Source code in ghidralib.py 218 219 220 221 222 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source ) rename ( new_name , source = SourceType . USER_DEFINED ) Source code in ghidralib.py 219 220 221 222 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source ) HighVariable Bases: GhidraWrapper Source code in ghidralib.py 209 210 211 212 213 214 215 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) symbol property rename ( new_name ) Source code in ghidralib.py 214 215 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name ) Instruction Bases: GhidraWrapper Wraps a Ghidra Instruction object Source code in ghidralib.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 class Instruction ( GhidraWrapper ): \"\"\"Wraps a Ghidra Instruction object\"\"\" def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction \"\"\"Get an instruction at an address, or None if not found.\"\"\" if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) @property def mnemonic ( self ): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] \"\"\"Get a list of references that point to this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return self . raw . getBytes () def operand ( self , ndx ): # type: (int) -> int \"\"\" \"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out @property def address ( self ): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self . raw . getAddress () . getOffset () @property def operands ( self ): # type: () -> list[int|str] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.\"\"\" raise RuntimeError ( \"TODO\" ) @property def flow ( self ): # type: () -> RefType \"\"\" \"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) address property Get the address of this instruction. flow property \"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP high_pcode property Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead. mnemonic property Get the mnemonic of this instruction. next property Get the next instruction. operands property Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned. pcode property Get a list of Pcode operations that this instruction was parsed to previous property Get the previous instruction. xrefs_from property Get a list of references that point to this instruction. add_operand_reference ( op_ndx , ref_addr , ref_type , src_type ) Add a reference to an operand of this instruction. Source code in ghidralib.py 773 774 775 776 777 778 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type ) get ( raw_or_address ) Get an instruction at an address, or None if not found. Source code in ghidralib.py 680 681 682 683 684 685 686 def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction \"\"\"Get an instruction at an address, or None if not found.\"\"\" if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) operand ( ndx ) \"Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 724 725 726 727 728 729 730 731 732 733 734 735 736 def operand ( self , ndx ): # type: (int) -> int \"\"\" \"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) register ( ndx ) Get the nth operand of this instruction as a register name. Source code in ghidralib.py 745 746 747 748 749 750 def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out scalar ( ndx ) Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 738 739 740 741 742 743 def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out to_bytes () Get the bytes of this instruction. Source code in ghidralib.py 720 721 722 def to_bytes ( self ): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return self . raw . getBytes () JavaObject A fake class, used for static type hints. Source code in ghidralib.py 60 61 62 63 64 65 class JavaObject : \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass __getattribute__ ( name ) This attribute exists to make mypy happy. Source code in ghidralib.py 63 64 65 def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass Parameter Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py 895 896 897 898 899 900 901 902 903 904 905 906 class Parameter ( Variable ): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal ( self ): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType ( self . raw . getFormalDataType ()) formal_data_type property Returns the formal data type of this parameter. ordinal property Returns the ordinal of this parameter. PcodeBlock Bases: GhidraWrapper Source code in ghidralib.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def has_children ( self ): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ] has_children property Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph. incoming_edges property outgoing_edges property pcode property PcodeOp Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ()) BOOL_AND = 39 class-attribute instance-attribute BOOL_NEGATE = 37 class-attribute instance-attribute BOOL_OR = 40 class-attribute instance-attribute BOOL_XOR = 38 class-attribute instance-attribute BRANCH = 4 class-attribute instance-attribute BRANCHIND = 6 class-attribute instance-attribute CALL = 7 class-attribute instance-attribute CALLIND = 8 class-attribute instance-attribute CALLOTHER = 9 class-attribute instance-attribute CAST = 64 class-attribute instance-attribute CBRANCH = 5 class-attribute instance-attribute COPY = 1 class-attribute instance-attribute CPOOLREF = 68 class-attribute instance-attribute EXTRACT = 71 class-attribute instance-attribute FLOAT_ABS = 52 class-attribute instance-attribute FLOAT_ADD = 47 class-attribute instance-attribute FLOAT_CEIL = 57 class-attribute instance-attribute FLOAT_DIV = 48 class-attribute instance-attribute FLOAT_EQUAL = 41 class-attribute instance-attribute FLOAT_FLOAT2FLOAT = 55 class-attribute instance-attribute FLOAT_FLOOR = 58 class-attribute instance-attribute FLOAT_INT2FLOAT = 54 class-attribute instance-attribute FLOAT_LESS = 43 class-attribute instance-attribute FLOAT_LESSEQUAL = 44 class-attribute instance-attribute FLOAT_MULT = 49 class-attribute instance-attribute FLOAT_NAN = 46 class-attribute instance-attribute FLOAT_NEG = 51 class-attribute instance-attribute FLOAT_NOTEQUAL = 42 class-attribute instance-attribute FLOAT_ROUND = 59 class-attribute instance-attribute FLOAT_SQRT = 53 class-attribute instance-attribute FLOAT_SUB = 50 class-attribute instance-attribute FLOAT_TRUNC = 56 class-attribute instance-attribute INDIRECT = 61 class-attribute instance-attribute INSERT = 70 class-attribute instance-attribute INT_2COMP = 24 class-attribute instance-attribute INT_ADD = 19 class-attribute instance-attribute INT_AND = 27 class-attribute instance-attribute INT_CARRY = 21 class-attribute instance-attribute INT_DIV = 33 class-attribute instance-attribute INT_EQUAL = 11 class-attribute instance-attribute INT_LEFT = 29 class-attribute instance-attribute INT_LESS = 15 class-attribute instance-attribute INT_LESSEQUAL = 16 class-attribute instance-attribute INT_MULT = 32 class-attribute instance-attribute INT_NEGATE = 25 class-attribute instance-attribute INT_NOTEQUAL = 12 class-attribute instance-attribute INT_OR = 28 class-attribute instance-attribute INT_REM = 35 class-attribute instance-attribute INT_RIGHT = 30 class-attribute instance-attribute INT_SBORROW = 23 class-attribute instance-attribute INT_SCARRY = 22 class-attribute instance-attribute INT_SDIV = 34 class-attribute instance-attribute INT_SEXT = 18 class-attribute instance-attribute INT_SLESS = 13 class-attribute instance-attribute INT_SLESSEQUAL = 14 class-attribute instance-attribute INT_SREM = 36 class-attribute instance-attribute INT_SRIGHT = 31 class-attribute instance-attribute INT_SUB = 20 class-attribute instance-attribute INT_XOR = 26 class-attribute instance-attribute INT_ZEXT = 17 class-attribute instance-attribute LOAD = 2 class-attribute instance-attribute LZCOUNT = 73 class-attribute instance-attribute MULTIEQUAL = 60 class-attribute instance-attribute NEW = 69 class-attribute instance-attribute PCODE_MAX = 74 class-attribute instance-attribute PIECE = 62 class-attribute instance-attribute POPCOUNT = 72 class-attribute instance-attribute PTRADD = 65 class-attribute instance-attribute PTRSUB = 66 class-attribute instance-attribute RETURN = 10 class-attribute instance-attribute SEGMENTOP = 67 class-attribute instance-attribute STORE = 3 class-attribute instance-attribute SUBPIECE = 63 class-attribute instance-attribute UNIMPLEMENTED = 0 class-attribute instance-attribute address property Get an address in the program where this instruction is located inputs property inputs_simple property Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). mnemonic property Get a string representation of the operation, for example \"COPY\" opcode property output property get_high_pcode_at ( address ) staticmethod Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 410 411 412 413 414 415 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) RefType Bases: GhidraWrapper Source code in ghidralib.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () class-attribute instance-attribute CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder () class-attribute instance-attribute CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute COMPUTED_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute CONDITIONAL_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute FALL_THROUGH = _reftype_placeholder () class-attribute instance-attribute FLOW = _reftype_placeholder () class-attribute instance-attribute INDIRECTION = _reftype_placeholder () class-attribute instance-attribute INVALID = _reftype_placeholder () class-attribute instance-attribute JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () class-attribute instance-attribute JUMP_TERMINATOR = _reftype_placeholder () class-attribute instance-attribute TERMINATOR = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_CALL = _reftype_placeholder () class-attribute instance-attribute UNCONDITIONAL_JUMP = _reftype_placeholder () class-attribute instance-attribute has_fall property writable is_call property writable is_computed property writable is_conditional property writable is_data property is_flow property is_jump property writable is_override property is_read property is_terminal property is_unconditional property is_write property Reference Bases: GhidraWrapper Source code in ghidralib.py 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self . raw . getToAddress () . getOffset () from_address property Return the address of the source of the reference. is_call property Return True if the reference is a call. is_jump property Return True if the reference is a jump. reftype property Return the type of reference. to_address property Return the address of the target of the reference. Register Bases: GhidraWrapper Source code in ghidralib.py 225 226 227 228 class Register ( GhidraWrapper ): @property def name ( self ): return self . raw . getName () name property Symbol Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 class Symbol ( GhidraWrapper ): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols.\"\"\" symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) @property def address ( self ): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None \"\"\"Set the data type of this symbol.\"\"\" create_data ( self . address , datatype ) def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source ) address property Get the address of this symbol. name property Get the name of this symbol. name_with_namespace property Get the fully qualified name of this symbol. xref_addrs property Get the addresses of all references to this symbol. xrefs property Get a list of references to this symbol. all () staticmethod Get all symbols. Source code in ghidralib.py 1287 1288 1289 1290 1291 1292 @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols.\"\"\" symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] create ( address , name , source = SourceType . USER_DEFINED ) staticmethod Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) get ( raw_or_name ) staticmethod Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) rename ( new_name , source = SourceType . USER_DEFINED ) Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source ) set_type ( datatype ) Set the data type of this symbol. Source code in ghidralib.py 1331 1332 1333 def set_type ( self , datatype ): # type: (DataType) -> None \"\"\"Set the data type of this symbol.\"\"\" create_data ( self . address , datatype ) Variable Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 class Variable ( GhidraWrapper ): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name ( self ): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self . raw . getName () @property def data_type ( self ): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self . raw . isValid () @property def comment ( self ): # type: () -> str \"\"\" \"\"Get the comment for this variable\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol \"\"\" \"\"Get the symbol for this variable\"\"\" return Symbol ( self . raw . getSymbol ()) comment property \"\"Get the comment for this variable data_type property Get the data type of this variable is_compound property Check if this variable is a compound variable is_memory property Check if this variable is stored in memory is_stack property Check if this variable is a stack variable is_unique property Check if this variable is of type unique is_valid property Check if this variable is valid name property Get the name of this variable symbol property \"\"Get the symbol for this variable set_comment ( comment ) Set the comment for this variable Source code in ghidralib.py 865 866 867 def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) Varnode Bases: GhidraWrapper Source code in ghidralib.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def as_register ( self ): # type: () -> Register language = currentProgram . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return Register ( raw ) @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register . name elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" ) as_register property free property has_value property high property is_address property is_constant property Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value. is_free property is_hash property is_register property is_unique property offset property simple property Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position. size property symbol property value property Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value. rename ( new_name ) Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 289 290 291 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) can_resolve ( addr ) Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py 132 133 134 135 136 137 def can_resolve ( addr ): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance ( addr , ( GenericAddress , int , long , str )) collect_iterator ( iterator ) Collect a Java iterator to a Python list. Source code in ghidralib.py 86 87 88 89 90 91 def collect_iterator ( iterator ): \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result create_data ( address , datatype ) Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 def create_data ( address , datatype ): # type: (Addr, DataType) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype )) current_location () Get the current location in the program. current_location() 0x1000 Source code in ghidralib.py 1689 1690 1691 1692 1693 1694 1695 def current_location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 \"\"\" return currentLocation . getAddress () . getOffset () enhex ( s ) Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def enhex ( s ): # type: (str | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if isinstance ( s , str ): s = [ ord ( x ) for x in s ] return s . encode ( \"hex\" ) # type: ignore <- py2 from_bytes ( b ) Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 def from_bytes ( b ): # type: (str | list[int]) -> int \"\"\"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 :param b: byte stream to decode.\"\"\" if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b )) get_string ( address ) Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 def get_string ( address ): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None read_bytes ( address , length ) Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 def read_bytes ( address , length ): # type: (Addr, int) -> str \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length )) read_cstring ( address ) Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyt is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 def read_cstring ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyt is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" address = resolve_to_int ( address ) string = \"\" while True : c = read_u8 ( address ) if c == 0 : break string += chr ( c ) address += 1 return string read_u16 ( address ) Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1708 1709 1710 1711 1712 1713 1714 1715 def read_u16 ( address ): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 2 )) read_u32 ( address ) Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1718 1719 1720 1721 1722 1723 1724 1725 def read_u32 ( address ): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 4 )) read_u8 ( address ) Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1698 1699 1700 1701 1702 1703 1704 1705 def read_u8 ( address ): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 1 )) resolve ( addr ) Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def resolve ( addr ): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" ) resolve_to_int ( addr ) Convert an addressable value to an integer representation. Source code in ghidralib.py 127 128 129 def resolve_to_int ( addr ): # type: (Addr) -> int \"\"\"Convert an addressable value to an integer representation.\"\"\" return resolve ( addr ) . getOffset () unhex ( s ) Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py 1752 1753 1754 1755 1756 1757 1758 1759 def unhex ( s ): # type: (str) -> str \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return s . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) . decode ( \"hex\" ) # type: ignore <- py2 unwrap ( wrapper_or_java_type ) If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py 140 141 142 143 144 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type xor ( a , b ) XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\u0001\", \"\u0004\") '\u0006' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 def xor ( a , b ): # type: (str, str) -> str \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"API reference"},{"location":"reference/#api-reference","text":"","title":"API reference"},{"location":"reference/#ghidralib","text":"This library is an attempt to provide a Pythonic standard library for Ghidra. The main goal is to make writing quick&dirty scripts actually quick, and not that dirty. There is no equivalent of FlatProgramAPI from GHidra. You are expected to start by getting an object of interest by calling instance methods, for example >>> Function(\"main\") main to get a function called \"main\". When you want to do something this library doesn't support (yet), you can always excape back to Ghidra's wrapped Java types, by getting a .raw property, for example: >>> Function(\"main\").raw.UNKNOWN_STACK_DEPTH_CHANGE 2147483647 For more details, see the documentation at https://msm-code.github.io/ghidralib/.","title":"ghidralib"},{"location":"reference/#ghidralib.Addr","text":"","title":"Addr"},{"location":"reference/#ghidralib.Reg","text":"","title":"Reg"},{"location":"reference/#ghidralib.long","text":"","title":"long"},{"location":"reference/#ghidralib.BasicBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 class BasicBlock ( GhidraWrapper ): @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw ) @property def start_address ( self ): # type: () -> int \"\"\"Get the address of the first instruction in this basic block.\"\"\" return self . raw . getMinAddress () . getOffset () @property def end_address ( self ): # type: () -> int \"\"\"Get the address of the last instruction in this basic block.\"\"\" return self . raw . getMaxAddress () . getOffset () @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get a list of instructions in this basic block.\"\"\" result = [] instruction = getInstructionAt ( resolve ( self . start_address )) while instruction and instruction . getAddress () . getOffset () < self . end_address : result . append ( Instruction ( instruction )) instruction = instruction . getNext () return result @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this basic block was parsed to\"\"\" result = [] for instruction in self . instructions : result . extend ( instruction . pcode ) return result @property def destinations ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that this basic block jumps to\"\"\" raw_refs = collect_iterator ( self . raw . getDestinations ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getDestinationBlock ()) for raw in raw_refs ] @property def sources ( self ): # type: () -> list[BasicBlock] \"\"\"Get a list of basic blocks that jump to this basic block\"\"\" raw_refs = collect_iterator ( self . raw . getSources ( TaskMonitor . DUMMY )) return [ BasicBlock ( raw . getSourceBlock ()) for raw in raw_refs ]","title":"BasicBlock"},{"location":"reference/#ghidralib.BasicBlock.destinations","text":"Get a list of basic blocks that this basic block jumps to","title":"destinations"},{"location":"reference/#ghidralib.BasicBlock.end_address","text":"Get the address of the last instruction in this basic block.","title":"end_address"},{"location":"reference/#ghidralib.BasicBlock.instructions","text":"Get a list of instructions in this basic block.","title":"instructions"},{"location":"reference/#ghidralib.BasicBlock.pcode","text":"Get a list of Pcode operations that this basic block was parsed to","title":"pcode"},{"location":"reference/#ghidralib.BasicBlock.sources","text":"Get a list of basic blocks that jump to this basic block","title":"sources"},{"location":"reference/#ghidralib.BasicBlock.start_address","text":"Get the address of the first instruction in this basic block.","title":"start_address"},{"location":"reference/#ghidralib.BasicBlock.get","text":"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped) Source code in ghidralib.py 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 @staticmethod def get ( raw_or_address ): # type: (JavaObject|Addr) -> BasicBlock \"\"\"Get a BasicBlock object for the given address, or return None. This function is tolerant and will accept different types of arguments: * address as int * Address object * symbol as string (will be resolved) * BasicBlock object (wrapped or unwrapped)\"\"\" if can_resolve ( raw_or_address ): block_model = SimpleBlockModel ( currentProgram ) raw = block_model . getFirstCodeBlockContaining ( resolve ( raw_or_address ), TaskMonitor . DUMMY ) else : raw = raw_or_address return BasicBlock ( raw )","title":"get"},{"location":"reference/#ghidralib.BlockGraph","text":"Bases: PcodeBlock Source code in ghidralib.py 486 487 488 489 class BlockGraph ( PcodeBlock ): @property def blocks ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getBlock ( i )) for i in range ( self . raw . getSize ())]","title":"BlockGraph"},{"location":"reference/#ghidralib.BlockGraph.blocks","text":"","title":"blocks"},{"location":"reference/#ghidralib.ClangTokenGroup","text":"Bases: GhidraWrapper Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()). Source code in ghidralib.py 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 class ClangTokenGroup ( GhidraWrapper ): \"\"\"Represents a group of clang tokens from a decompiler. Warning: Currently this class is experimental, and should not be relied upon, except to get the Java object (with .raw) or maybe dump (.dump()).\"\"\" def _cleanup ( self , token ): # type: (JavaObject) -> JavaObject new = GhClangTokenGroup ( token . Parent ()) for token in list ( token . iterator ()): if isinstance ( token , ( ClangCommentToken , ClangBreak )): continue if isinstance ( token , ClangSyntaxToken ): if not token . getText () or token . getText () . isspace (): continue if isinstance ( token , GhClangTokenGroup ): token = self . _cleanup ( token ) new . AddTokenGroup ( token ) return new @property def cleaned ( self ): # type: () -> ClangTokenGroup \"\"\"Remove all whitespace and comments from this token group, recursively.\"\"\" return ClangTokenGroup ( self . _cleanup ( self . raw )) def _dump ( self , token , indent = 0 ): # type: (JavaObject, int) -> None if isinstance ( token , GhClangTokenGroup ): print ( \" {} [group]\" . format ( indent * \" \" , token . __class__ . __name__ )) for child in token . iterator (): self . _dump ( child , indent + 1 ) else : print ( \" {}{} ( {} )\" . format ( indent * \" \" , token , token . __class__ . __name__ )) def dump ( self ): # type: () -> None self . _dump ( self . raw )","title":"ClangTokenGroup"},{"location":"reference/#ghidralib.ClangTokenGroup.cleaned","text":"Remove all whitespace and comments from this token group, recursively.","title":"cleaned"},{"location":"reference/#ghidralib.ClangTokenGroup.dump","text":"Source code in ghidralib.py 1014 1015 def dump ( self ): # type: () -> None self . _dump ( self . raw )","title":"dump"},{"location":"reference/#ghidralib.DataType","text":"Bases: GhidraWrapper Source code in ghidralib.py 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 class DataType ( GhidraWrapper ): @staticmethod def get ( name ): # type: (str) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name: the name of the data type :return: the data type, or None if not found\"\"\" for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes @property def name ( self ): # type: () -> str \"\"\"Get a name of this data type >>> DataType('int').name 'int' \"\"\" return self . raw . getName () def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value ) @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> from_c('typedef void* HINTERNET;') HINTERNET :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"DataType"},{"location":"reference/#ghidralib.DataType.name","text":"Get a name of this data type DataType('int').name 'int'","title":"name"},{"location":"reference/#ghidralib.DataType.all","text":"Get all data types Parameters: only_local \u2013 if True, return only local data types. Otherwise, will scan all data types in all data type managers. Source code in ghidralib.py 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 @staticmethod def all ( only_local = False ): # type: (bool) -> list[DataType] \"\"\"Get all data types :param only_local: if True, return only local data types. Otherwise, will scan all data types in all data type managers.\"\"\" datatypes = list ( currentProgram . getDataTypeManager () . getAllDataTypes ()) if only_local : return datatypes managers = ( state . getTool () . getService ( DataTypeManagerService ) . getDataTypeManagers () ) for manager in managers : for datatype in manager . getAllDataTypes (): datatypes . append ( datatype ) return datatypes","title":"all"},{"location":"reference/#ghidralib.DataType.from_c","text":"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is typedef void* HINTERNET; >>> from_c('typedef void* HINTERNET;') HINTERNET Parameters: c_code \u2013 the C structure definition insert \u2013 if True, add the data type to the current program Source code in ghidralib.py 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 @staticmethod def from_c ( c_code , insert = True ): # type: (str, bool) -> DataType \"\"\"Parse C structure definition and return the parsed DataType. If insert (true by default), add it to current program. Example of a valid c_code is `typedef void* HINTERNET;` >>> from_c('typedef void* HINTERNET;') HINTERNET :param c_code: the C structure definition :param insert: if True, add the data type to the current program \"\"\" dtm = currentProgram . getDataTypeManager () parser = CParser ( dtm ) new_dt = parser . parse ( c_code ) if insert : transaction = dtm . startTransaction ( \"Adding new data\" ) dtm . addDataType ( new_dt , None ) dtm . endTransaction ( transaction , True ) return new_dt","title":"from_c"},{"location":"reference/#ghidralib.DataType.get","text":"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int Parameters: name \u2013 the name of the data type Returns: \u2013 the data type, or None if not found Source code in ghidralib.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 @staticmethod def get ( name ): # type: (str) -> DataType|None \"\"\"Gets a data type by name, or returns None if not found. Warning: this method is relatively slow, since it scans all data types in all data type managers. >>> DataType.get(\"int\") int :param name: the name of the data type :return: the data type, or None if not found\"\"\" for datatype in DataType . all (): if datatype . name == name : return DataType ( datatype ) return None","title":"get"},{"location":"reference/#ghidralib.DataType.get_name","text":"If this data type is an enum, get the name of the value. Parameters: value \u2013 the value to get the name of Source code in ghidralib.py 1393 1394 1395 1396 1397 def get_name ( self , value ): # type: (int) -> str \"\"\"If this data type is an enum, get the name of the value. :param value: the value to get the name of\"\"\" return self . raw . getName ( value )","title":"get_name"},{"location":"reference/#ghidralib.Emulator","text":"Bases: GhidraWrapper Wraps a Ghidra EmulatorHelper object. Source code in ghidralib.py 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 class Emulator ( GhidraWrapper ): \"\"\"Wraps a Ghidra EmulatorHelper object.\"\"\" def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw ) @property def pc ( self ): # type: () -> Addr \"\"\"Get the program counter of the emulated program.\"\"\" return self . raw . getExecutionAddress () def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address ) def __getitem__ ( self , reg_or_addr ): # type: (Reg|int) -> int \"\"\"Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to read from\"\"\" if isinstance ( reg_or_addr , ( int , long )): return ord ( self . read_memory ( reg_or_addr , 1 )) elif isinstance ( reg_or_addr , str ): return self . read_register ( reg_or_addr ) else : raise TypeError ( \"Invalid type for reg_or_addr\" ) def __setitem__ ( self , reg_or_addr , value ): # type: (Reg|int, int|str) -> None \"\"\"Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to write to :param value: the value to write\"\"\" if isinstance ( reg_or_addr , ( int , long )): if isinstance ( value , str ): self . write_memory ( reg_or_addr , value ) else : assert - 127 <= value < 256 # <3 signed bytes value = value % 256 self . write_memory ( reg_or_addr , chr ( value )) elif isinstance ( reg_or_addr , str ): assert isinstance ( value , ( int , long )) self . write_register ( reg_or_addr , value ) def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg ) def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value ) def get_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"An alias for `read_memory`. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist ) def read_memory ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" return self . get_bytes ( address , length ) def write_memory ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( address , value ) def emulate ( self , start , end ): # type: (Addr, Addr) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' :param start: the start address to emulate :param end: the end address to emulate\"\"\" self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err )) def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode of the emulated program. This method can't read hash and unique varnodes\"\"\" if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" ) def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed Pcode\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress () def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"Emulator"},{"location":"reference/#ghidralib.Emulator.pc","text":"Get the program counter of the emulated program.","title":"pc"},{"location":"reference/#ghidralib.Emulator.__getitem__","text":"Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. Parameters: reg_or_addr \u2013 the register or address to read from Source code in ghidralib.py 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 def __getitem__ ( self , reg_or_addr ): # type: (Reg|int) -> int \"\"\"Read the register or a single byte of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator[\"eax\"] 1337 >>> emulator.write_memory(0x1000, \"A\") >>> emulator[0x1000] 65 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to read from\"\"\" if isinstance ( reg_or_addr , ( int , long )): return ord ( self . read_memory ( reg_or_addr , 1 )) elif isinstance ( reg_or_addr , str ): return self . read_register ( reg_or_addr ) else : raise TypeError ( \"Invalid type for reg_or_addr\" )","title":"__getitem__"},{"location":"reference/#ghidralib.Emulator.__init__","text":"Create a new Emulator object. Source code in ghidralib.py 1428 1429 1430 1431 def __init__ ( self ): # type: () -> None \"\"\"Create a new Emulator object.\"\"\" raw = EmulatorHelper ( currentProgram ) GhidraWrapper . __init__ ( self , raw )","title":"__init__"},{"location":"reference/#ghidralib.Emulator.__setitem__","text":"Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. Parameters: reg_or_addr \u2013 the register or address to write to value \u2013 the value to write Source code in ghidralib.py 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 def __setitem__ ( self , reg_or_addr , value ): # type: (Reg|int, int|str) -> None \"\"\"Write to the register or memory of the emulated program. >>> emulator[\"eax\"] = 1234 >>> emulator.read_register(\"eax\") 1337 >>> emulator[0x1000] = \"ABC\" >>> emulator.read_memory(0x1001, 1) 66 >>> emulator[0x1000] = 123 >>> emulator.read_memory(0x1000, 1) 123 Warning: if speed matters, don't read byte by byte using this method, use read_memory instead. :param reg_or_addr: the register or address to write to :param value: the value to write\"\"\" if isinstance ( reg_or_addr , ( int , long )): if isinstance ( value , str ): self . write_memory ( reg_or_addr , value ) else : assert - 127 <= value < 256 # <3 signed bytes value = value % 256 self . write_memory ( reg_or_addr , chr ( value )) elif isinstance ( reg_or_addr , str ): assert isinstance ( value , ( int , long )) self . write_register ( reg_or_addr , value )","title":"__setitem__"},{"location":"reference/#ghidralib.Emulator.emulate","text":"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate Source code in ghidralib.py 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 def emulate ( self , start , end ): # type: (Addr, Addr) -> None \"\"\"Emulate from start to end address. This method will set a breakpoint at the end address, and clear it after the emulation is done. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.emulate(0x1000, 0x1005) >>> emulator.read_memory(0x1000, 1) '0' :param start: the start address to emulate :param end: the end address to emulate\"\"\" self . set_pc ( start ) end = resolve ( end ) self . raw . setBreakpoint ( end ) is_breakpoint = self . raw . run ( TaskMonitor . DUMMY ) self . raw . clearBreakpoint ( end ) if not is_breakpoint : err = self . raw . getLastError () raise RuntimeError ( \"Error when running: {} \" . format ( err ))","title":"emulate"},{"location":"reference/#ghidralib.Emulator.get_bytes","text":"An alias for read_memory . >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 def get_bytes ( self , address , length ): # type: (Addr, int) -> str \"\"\"An alias for `read_memory`. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" bytelist = self . raw . readMemory ( address , length ) return \"\" . join ( chr ( x % 256 ) for x in bytelist )","title":"get_bytes"},{"location":"reference/#ghidralib.Emulator.propagate_varnodes","text":"Source code in ghidralib.py 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 def propagate_varnodes ( self , start , end ): # type: (Addr, Addr) -> dict[Varnode, int] known_state = {} # type: dict[Varnode, int] def callback ( op ): # type: (PcodeOp) -> None resolved = True for inp in op . inputs : if inp in known_state : continue if inp . is_constant or inp . is_address : continue resolved = False break if resolved and op . output is not None : res = self . read_varnode ( op . output ) known_state [ op . output ] = res self . trace_pcode ( start , end , callback ) return known_state","title":"propagate_varnodes"},{"location":"reference/#ghidralib.Emulator.read_memory","text":"Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' Parameters: address \u2013 the address to read from length \u2013 the length to read Source code in ghidralib.py 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 def read_memory ( self , address , length ): # type: (Addr, int) -> str \"\"\"Read from the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.get_bytes(0x1000, 1) '1' :param address: the address to read from :param length: the length to read\"\"\" return self . get_bytes ( address , length )","title":"read_memory"},{"location":"reference/#ghidralib.Emulator.read_register","text":"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 Parameters: reg \u2013 the register to read from. Source code in ghidralib.py 1493 1494 1495 1496 1497 1498 1499 1500 1501 def read_register ( self , reg ): # type: (Reg) -> int \"\"\"Read from the register of the emulated program. >>> emulator.write_register(\"eax\", 1337) >>> emulator.read_register(\"eax\") 1337 :param reg: the register to read from.\"\"\" return self . raw . readRegister ( reg )","title":"read_register"},{"location":"reference/#ghidralib.Emulator.read_varnode","text":"Read from the varnode of the emulated program. This method can't read hash and unique varnodes Source code in ghidralib.py 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 def read_varnode ( self , varnode ): # type: (Varnode) -> int \"\"\"Read from the varnode of the emulated program. This method can't read hash and unique varnodes\"\"\" if varnode . is_constant : return varnode . value elif varnode . is_address : rawnum = self . raw . readMemory ( varnode . offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_unique : space = currentProgram . getAddressFactory () . getUniqueSpace () offset = space . getAddress ( varnode . offset ) rawnum = self . raw . readMemory ( offset , varnode . size ) return from_bytes ( rawnum ) elif varnode . is_register : language = currentProgram . getLanguage () reg = language . getRegister ( varnode . raw . getAddress (), varnode . size ) return self . raw . readRegister ( reg ) raise RuntimeError ( \"Unsupported varnode type\" )","title":"read_varnode"},{"location":"reference/#ghidralib.Emulator.set_pc","text":"Set the program counter of the emulated program. Source code in ghidralib.py 1438 1439 1440 1441 def set_pc ( self , address ): # type: (Addr) -> None \"\"\"Set the program counter of the emulated program.\"\"\" pc = self . raw . getPCRegister () self . raw . writeRegister ( pc , address )","title":"set_pc"},{"location":"reference/#ghidralib.Emulator.trace_pcode","text":"Emulate from start to end address, with callback for each executed PcodeOp. Parameters: start \u2013 the start address to emulate end \u2013 the end address to emulate callback \u2013 the callback to call for each executed Pcode Source code in ghidralib.py 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 def trace_pcode ( self , start , end , callback ): # type: (Addr, Addr, Callable[[PcodeOp], None]) -> None \"\"\"Emulate from start to end address, with callback for each executed PcodeOp. :param start: the start address to emulate :param end: the end address to emulate :param callback: the callback to call for each executed Pcode\"\"\" self . set_pc ( start ) current = resolve ( start ) end = resolve ( end ) while current != end : success = self . raw . step ( TaskMonitor . DUMMY ) if not success : err = self . raw . getLastError () raise RuntimeError ( \"Error at {} : {} \" . format ( current , err )) instruction = Instruction ( current ) for op in instruction . pcode : callback ( op ) current = self . raw . getExecutionAddress ()","title":"trace_pcode"},{"location":"reference/#ghidralib.Emulator.write_memory","text":"Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' Parameters: address \u2013 the address to write to value \u2013 the value to write Source code in ghidralib.py 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 def write_memory ( self , address , value ): # type: (Addr, str) -> None \"\"\"Write to the memory of the emulated program. >>> emulator.write_memory(0x1000, \"1\") >>> emulator.read_memory(0x1000, 1) '1' :param address: the address to write to :param value: the value to write\"\"\" self . raw . writeMemory ( address , value )","title":"write_memory"},{"location":"reference/#ghidralib.Emulator.write_register","text":"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 Parameters: reg \u2013 the register to write to value \u2013 the value to write Source code in ghidralib.py 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 def write_register ( self , reg , value ): # type: (Reg, int) -> None \"\"\"Write to the register of the emulated program. >>> emulator.write_register(\"eax\", 1) >>> emulator.read_register(\"eax\") 1 :param reg: the register to write to :param value: the value to write\"\"\" self . raw . writeRegister ( reg , value )","title":"write_register"},{"location":"reference/#ghidralib.Function","text":"Bases: GhidraWrapper Wraps a Ghidra Function object. Source code in ghidralib.py 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 class Function ( GhidraWrapper ): \"\"\"Wraps a Ghidra Function object.\"\"\" @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ] @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func ) @property def return_type ( self ): # type: () -> DataType \"\"\"Get the return type of this function.\"\"\" return DataType ( self . raw . getReturnType ()) @property def return_variable ( self ): # type: () -> Parameter \"\"\"Get the variable representing a return value of this function.\"\"\" return Parameter ( self . raw . getReturn ()) @property def entrypoint ( self ): # type: () -> int \"\"\"Get the entrypoint of this function.\"\"\" return self . raw . getEntryPoint () . getOffset () @property def address ( self ): # type: () -> int \"\"\"Get the address of this function.\"\"\" return self . entrypoint @property def name ( self ): # type: () -> str \"\"\"Get the name of this function.\"\"\" return self . raw . getName () @property def comment ( self ): # type: () -> str \"\"\"Get the comment of this function, if any.\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment ) @property def is_thunk ( self ): # type: () -> bool \"\"\"Return True if this function is a thunk.\"\"\" return self . raw . isThunk () @property def is_external ( self ): # type: () -> bool \"\"\"Return True if this function is external.\"\"\" return self . raw . isExternal () @property def repeatable_comment ( self ): # type: () -> str \"\"\"Get the repeatable comment of this function, if any.\"\"\" return self . raw . getRepeatableComment () def set_repeatable_comment ( self , comment ): # type: (str) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment ) @property def parameters ( self ): # type: () -> list[Parameter] \"\"\" \"Get the parameters of this function.\"\"\" return [ Parameter ( raw ) for raw in self . raw . getParameters ()] @property def local_variables ( self ): # type: () -> list[Variable] \"\"\" \"Get the local variables of this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getLocalVariables ()] @property def variables ( self ): # type: () -> list[Variable] \"\"\"Get all variables defined in this function.\"\"\" return [ Variable ( raw ) for raw in self . raw . getAllVariables ()] def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED ) @property def instructions ( self ): # type: () -> list[Instruction] \"\"\"Get the assembler instructions for this function.\"\"\" listing = currentProgram . getListing () raw_instructions = listing . getInstructions ( self . raw . getBody (), True ) return [ Instruction ( raw ) for raw in raw_instructions ] @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get the references to this function.\"\"\" raw_refs = getReferencesTo ( resolve ( self . entrypoint )) return [ Reference ( raw ) for raw in raw_refs ] @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the source addresses of references to this function.\"\"\" return [ xref . from_address for xref in self . xrefs ] @property def callers ( self ): # type: () -> list[Function] \"\"\"Get all functions that call this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCallingFunctions ( TaskMonitor . DUMMY ) ] @property def called ( self ): # type: () -> list[Function] \"\"\"Get all functions that are called by this function.\"\"\" return [ Function ( raw ) for raw in self . raw . getCalledFunctions ( TaskMonitor . DUMMY )] @property def fixup ( self ): # type: () -> str \"\"\" \"Get the fixup of this function.\"\"\" return self . raw . getFixup () @fixup . setter def fixup ( self , fixup ): # type: (str) -> None \"\"\"Set the fixup of this function. :param fixup: The new fixup to set.\"\"\" self . raw . setFixup ( fixup ) @property def calls ( self ): # type: () -> list[FunctionCall] \"\"\" \"Get all function calls to this function.\"\"\" calls = [] for ref in self . xrefs : if ref . is_call : calls . append ( FunctionCall ( self , ref . from_address )) return calls @property def basicblocks ( self ): # type: () -> list[BasicBlock] \"\"\"Get the basic blocks of this function.\"\"\" block_model = BasicBlockModel ( currentProgram ) blocks = block_model . getCodeBlocksContaining ( self . raw . getBody (), TaskMonitor . DUMMY ) return [ BasicBlock ( block ) for block in blocks ] def _decompile ( self , simplify = \"decompile\" ): # type: (str) -> JavaObject \"\"\"Decompile this function (internal helper).\"\"\" decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) decompiler . setSimplificationStyle ( simplify ) decompiled = decompiler . decompileFunction ( self . raw , 5 , TaskMonitor . DUMMY ) decompiler . closeProgram () decompiler . dispose () if decompiled is None : raise RuntimeError ( \"Failed to decompile function {} \" . format ( self . name )) return decompiled def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC () def tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ()) @property def high_function ( self ): # type: () -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ()) def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\" \"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode @property def pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_pcode_tree () def get_pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . get_pcode_tree () @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\" \"Get the (low-level) Pcode for this function.\"\"\" result = [] for block in self . basicblocks : result . extend ( block . pcode ) return result @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_pcode () def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address )","title":"Function"},{"location":"reference/#ghidralib.Function.address","text":"Get the address of this function.","title":"address"},{"location":"reference/#ghidralib.Function.basicblocks","text":"Get the basic blocks of this function.","title":"basicblocks"},{"location":"reference/#ghidralib.Function.called","text":"Get all functions that are called by this function.","title":"called"},{"location":"reference/#ghidralib.Function.callers","text":"Get all functions that call this function.","title":"callers"},{"location":"reference/#ghidralib.Function.calls","text":"\"Get all function calls to this function.","title":"calls"},{"location":"reference/#ghidralib.Function.comment","text":"Get the comment of this function, if any.","title":"comment"},{"location":"reference/#ghidralib.Function.entrypoint","text":"Get the entrypoint of this function.","title":"entrypoint"},{"location":"reference/#ghidralib.Function.fixup","text":"\"Get the fixup of this function.","title":"fixup"},{"location":"reference/#ghidralib.Function.high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_function"},{"location":"reference/#ghidralib.Function.high_pcode","text":"Get the (high-level) Pcode for this function. Warning: this method needs to decompile the function, and is therefore slow.","title":"high_pcode"},{"location":"reference/#ghidralib.Function.instructions","text":"Get the assembler instructions for this function.","title":"instructions"},{"location":"reference/#ghidralib.Function.is_external","text":"Return True if this function is external.","title":"is_external"},{"location":"reference/#ghidralib.Function.is_thunk","text":"Return True if this function is a thunk.","title":"is_thunk"},{"location":"reference/#ghidralib.Function.local_variables","text":"\"Get the local variables of this function.","title":"local_variables"},{"location":"reference/#ghidralib.Function.name","text":"Get the name of this function.","title":"name"},{"location":"reference/#ghidralib.Function.parameters","text":"\"Get the parameters of this function.","title":"parameters"},{"location":"reference/#ghidralib.Function.pcode","text":"\"Get the (low-level) Pcode for this function.","title":"pcode"},{"location":"reference/#ghidralib.Function.pcode_tree","text":"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.","title":"pcode_tree"},{"location":"reference/#ghidralib.Function.repeatable_comment","text":"Get the repeatable comment of this function, if any.","title":"repeatable_comment"},{"location":"reference/#ghidralib.Function.return_type","text":"Get the return type of this function.","title":"return_type"},{"location":"reference/#ghidralib.Function.return_variable","text":"Get the variable representing a return value of this function.","title":"return_variable"},{"location":"reference/#ghidralib.Function.variables","text":"Get all variables defined in this function.","title":"variables"},{"location":"reference/#ghidralib.Function.xref_addrs","text":"Get the source addresses of references to this function.","title":"xref_addrs"},{"location":"reference/#ghidralib.Function.xrefs","text":"Get the references to this function.","title":"xrefs"},{"location":"reference/#ghidralib.Function.all","text":"Return all functions in the current program. Source code in ghidralib.py 1030 1031 1032 1033 1034 @staticmethod def all (): # type: () -> list[Function] \"\"\"Return all functions in the current program.\"\"\" raw_functions = currentProgram . getFunctionManager () . getFunctions ( True ) return [ Function ( f ) for f in raw_functions ]","title":"all"},{"location":"reference/#ghidralib.Function.create","text":"Create a new function at the given address with the given name. Source code in ghidralib.py 1036 1037 1038 1039 1040 @staticmethod def create ( address , name ): # type: (Addr, str) -> Function \"\"\"Create a new function at the given address with the given name.\"\"\" func = createFunction ( resolve ( address ), name ) return Function ( func )","title":"create"},{"location":"reference/#ghidralib.Function.decompile","text":"Get decompiled C code for the function as string. Source code in ghidralib.py 1186 1187 1188 1189 def decompile ( self ): # type: () -> str \"\"\"Get decompiled C code for the function as string.\"\"\" decompiled = self . _decompile () return decompiled . getDecompiledFunction () . getC ()","title":"decompile"},{"location":"reference/#ghidralib.Function.get","text":"Return a function at the given address, or None if no function exists there. Source code in ghidralib.py 1021 1022 1023 1024 1025 1026 1027 1028 @staticmethod def get ( addr ): # type: (Addr|JavaObject) -> Function|None \"\"\"Return a function at the given address, or None if no function exists there.\"\"\" raw = currentProgram . getListing () . getFunctionContaining ( resolve ( addr )) if raw is None : return None return Function ( raw ) # type: ignore","title":"get"},{"location":"reference/#ghidralib.Function.get_high_function","text":"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 1205 1206 1207 1208 1209 1210 1211 1212 1213 def get_high_function ( self , simplify = \"decompile\" ): # type: (str) -> HighFunction \"\"\"Decompile this function, and return a high-level function. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" decompiled = self . _decompile ( simplify ) return HighFunction ( decompiled . getHighFunction ())","title":"get_high_function"},{"location":"reference/#ghidralib.Function.get_high_pcode","text":"\"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle. Source code in ghidralib.py 1215 1216 1217 1218 1219 1220 1221 1222 def get_high_pcode ( self , simplify = \"decompile\" ): # type: (str) -> list[PcodeOp] \"\"\" \"Decompile this function, and return its high-level Pcode. Warning: this method needs to decompile the function, and is therefore slow. :simplify: the simplification style to use. See DecompilerInterface.setSimplificationStyle.\"\"\" return self . get_high_function ( simplify ) . pcode","title":"get_high_pcode"},{"location":"reference/#ghidralib.Function.get_high_pcode_at","text":"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. Parameters: address \u2013 the address to get the Pcode for. Source code in ghidralib.py 1252 1253 1254 1255 1256 1257 1258 1259 1260 def get_high_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get the high-level Pcode at the given address. Do not use this function in a loop! Better decompile the whole function first. Warning: this method needs to decompile the function, and is therefore slow. :param address: the address to get the Pcode for.\"\"\" return self . get_high_function () . get_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.Function.get_pcode_tree","text":"\"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 1231 1232 1233 1234 1235 def get_pcode_tree ( self ): # type: () -> BlockGraph \"\"\" \"Get an AST-like representation of the function's Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" return self . get_high_function () . get_pcode_tree ()","title":"get_pcode_tree"},{"location":"reference/#ghidralib.Function.rename","text":"Change the name of this function. Source code in ghidralib.py 1110 1111 1112 def rename ( self , name ): # type: (str) -> None \"\"\"Change the name of this function.\"\"\" self . raw . setName ( name , SourceType . USER_DEFINED )","title":"rename"},{"location":"reference/#ghidralib.Function.set_comment","text":"Set the comment of this function. Source code in ghidralib.py 1072 1073 1074 def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment of this function.\"\"\" self . raw . setComment ( comment )","title":"set_comment"},{"location":"reference/#ghidralib.Function.set_repeatable_comment","text":"Set the repeatable comment of this function. Source code in ghidralib.py 1091 1092 1093 def set_repeatable_comment ( self , comment ): # type: (str) -> None \"\"\"Set the repeatable comment of this function.\"\"\" self . raw . setRepeatableComment ( comment )","title":"set_repeatable_comment"},{"location":"reference/#ghidralib.Function.tokens","text":"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value. Source code in ghidralib.py 1191 1192 1193 1194 1195 1196 def tokens ( self ): # type: () -> ClangTokenGroup \"\"\"Get clang tokens for the decompiled function. This returns a ClangTokenGroup object. TODO: wrap the return value.\"\"\" decompiled = self . _decompile () return ClangTokenGroup ( decompiled . getCCodeMarkup ())","title":"tokens"},{"location":"reference/#ghidralib.FunctionCall","text":"Represents an abstract function call. Can be used to get the function being called and the parameters passed to it. Source code in ghidralib.py 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 class FunctionCall : \"\"\"Represents an abstract function call. Can be used to get the function being called and the parameters passed to it.\"\"\" def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address ) def get_high_pcode ( self ): # type: () -> PcodeOp \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address ))) def get_varnodes ( self ): # type: () -> dict[Varnode, int] \"\"\"Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values.\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address ) def emulate ( self ): # type: () -> Emulator \"\"\"Emulate the basic block of this function call, and return the state\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu def get_args_as_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr def get_args ( self , emulate = True ): # type: (bool) -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"FunctionCall"},{"location":"reference/#ghidralib.FunctionCall.address","text":"","title":"address"},{"location":"reference/#ghidralib.FunctionCall.function","text":"","title":"function"},{"location":"reference/#ghidralib.FunctionCall.__init__","text":"Source code in ghidralib.py 914 915 916 def __init__ ( self , function , address ): # type: (Function, Addr) -> None self . function = function self . address = resolve ( address )","title":"__init__"},{"location":"reference/#ghidralib.FunctionCall.emulate","text":"Emulate the basic block of this function call, and return the state Source code in ghidralib.py 941 942 943 944 945 946 def emulate ( self ): # type: () -> Emulator \"\"\"Emulate the basic block of this function call, and return the state\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () emu . emulate ( basicblock . start_address , self . address ) return emu","title":"emulate"},{"location":"reference/#ghidralib.FunctionCall.get_args","text":"Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 def get_args ( self , emulate = True ): # type: (bool) -> list[int|None] \"\"\"Get a list of the arguments passed to this function call, as integers. This method gets arguments of this function, as seen by Ghidra decompiler. If it's not possible to get an argument, return None in its place. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" basicblock = BasicBlock ( self . address ) state = {} if emulate : # Almost no reason not to emulate - it takes some time, but it's # nothing compared to generating high pcode (required for getting args). emu = Emulator () state = emu . propagate_varnodes ( basicblock . start_address , self . address ) args = [] for varnode in self . get_args_as_varnodes (): varnode = varnode . free if varnode . has_value : args . append ( varnode . value ) elif varnode in state : args . append ( state [ varnode ]) else : args . append ( None ) return args","title":"get_args"},{"location":"reference/#ghidralib.FunctionCall.get_args_as_varnodes","text":"Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 948 949 950 951 952 953 def get_args_as_varnodes ( self ): # type: () -> list[Varnode] \"\"\"Get a list of the arguments passed to this function call, as varnodes. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" pcode_op = self . get_high_pcode () return pcode_op . inputs [ 1 :] # skip function addr","title":"get_args_as_varnodes"},{"location":"reference/#ghidralib.FunctionCall.get_high_pcode","text":"Get the high-level PcodeOp for this function call. High-level Pcode call ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow. Source code in ghidralib.py 918 919 920 921 922 923 924 925 926 927 928 929 930 def get_high_pcode ( self ): # type: () -> PcodeOp \"\"\"Get the high-level PcodeOp for this function call. High-level Pcode `call` ops have the parameters resolved, so we can use them to read them when analysing Pcode. Warning: this method needs to decompile the function, and is therefore slow.\"\"\" for pcode_op in PcodeOp . get_high_pcode_at ( self . address ): if pcode_op . opcode != pcode_op . CALL : continue return pcode_op raise RuntimeError ( \"No CALL at {} \" . format ( hex ( self . address )))","title":"get_high_pcode"},{"location":"reference/#ghidralib.FunctionCall.get_varnodes","text":"Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values. Source code in ghidralib.py 932 933 934 935 936 937 938 939 def get_varnodes ( self ): # type: () -> dict[Varnode, int] \"\"\"Single-step the current basic block in the emulator, and trace the varnodes This will return a dictionary of varnodes and their values.\"\"\" basicblock = BasicBlock ( self . address ) emu = Emulator () return emu . propagate_varnodes ( basicblock . start_address , self . address )","title":"get_varnodes"},{"location":"reference/#ghidralib.GhidraWrapper","text":"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object. Source code in ghidralib.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class GhidraWrapper : \"\"\"The base class for all Ghidra wrappers. This function tries to be as transparent as possible - for example, it will not raise an error on double-wrapping, or when passed instead of a Java type. >>> instr = getInstructionAt(getAddr(0x1234)) >>> GhidraWrapper(instr) <Instruction 0x1234> >>> GhidraWrapper(GhidraWrapper(instr)) <Instruction 0x1234> >>> getInstructionBefore(Instruction(instr)) <Instruction 0x1233> Similarly, equality is based on the underlying Java object.\"\"\" def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw def __hash__ ( self ): # type: () -> int return self . raw . hashCode () def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"GhidraWrapper"},{"location":"reference/#ghidralib.GhidraWrapper.__repr__","text":"","title":"__repr__"},{"location":"reference/#ghidralib.GhidraWrapper.__str__","text":"","title":"__str__"},{"location":"reference/#ghidralib.GhidraWrapper.raw","text":"","title":"raw"},{"location":"reference/#ghidralib.GhidraWrapper.__eq__","text":"Source code in ghidralib.py 203 204 205 206 def __eq__ ( self , other ): # type: (object) -> bool if isinstance ( other , GhidraWrapper ): return self . raw . equals ( other . raw ) return self . raw . equals ( other )","title":"__eq__"},{"location":"reference/#ghidralib.GhidraWrapper.__hash__","text":"Source code in ghidralib.py 200 201 def __hash__ ( self ): # type: () -> int return self . raw . hashCode ()","title":"__hash__"},{"location":"reference/#ghidralib.GhidraWrapper.__init__","text":"Source code in ghidralib.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def __init__ ( self , raw ): # type: (JavaObject|int|long|str|GhidraWrapper) -> None if isinstance ( raw , ( int , long , str )): # Someone passed a primitive type to us. # If possible, try to resolve it with a \"get\" method. if hasattr ( self , \"get\" ): new_raw = self . get ( raw ) # type: ignore if new_raw is None : # Show original data for better error messages raise RuntimeError ( \"Unable to wrap \" + str ( raw )) raw = new_raw else : raise RuntimeError ( \"Unable to wrap a primitive: \" + str ( raw )) while isinstance ( raw , GhidraWrapper ): # In case someone tries to Function(Function(\"main\")) us raw = raw . raw if raw is None : raise RuntimeError ( \"Object doesn't exist (refusing to wrap None)\" ) self . __str__ = raw . __str__ self . __repr__ = raw . __repr__ self . raw = _as_javaobject ( raw ) # type: JavaObject","title":"__init__"},{"location":"reference/#ghidralib.GhidraWrapper.__tojava__","text":"Make it possible to pass this object to Java methods Source code in ghidralib.py 196 197 198 def __tojava__ ( self , klass ): \"\"\"Make it possible to pass this object to Java methods\"\"\" return self . raw","title":"__tojava__"},{"location":"reference/#ghidralib.HighFunction","text":"Bases: GhidraWrapper Source code in ghidralib.py 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 class HighFunction ( GhidraWrapper ): def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )] @property def pcode ( self ): # type: () -> list[PcodeOp] return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ()] @property def basic_blocks ( self ): # type: () -> list[PcodeBlock] return [ PcodeBlock ( raw ) for raw in self . raw . getBasicBlocks ()] def get_pcode_tree ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph )","title":"HighFunction"},{"location":"reference/#ghidralib.HighFunction.basic_blocks","text":"","title":"basic_blocks"},{"location":"reference/#ghidralib.HighFunction.pcode","text":"","title":"pcode"},{"location":"reference/#ghidralib.HighFunction.get_pcode_at","text":"Source code in ghidralib.py 493 494 495 def get_pcode_at ( self , address ): # type: (Addr) -> list[PcodeOp] address = resolve ( address ) return [ PcodeOp ( raw ) for raw in self . raw . getPcodeOps ( address )]","title":"get_pcode_at"},{"location":"reference/#ghidralib.HighFunction.get_pcode_tree","text":"Source code in ghidralib.py 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def get_pcode_tree ( self ): # type: () -> BlockGraph edge_map = {} ingraph = GhBlockGraph () for block in self . basic_blocks : gb = BlockCopy ( block . raw , block . raw . getStart ()) ingraph . addBlock ( gb ) edge_map [ block . raw ] = gb for block in self . basic_blocks : for edge in block . outgoing_edges : ingraph . addEdge ( edge_map [ block . raw ], edge_map [ edge . raw ]) ingraph . setIndices () decompiler = DecompInterface () decompiler . openProgram ( currentProgram ) outgraph = decompiler . structureGraph ( ingraph , 0 , monitor ) return BlockGraph ( outgraph )","title":"get_pcode_tree"},{"location":"reference/#ghidralib.HighSymbol","text":"Bases: GhidraWrapper Source code in ghidralib.py 218 219 220 221 222 class HighSymbol ( GhidraWrapper ): def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source )","title":"HighSymbol"},{"location":"reference/#ghidralib.HighSymbol.rename","text":"Source code in ghidralib.py 219 220 221 222 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None HighFunctionDBUtil . updateDBVariable ( self . raw , new_name , None , source )","title":"rename"},{"location":"reference/#ghidralib.HighVariable","text":"Bases: GhidraWrapper Source code in ghidralib.py 209 210 211 212 213 214 215 class HighVariable ( GhidraWrapper ): @property def symbol ( self ): # type: () -> HighSymbol return HighSymbol ( self . raw . getSymbol ()) def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"HighVariable"},{"location":"reference/#ghidralib.HighVariable.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.HighVariable.rename","text":"Source code in ghidralib.py 214 215 def rename ( self , new_name ): # type: (str) -> None self . symbol . rename ( new_name )","title":"rename"},{"location":"reference/#ghidralib.Instruction","text":"Bases: GhidraWrapper Wraps a Ghidra Instruction object Source code in ghidralib.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 class Instruction ( GhidraWrapper ): \"\"\"Wraps a Ghidra Instruction object\"\"\" def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction \"\"\"Get an instruction at an address, or None if not found.\"\"\" if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw ) @property def mnemonic ( self ): # type: () -> str \"\"\"Get the mnemonic of this instruction.\"\"\" return self . raw . getMnemonicString () @property def next ( self ): # type: () -> Instruction \"\"\"Get the next instruction.\"\"\" return Instruction ( self . raw . getNext ()) @property def previous ( self ): # type: () -> Instruction \"\"\"Get the previous instruction.\"\"\" return Instruction ( self . raw . getPrevious ()) @property def pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get a list of Pcode operations that this instruction was parsed to\"\"\" return [ PcodeOp ( raw ) for raw in self . raw . getPcode ()] @property def high_pcode ( self ): # type: () -> list[PcodeOp] \"\"\"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.\"\"\" return PcodeOp . get_high_pcode_at ( self . address ) @property def xrefs_from ( self ): # type: () -> list[Reference] \"\"\"Get a list of references that point to this instruction.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferencesFrom ()] def to_bytes ( self ): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return self . raw . getBytes () def operand ( self , ndx ): # type: (int) -> int \"\"\" \"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj ) def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out @property def address ( self ): # type: () -> int \"\"\"Get the address of this instruction.\"\"\" return self . raw . getAddress () . getOffset () @property def operands ( self ): # type: () -> list[int|str] \"\"\"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.\"\"\" raise RuntimeError ( \"TODO\" ) @property def flow ( self ): # type: () -> RefType \"\"\" \"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP\"\"\" return RefType ( self . raw . getFlowType ()) # int opIndex, Address refAddr, RefType type, SourceType sourceType def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"Instruction"},{"location":"reference/#ghidralib.Instruction.address","text":"Get the address of this instruction.","title":"address"},{"location":"reference/#ghidralib.Instruction.flow","text":"\"Get the flow type of this instruction. For example, for x86 JMP this will return RefType.UNCONDITIONAL_JUMP","title":"flow"},{"location":"reference/#ghidralib.Instruction.high_pcode","text":"Get high Pcode for this instruction. WARNING: do not use this in a loop. Use Function.high_pcode instead.","title":"high_pcode"},{"location":"reference/#ghidralib.Instruction.mnemonic","text":"Get the mnemonic of this instruction.","title":"mnemonic"},{"location":"reference/#ghidralib.Instruction.next","text":"Get the next instruction.","title":"next"},{"location":"reference/#ghidralib.Instruction.operands","text":"Return operands as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, and for registers the name will be returned.","title":"operands"},{"location":"reference/#ghidralib.Instruction.pcode","text":"Get a list of Pcode operations that this instruction was parsed to","title":"pcode"},{"location":"reference/#ghidralib.Instruction.previous","text":"Get the previous instruction.","title":"previous"},{"location":"reference/#ghidralib.Instruction.xrefs_from","text":"Get a list of references that point to this instruction.","title":"xrefs_from"},{"location":"reference/#ghidralib.Instruction.add_operand_reference","text":"Add a reference to an operand of this instruction. Source code in ghidralib.py 773 774 775 776 777 778 def add_operand_reference ( self , op_ndx , ref_addr , ref_type , src_type ): # type: (int, Addr, RefType, SourceType) -> None \"\"\"Add a reference to an operand of this instruction.\"\"\" # TODO: wrap SourceType too, someday? self . raw . addOperandReference ( op_ndx , resolve ( ref_addr ), ref_type . raw , src_type )","title":"add_operand_reference"},{"location":"reference/#ghidralib.Instruction.get","text":"Get an instruction at an address, or None if not found. Source code in ghidralib.py 680 681 682 683 684 685 686 def get ( self , raw_or_address ): # type: (JavaObject|Addr) -> Instruction \"\"\"Get an instruction at an address, or None if not found.\"\"\" if can_resolve ( raw_or_address ): raw = getInstructionAt ( resolve ( raw_or_address )) else : raw = raw_or_address return Instruction ( raw )","title":"get"},{"location":"reference/#ghidralib.Instruction.operand","text":"\"Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 724 725 726 727 728 729 730 731 732 733 734 735 736 def operand ( self , ndx ): # type: (int) -> int \"\"\" \"Get the nth operand of this instruction as a scalar.\"\"\" scalar = self . raw . getScalar ( ndx ) if scalar : return scalar . getValue () addr = self . raw . getAddress ( ndx ) if addr : return addr . getOffset () reg = self . raw . getRegister ( ndx ) if reg : return reg . getName () obj = addr . getOpObjects ( ndx ) raise RuntimeError ( \"Don't know how to read operand {} \" , obj )","title":"operand"},{"location":"reference/#ghidralib.Instruction.register","text":"Get the nth operand of this instruction as a register name. Source code in ghidralib.py 745 746 747 748 749 750 def register ( self , ndx ): # type: (int) -> str \"\"\"Get the nth operand of this instruction as a register name.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , str ): raise RuntimeError ( \"Operand {} is not a register\" . format ( ndx )) return out","title":"register"},{"location":"reference/#ghidralib.Instruction.scalar","text":"Get the nth operand of this instruction as a scalar. Source code in ghidralib.py 738 739 740 741 742 743 def scalar ( self , ndx ): # type: (int) -> int \"\"\"Get the nth operand of this instruction as a scalar.\"\"\" out = self . operand ( ndx ) if not isinstance ( out , int ): raise RuntimeError ( \"Operand {} is not a scalar\" . format ( ndx )) return out","title":"scalar"},{"location":"reference/#ghidralib.Instruction.to_bytes","text":"Get the bytes of this instruction. Source code in ghidralib.py 720 721 722 def to_bytes ( self ): # type: () -> bytes \"\"\"Get the bytes of this instruction.\"\"\" return self . raw . getBytes ()","title":"to_bytes"},{"location":"reference/#ghidralib.JavaObject","text":"A fake class, used for static type hints. Source code in ghidralib.py 60 61 62 63 64 65 class JavaObject : \"\"\"A fake class, used for static type hints.\"\"\" def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"JavaObject"},{"location":"reference/#ghidralib.JavaObject.__getattribute__","text":"This attribute exists to make mypy happy. Source code in ghidralib.py 63 64 65 def __getattribute__ ( self , name ): # type: (str) -> Any \"\"\"This attribute exists to make mypy happy.\"\"\" pass","title":"__getattribute__"},{"location":"reference/#ghidralib.Parameter","text":"Bases: Variable Wraps a Ghidra Parameter object. Source code in ghidralib.py 895 896 897 898 899 900 901 902 903 904 905 906 class Parameter ( Variable ): \"\"\"Wraps a Ghidra Parameter object.\"\"\" @property def ordinal ( self ): # type: () -> int \"\"\"Returns the ordinal of this parameter.\"\"\" return self . raw . getOrdinal () @property def formal_data_type ( self ): # type: () -> DataType \"\"\"Returns the formal data type of this parameter.\"\"\" return DataType ( self . raw . getFormalDataType ())","title":"Parameter"},{"location":"reference/#ghidralib.Parameter.formal_data_type","text":"Returns the formal data type of this parameter.","title":"formal_data_type"},{"location":"reference/#ghidralib.Parameter.ordinal","text":"Returns the ordinal of this parameter.","title":"ordinal"},{"location":"reference/#ghidralib.PcodeBlock","text":"Bases: GhidraWrapper Source code in ghidralib.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 class PcodeBlock ( GhidraWrapper ): @property def outgoing_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getOut ( i )) for i in range ( self . raw . getOutSize ())] @property def incoming_edges ( self ): # type: () -> list[PcodeBlock] return [ _pcode_node ( self . raw . getIn ( i )) for i in range ( self . raw . getInSize ())] @property def has_children ( self ): # type: () -> bool \"\"\"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.\"\"\" return isinstance ( self . raw , GhBlockGraph ) @property def pcode ( self ): # type: () -> list[PcodeOp] raw_pcode = collect_iterator ( self . raw . getRef () . getIterator ()) return [ PcodeOp ( raw ) for raw in raw_pcode ]","title":"PcodeBlock"},{"location":"reference/#ghidralib.PcodeBlock.has_children","text":"Returns True if this block has any children and can be iterated over. This function is necessary because Ghidra's code uses isinstance() checks to dispatch types. We return true for instances of Java BlockGraph.","title":"has_children"},{"location":"reference/#ghidralib.PcodeBlock.incoming_edges","text":"","title":"incoming_edges"},{"location":"reference/#ghidralib.PcodeBlock.outgoing_edges","text":"","title":"outgoing_edges"},{"location":"reference/#ghidralib.PcodeBlock.pcode","text":"","title":"pcode"},{"location":"reference/#ghidralib.PcodeOp","text":"Bases: GhidraWrapper Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. Source code in ghidralib.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 class PcodeOp ( GhidraWrapper ): \"\"\"Pcode is a Ghidra's low-level intermediate language. Instructions from any processor are transformed into PCode before any analysis takes place. There is a finite number of possible operations. While Ghidra doesn't define \"High Pcode\", this library refers to analysed Pcode as \"High Pcode\". While theoretically still the same object, Pcode is transformed significantly, for example before function parameter analysis \"CALL\" opcodes have no inputs. \"\"\" UNIMPLEMENTED = 0 COPY = 1 LOAD = 2 STORE = 3 BRANCH = 4 CBRANCH = 5 BRANCHIND = 6 CALL = 7 CALLIND = 8 CALLOTHER = 9 RETURN = 10 INT_EQUAL = 11 INT_NOTEQUAL = 12 INT_SLESS = 13 INT_SLESSEQUAL = 14 INT_LESS = 15 INT_LESSEQUAL = 16 INT_ZEXT = 17 INT_SEXT = 18 INT_ADD = 19 INT_SUB = 20 INT_CARRY = 21 INT_SCARRY = 22 INT_SBORROW = 23 INT_2COMP = 24 INT_NEGATE = 25 INT_XOR = 26 INT_AND = 27 INT_OR = 28 INT_LEFT = 29 INT_RIGHT = 30 INT_SRIGHT = 31 INT_MULT = 32 INT_DIV = 33 INT_SDIV = 34 INT_REM = 35 INT_SREM = 36 BOOL_NEGATE = 37 BOOL_XOR = 38 BOOL_AND = 39 BOOL_OR = 40 FLOAT_EQUAL = 41 FLOAT_NOTEQUAL = 42 FLOAT_LESS = 43 FLOAT_LESSEQUAL = 44 # Slot 45 is unused FLOAT_NAN = 46 FLOAT_ADD = 47 FLOAT_DIV = 48 FLOAT_MULT = 49 FLOAT_SUB = 50 FLOAT_NEG = 51 FLOAT_ABS = 52 FLOAT_SQRT = 53 FLOAT_INT2FLOAT = 54 FLOAT_FLOAT2FLOAT = 55 FLOAT_TRUNC = 56 FLOAT_CEIL = 57 FLOAT_FLOOR = 58 FLOAT_ROUND = 59 MULTIEQUAL = 60 INDIRECT = 61 PIECE = 62 SUBPIECE = 63 CAST = 64 PTRADD = 65 PTRSUB = 66 SEGMENTOP = 67 CPOOLREF = 68 NEW = 69 INSERT = 70 EXTRACT = 71 POPCOUNT = 72 LZCOUNT = 73 PCODE_MAX = 74 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address ) @property def address ( self ): # type: () -> int \"\"\"Get an address in the program where this instruction is located\"\"\" return self . raw . getSeqnum () . getTarget () . getOffset () @property def opcode ( self ): # type: () -> int return self . raw . getOpcode () @property def mnemonic ( self ): # type: () -> str \"\"\"Get a string representation of the operation, for example \"COPY\" \"\"\" return self . raw . getMnemonic () @property def inputs ( self ): # type: () -> list[Varnode] return [ Varnode ( raw ) for raw in self . raw . getInputs ()] @property def inputs_simple ( self ): # type: () -> list[int|str] \"\"\"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). \"\"\" return [ varnode . simple for varnode in self . inputs ] @property def output ( self ): # type: () -> Varnode|None if self . raw . getOutput () is None : return None return Varnode ( self . raw . getOutput ())","title":"PcodeOp"},{"location":"reference/#ghidralib.PcodeOp.BOOL_AND","text":"","title":"BOOL_AND"},{"location":"reference/#ghidralib.PcodeOp.BOOL_NEGATE","text":"","title":"BOOL_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.BOOL_OR","text":"","title":"BOOL_OR"},{"location":"reference/#ghidralib.PcodeOp.BOOL_XOR","text":"","title":"BOOL_XOR"},{"location":"reference/#ghidralib.PcodeOp.BRANCH","text":"","title":"BRANCH"},{"location":"reference/#ghidralib.PcodeOp.BRANCHIND","text":"","title":"BRANCHIND"},{"location":"reference/#ghidralib.PcodeOp.CALL","text":"","title":"CALL"},{"location":"reference/#ghidralib.PcodeOp.CALLIND","text":"","title":"CALLIND"},{"location":"reference/#ghidralib.PcodeOp.CALLOTHER","text":"","title":"CALLOTHER"},{"location":"reference/#ghidralib.PcodeOp.CAST","text":"","title":"CAST"},{"location":"reference/#ghidralib.PcodeOp.CBRANCH","text":"","title":"CBRANCH"},{"location":"reference/#ghidralib.PcodeOp.COPY","text":"","title":"COPY"},{"location":"reference/#ghidralib.PcodeOp.CPOOLREF","text":"","title":"CPOOLREF"},{"location":"reference/#ghidralib.PcodeOp.EXTRACT","text":"","title":"EXTRACT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ABS","text":"","title":"FLOAT_ABS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ADD","text":"","title":"FLOAT_ADD"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_CEIL","text":"","title":"FLOAT_CEIL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_DIV","text":"","title":"FLOAT_DIV"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_EQUAL","text":"","title":"FLOAT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOAT2FLOAT","text":"","title":"FLOAT_FLOAT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_FLOOR","text":"","title":"FLOAT_FLOOR"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_INT2FLOAT","text":"","title":"FLOAT_INT2FLOAT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESS","text":"","title":"FLOAT_LESS"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_LESSEQUAL","text":"","title":"FLOAT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_MULT","text":"","title":"FLOAT_MULT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NAN","text":"","title":"FLOAT_NAN"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NEG","text":"","title":"FLOAT_NEG"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_NOTEQUAL","text":"","title":"FLOAT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_ROUND","text":"","title":"FLOAT_ROUND"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SQRT","text":"","title":"FLOAT_SQRT"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_SUB","text":"","title":"FLOAT_SUB"},{"location":"reference/#ghidralib.PcodeOp.FLOAT_TRUNC","text":"","title":"FLOAT_TRUNC"},{"location":"reference/#ghidralib.PcodeOp.INDIRECT","text":"","title":"INDIRECT"},{"location":"reference/#ghidralib.PcodeOp.INSERT","text":"","title":"INSERT"},{"location":"reference/#ghidralib.PcodeOp.INT_2COMP","text":"","title":"INT_2COMP"},{"location":"reference/#ghidralib.PcodeOp.INT_ADD","text":"","title":"INT_ADD"},{"location":"reference/#ghidralib.PcodeOp.INT_AND","text":"","title":"INT_AND"},{"location":"reference/#ghidralib.PcodeOp.INT_CARRY","text":"","title":"INT_CARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_DIV","text":"","title":"INT_DIV"},{"location":"reference/#ghidralib.PcodeOp.INT_EQUAL","text":"","title":"INT_EQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_LEFT","text":"","title":"INT_LEFT"},{"location":"reference/#ghidralib.PcodeOp.INT_LESS","text":"","title":"INT_LESS"},{"location":"reference/#ghidralib.PcodeOp.INT_LESSEQUAL","text":"","title":"INT_LESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_MULT","text":"","title":"INT_MULT"},{"location":"reference/#ghidralib.PcodeOp.INT_NEGATE","text":"","title":"INT_NEGATE"},{"location":"reference/#ghidralib.PcodeOp.INT_NOTEQUAL","text":"","title":"INT_NOTEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_OR","text":"","title":"INT_OR"},{"location":"reference/#ghidralib.PcodeOp.INT_REM","text":"","title":"INT_REM"},{"location":"reference/#ghidralib.PcodeOp.INT_RIGHT","text":"","title":"INT_RIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SBORROW","text":"","title":"INT_SBORROW"},{"location":"reference/#ghidralib.PcodeOp.INT_SCARRY","text":"","title":"INT_SCARRY"},{"location":"reference/#ghidralib.PcodeOp.INT_SDIV","text":"","title":"INT_SDIV"},{"location":"reference/#ghidralib.PcodeOp.INT_SEXT","text":"","title":"INT_SEXT"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESS","text":"","title":"INT_SLESS"},{"location":"reference/#ghidralib.PcodeOp.INT_SLESSEQUAL","text":"","title":"INT_SLESSEQUAL"},{"location":"reference/#ghidralib.PcodeOp.INT_SREM","text":"","title":"INT_SREM"},{"location":"reference/#ghidralib.PcodeOp.INT_SRIGHT","text":"","title":"INT_SRIGHT"},{"location":"reference/#ghidralib.PcodeOp.INT_SUB","text":"","title":"INT_SUB"},{"location":"reference/#ghidralib.PcodeOp.INT_XOR","text":"","title":"INT_XOR"},{"location":"reference/#ghidralib.PcodeOp.INT_ZEXT","text":"","title":"INT_ZEXT"},{"location":"reference/#ghidralib.PcodeOp.LOAD","text":"","title":"LOAD"},{"location":"reference/#ghidralib.PcodeOp.LZCOUNT","text":"","title":"LZCOUNT"},{"location":"reference/#ghidralib.PcodeOp.MULTIEQUAL","text":"","title":"MULTIEQUAL"},{"location":"reference/#ghidralib.PcodeOp.NEW","text":"","title":"NEW"},{"location":"reference/#ghidralib.PcodeOp.PCODE_MAX","text":"","title":"PCODE_MAX"},{"location":"reference/#ghidralib.PcodeOp.PIECE","text":"","title":"PIECE"},{"location":"reference/#ghidralib.PcodeOp.POPCOUNT","text":"","title":"POPCOUNT"},{"location":"reference/#ghidralib.PcodeOp.PTRADD","text":"","title":"PTRADD"},{"location":"reference/#ghidralib.PcodeOp.PTRSUB","text":"","title":"PTRSUB"},{"location":"reference/#ghidralib.PcodeOp.RETURN","text":"","title":"RETURN"},{"location":"reference/#ghidralib.PcodeOp.SEGMENTOP","text":"","title":"SEGMENTOP"},{"location":"reference/#ghidralib.PcodeOp.STORE","text":"","title":"STORE"},{"location":"reference/#ghidralib.PcodeOp.SUBPIECE","text":"","title":"SUBPIECE"},{"location":"reference/#ghidralib.PcodeOp.UNIMPLEMENTED","text":"","title":"UNIMPLEMENTED"},{"location":"reference/#ghidralib.PcodeOp.address","text":"Get an address in the program where this instruction is located","title":"address"},{"location":"reference/#ghidralib.PcodeOp.inputs","text":"","title":"inputs"},{"location":"reference/#ghidralib.PcodeOp.inputs_simple","text":"Return inputs as primitive values (int or a string representation). More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier).","title":"inputs_simple"},{"location":"reference/#ghidralib.PcodeOp.mnemonic","text":"Get a string representation of the operation, for example \"COPY\"","title":"mnemonic"},{"location":"reference/#ghidralib.PcodeOp.opcode","text":"","title":"opcode"},{"location":"reference/#ghidralib.PcodeOp.output","text":"","title":"output"},{"location":"reference/#ghidralib.PcodeOp.get_high_pcode_at","text":"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address). Source code in ghidralib.py 410 411 412 413 414 415 @staticmethod def get_high_pcode_at ( address ): # type: (Addr) -> list[PcodeOp] \"\"\"Get a high pcode for the instruction at a specified address Convenience wrapper for Function(address).get_high_pcode_at(address).\"\"\" return Function ( address ) . get_high_pcode_at ( address )","title":"get_high_pcode_at"},{"location":"reference/#ghidralib.RefType","text":"Bases: GhidraWrapper Source code in ghidralib.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 class RefType ( GhidraWrapper ): @property def has_fall ( self ): # type: () -> bool return self . raw . hasFallthrough () @has_fall . setter def has_fall ( self , value ): # type: (bool) -> None self . raw . setHasFall ( value ) @property def is_call ( self ): # type: () -> bool return self . raw . isCall () @is_call . setter def is_call ( self , value ): # type: (bool) -> None self . raw . setIsCall ( value ) @property def is_jump ( self ): # type: () -> bool return self . raw . isJump () @is_jump . setter def is_jump ( self , value ): # type: (bool) -> None self . raw . setIsJump ( value ) @property def is_computed ( self ): # type: () -> bool return self . raw . isComputed () @is_computed . setter def is_computed ( self , value ): # type: (bool) -> None self . raw . setIsComputed ( value ) @property def is_conditional ( self ): # type: () -> bool return self . raw . isConditional () @is_conditional . setter def is_conditional ( self , value ): # type: (bool) -> None self . raw . setIsConditional ( value ) @property def is_unconditional ( self ): # type: () -> bool return not self . is_conditional @property def is_terminal ( self ): # type: () -> bool return self . raw . isTerminal () @property def is_data ( self ): # type: () -> bool return self . raw . isData () @property def is_read ( self ): # type: () -> bool return self . raw . isRead () @property def is_write ( self ): # type: () -> bool return self . raw . isWrite () @property def is_flow ( self ): # type: () -> bool return self . raw . isFlow () @property def is_override ( self ): # type: () -> bool return self . raw . isOverride () INVALID = _reftype_placeholder () FLOW = _reftype_placeholder () FALL_THROUGH = _reftype_placeholder () UNCONDITIONAL_JUMP = _reftype_placeholder () CONDITIONAL_JUMP = _reftype_placeholder () UNCONDITIONAL_CALL = _reftype_placeholder () CONDITIONAL_CALL = _reftype_placeholder () TERMINATOR = _reftype_placeholder () COMPUTED_JUMP = _reftype_placeholder () CONDITIONAL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL = _reftype_placeholder () CALL_TERMINATOR = _reftype_placeholder () COMPUTED_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_CALL_TERMINATOR = _reftype_placeholder () CONDITIONAL_COMPUTED_CALL = _reftype_placeholder () CONDITIONAL_COMPUTED_JUMP = _reftype_placeholder () JUMP_TERMINATOR = _reftype_placeholder () INDIRECTION = _reftype_placeholder () CALL_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () JUMP_OVERRIDE_UNCONDITIONAL = _reftype_placeholder () CALLOTHER_OVERRIDE_CALL = _reftype_placeholder () CALLOTHER_OVERRIDE_JUMP = _reftype_placeholder ()","title":"RefType"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_CALL","text":"","title":"CALLOTHER_OVERRIDE_CALL"},{"location":"reference/#ghidralib.RefType.CALLOTHER_OVERRIDE_JUMP","text":"","title":"CALLOTHER_OVERRIDE_JUMP"},{"location":"reference/#ghidralib.RefType.CALL_OVERRIDE_UNCONDITIONAL","text":"","title":"CALL_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.CALL_TERMINATOR","text":"","title":"CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL","text":"","title":"COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.COMPUTED_CALL_TERMINATOR","text":"","title":"COMPUTED_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.COMPUTED_JUMP","text":"","title":"COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL","text":"","title":"CONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_CALL_TERMINATOR","text":"","title":"CONDITIONAL_CALL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_CALL","text":"","title":"CONDITIONAL_COMPUTED_CALL"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_COMPUTED_JUMP","text":"","title":"CONDITIONAL_COMPUTED_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_JUMP","text":"","title":"CONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.CONDITIONAL_TERMINATOR","text":"","title":"CONDITIONAL_TERMINATOR"},{"location":"reference/#ghidralib.RefType.FALL_THROUGH","text":"","title":"FALL_THROUGH"},{"location":"reference/#ghidralib.RefType.FLOW","text":"","title":"FLOW"},{"location":"reference/#ghidralib.RefType.INDIRECTION","text":"","title":"INDIRECTION"},{"location":"reference/#ghidralib.RefType.INVALID","text":"","title":"INVALID"},{"location":"reference/#ghidralib.RefType.JUMP_OVERRIDE_UNCONDITIONAL","text":"","title":"JUMP_OVERRIDE_UNCONDITIONAL"},{"location":"reference/#ghidralib.RefType.JUMP_TERMINATOR","text":"","title":"JUMP_TERMINATOR"},{"location":"reference/#ghidralib.RefType.TERMINATOR","text":"","title":"TERMINATOR"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_CALL","text":"","title":"UNCONDITIONAL_CALL"},{"location":"reference/#ghidralib.RefType.UNCONDITIONAL_JUMP","text":"","title":"UNCONDITIONAL_JUMP"},{"location":"reference/#ghidralib.RefType.has_fall","text":"","title":"has_fall"},{"location":"reference/#ghidralib.RefType.is_call","text":"","title":"is_call"},{"location":"reference/#ghidralib.RefType.is_computed","text":"","title":"is_computed"},{"location":"reference/#ghidralib.RefType.is_conditional","text":"","title":"is_conditional"},{"location":"reference/#ghidralib.RefType.is_data","text":"","title":"is_data"},{"location":"reference/#ghidralib.RefType.is_flow","text":"","title":"is_flow"},{"location":"reference/#ghidralib.RefType.is_jump","text":"","title":"is_jump"},{"location":"reference/#ghidralib.RefType.is_override","text":"","title":"is_override"},{"location":"reference/#ghidralib.RefType.is_read","text":"","title":"is_read"},{"location":"reference/#ghidralib.RefType.is_terminal","text":"","title":"is_terminal"},{"location":"reference/#ghidralib.RefType.is_unconditional","text":"","title":"is_unconditional"},{"location":"reference/#ghidralib.RefType.is_write","text":"","title":"is_write"},{"location":"reference/#ghidralib.Reference","text":"Bases: GhidraWrapper Source code in ghidralib.py 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 class Reference ( GhidraWrapper ): @property def is_call ( self ): # type: () -> bool \"\"\"Return True if the reference is a call.\"\"\" return self . reftype . is_call @property def is_jump ( self ): # type: () -> bool \"\"\"Return True if the reference is a jump.\"\"\" return self . reftype . is_jump @property def reftype ( self ): # type: () -> RefType \"\"\"Return the type of reference.\"\"\" return RefType ( self . raw . getReferenceType ()) @property def from_address ( self ): # type: () -> int \"\"\"Return the address of the source of the reference.\"\"\" return self . raw . getFromAddress () . getOffset () @property def to_address ( self ): # type: () -> int \"\"\"Return the address of the target of the reference.\"\"\" return self . raw . getToAddress () . getOffset ()","title":"Reference"},{"location":"reference/#ghidralib.Reference.from_address","text":"Return the address of the source of the reference.","title":"from_address"},{"location":"reference/#ghidralib.Reference.is_call","text":"Return True if the reference is a call.","title":"is_call"},{"location":"reference/#ghidralib.Reference.is_jump","text":"Return True if the reference is a jump.","title":"is_jump"},{"location":"reference/#ghidralib.Reference.reftype","text":"Return the type of reference.","title":"reftype"},{"location":"reference/#ghidralib.Reference.to_address","text":"Return the address of the target of the reference.","title":"to_address"},{"location":"reference/#ghidralib.Register","text":"Bases: GhidraWrapper Source code in ghidralib.py 225 226 227 228 class Register ( GhidraWrapper ): @property def name ( self ): return self . raw . getName ()","title":"Register"},{"location":"reference/#ghidralib.Register.name","text":"","title":"name"},{"location":"reference/#ghidralib.Symbol","text":"Bases: GhidraWrapper Wraps a Ghidra Symbol object. Source code in ghidralib.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 class Symbol ( GhidraWrapper ): \"\"\"Wraps a Ghidra Symbol object.\"\"\" @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) if not raw : return None else : raw = raw_or_name return Symbol ( raw ) @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols.\"\"\" symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ] @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw ) @property def address ( self ): # type: () -> int \"\"\"Get the address of this symbol.\"\"\" return self . raw . getAddress () . getOffset () @property def name ( self ): # type: () -> str \"\"\"Get the name of this symbol.\"\"\" return self . raw . getName () @property def name_with_namespace ( self ): # type: () -> str \"\"\"Get the fully qualified name of this symbol.\"\"\" return self . raw . getName ( True ) @property def xrefs ( self ): # type: () -> list[Reference] \"\"\"Get a list of references to this symbol.\"\"\" return [ Reference ( raw ) for raw in self . raw . getReferences ()] @property def xref_addrs ( self ): # type: () -> list[int] \"\"\"Get the addresses of all references to this symbol.\"\"\" return [ xref . from_address for xref in self . xrefs ] def set_type ( self , datatype ): # type: (DataType) -> None \"\"\"Set the data type of this symbol.\"\"\" create_data ( self . address , datatype ) def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source )","title":"Symbol"},{"location":"reference/#ghidralib.Symbol.address","text":"Get the address of this symbol.","title":"address"},{"location":"reference/#ghidralib.Symbol.name","text":"Get the name of this symbol.","title":"name"},{"location":"reference/#ghidralib.Symbol.name_with_namespace","text":"Get the fully qualified name of this symbol.","title":"name_with_namespace"},{"location":"reference/#ghidralib.Symbol.xref_addrs","text":"Get the addresses of all references to this symbol.","title":"xref_addrs"},{"location":"reference/#ghidralib.Symbol.xrefs","text":"Get a list of references to this symbol.","title":"xrefs"},{"location":"reference/#ghidralib.Symbol.all","text":"Get all symbols. Source code in ghidralib.py 1287 1288 1289 1290 1291 1292 @staticmethod def all (): # type: () -> list[Symbol] \"\"\"Get all symbols.\"\"\" symbol_iterator = currentProgram . getSymbolTable () . getAllSymbols () symbols = collect_iterator ( symbol_iterator ) return [ Symbol ( s ) for s in symbols ]","title":"all"},{"location":"reference/#ghidralib.Symbol.create","text":"Create a new symbol (also called label) at the given address. Parameters: address \u2013 the address where to create the symbol. name \u2013 the name of the symbol. source \u2013 the source type for the new symbol. Source code in ghidralib.py 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 @staticmethod def create ( address , name , source = SourceType . USER_DEFINED ): # type: (Addr, str, SourceType) -> Symbol \"\"\"Create a new symbol (also called label) at the given address. :param address: the address where to create the symbol. :param name: the name of the symbol. :param source: the source type for the new symbol.\"\"\" raw = createLabel ( resolve ( address ), name , False , source ) return Symbol ( raw )","title":"create"},{"location":"reference/#ghidralib.Symbol.get","text":"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. Parameters: raw_or_name \u2013 a Ghidra Java object, a string, or an address. Source code in ghidralib.py 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 @staticmethod def get ( raw_or_name ): # type: (JavaObject|str|Addr) -> Symbol|None \"\"\"Get a symbol with the provided name or at the provided address. Return None if the symbol was not found. :param raw_or_name: a Ghidra Java object, a string, or an address.\"\"\" if isinstance ( raw_or_name , str ): symbol_iterator = currentProgram . getSymbolTable () . getSymbols ( raw_or_name ) symbols = collect_iterator ( symbol_iterator ) if not symbols : return None raw = symbols [ 0 ] elif can_resolve ( raw_or_name ): raw = currentProgram . getSymbolTable () . getPrimarySymbol ( resolve ( raw_or_name )) if not raw : return None else : raw = raw_or_name return Symbol ( raw )","title":"get"},{"location":"reference/#ghidralib.Symbol.rename","text":"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' Parameters: new_name \u2013 the new name of the symbol. Source code in ghidralib.py 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 def rename ( self , new_name , source = SourceType . USER_DEFINED ): # type: (str, SourceType) -> None \"\"\"Rename this symbol. >>> main = Symbol.get(\"main\") >>> main.rename(\"main_renamed\") >>> main.name 'main_renamed' :param new_name: the new name of the symbol.\"\"\" self . raw . setName ( new_name , source )","title":"rename"},{"location":"reference/#ghidralib.Symbol.set_type","text":"Set the data type of this symbol. Source code in ghidralib.py 1331 1332 1333 def set_type ( self , datatype ): # type: (DataType) -> None \"\"\"Set the data type of this symbol.\"\"\" create_data ( self . address , datatype )","title":"set_type"},{"location":"reference/#ghidralib.Variable","text":"Bases: GhidraWrapper Wraps a Ghidra Variable object Source code in ghidralib.py 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 class Variable ( GhidraWrapper ): \"\"\"Wraps a Ghidra Variable object\"\"\" @property def name ( self ): # type: () -> str \"\"\"Get the name of this variable\"\"\" return self . raw . getName () @property def data_type ( self ): # type: () -> DataType \"\"\"Get the data type of this variable\"\"\" return DataType ( self . raw . getDataType ()) @property def is_valid ( self ): # type: () -> bool \"\"\"Check if this variable is valid\"\"\" return self . raw . isValid () @property def comment ( self ): # type: () -> str \"\"\" \"\"Get the comment for this variable\"\"\" return self . raw . getComment () def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment ) @property def is_stack ( self ): # type: () -> bool \"\"\"Check if this variable is a stack variable\"\"\" return self . raw . isStackVariable () @property def is_memory ( self ): # type: () -> bool \"\"\"Check if this variable is stored in memory\"\"\" return self . raw . isMemoryVariable () @property def is_unique ( self ): # type: () -> bool \"\"\"Check if this variable is of type unique\"\"\" return self . raw . isUniqueVariable () @property def is_compound ( self ): # type: () -> bool \"\"\"Check if this variable is a compound variable\"\"\" return self . raw . isCompoundVariable () @property def symbol ( self ): # type: () -> Symbol \"\"\" \"\"Get the symbol for this variable\"\"\" return Symbol ( self . raw . getSymbol ())","title":"Variable"},{"location":"reference/#ghidralib.Variable.comment","text":"\"\"Get the comment for this variable","title":"comment"},{"location":"reference/#ghidralib.Variable.data_type","text":"Get the data type of this variable","title":"data_type"},{"location":"reference/#ghidralib.Variable.is_compound","text":"Check if this variable is a compound variable","title":"is_compound"},{"location":"reference/#ghidralib.Variable.is_memory","text":"Check if this variable is stored in memory","title":"is_memory"},{"location":"reference/#ghidralib.Variable.is_stack","text":"Check if this variable is a stack variable","title":"is_stack"},{"location":"reference/#ghidralib.Variable.is_unique","text":"Check if this variable is of type unique","title":"is_unique"},{"location":"reference/#ghidralib.Variable.is_valid","text":"Check if this variable is valid","title":"is_valid"},{"location":"reference/#ghidralib.Variable.name","text":"Get the name of this variable","title":"name"},{"location":"reference/#ghidralib.Variable.symbol","text":"\"\"Get the symbol for this variable","title":"symbol"},{"location":"reference/#ghidralib.Variable.set_comment","text":"Set the comment for this variable Source code in ghidralib.py 865 866 867 def set_comment ( self , comment ): # type: (str) -> None \"\"\"Set the comment for this variable\"\"\" self . raw . setComment ( comment )","title":"set_comment"},{"location":"reference/#ghidralib.Varnode","text":"Bases: GhidraWrapper Source code in ghidralib.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 class Varnode ( GhidraWrapper ): @property def has_value ( self ): # type: () -> bool return self . is_address or self . is_constant @property def value ( self ): # type: () -> int \"\"\"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.\"\"\" if not self . has_value : raise RuntimeError ( \"Varnode can't be converted to value\" ) return self . raw . getOffset () @property def offset ( self ): # type: () -> int return self . raw . getOffset () @property def size ( self ): # type: () -> int return self . raw . getSize () @property def high ( self ): # type: () -> HighVariable return HighVariable ( self . raw . getHigh ()) @property def symbol ( self ): # type: () -> HighSymbol return self . high . symbol @property def is_constant ( self ): # type: () -> bool \"\"\"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.\"\"\" return self . raw . isConstant () @property def is_register ( self ): # type: () -> bool return self . raw . isRegister () @property def is_address ( self ): # type: () -> bool return self . raw . isAddress () @property def as_register ( self ): # type: () -> Register language = currentProgram . getLanguage () raw = language . getRegister ( self . raw . getAddress (), self . size ) return Register ( raw ) @property def is_unique ( self ): # type: () -> bool return self . raw . isUnique () @property def is_hash ( self ): # type: () -> bool return self . raw . isHash () def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name ) @property def is_free ( self ): # type: () -> bool return self . raw . isFree () @property def free ( self ): # type: () -> Varnode return Varnode ( GhVarnode ( self . raw . getAddress (), self . raw . getSize ())) @property def simple ( self ): # type: () -> int|str \"\"\"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.\"\"\" if self . has_value : return self . value elif self . is_register : return self . as_register . name elif self . is_unique : return \"uniq: {:x} \" . format ( self . offset ) elif self . is_hash : return \"hash: {:x} \" . format ( self . offset ) raise RuntimeError ( \"Unknown varnode type\" )","title":"Varnode"},{"location":"reference/#ghidralib.Varnode.as_register","text":"","title":"as_register"},{"location":"reference/#ghidralib.Varnode.free","text":"","title":"free"},{"location":"reference/#ghidralib.Varnode.has_value","text":"","title":"has_value"},{"location":"reference/#ghidralib.Varnode.high","text":"","title":"high"},{"location":"reference/#ghidralib.Varnode.is_address","text":"","title":"is_address"},{"location":"reference/#ghidralib.Varnode.is_constant","text":"Note: addresses are not constants in Ghidra-speak. Use has_value to check if the varnode has a predictable value.","title":"is_constant"},{"location":"reference/#ghidralib.Varnode.is_free","text":"","title":"is_free"},{"location":"reference/#ghidralib.Varnode.is_hash","text":"","title":"is_hash"},{"location":"reference/#ghidralib.Varnode.is_register","text":"","title":"is_register"},{"location":"reference/#ghidralib.Varnode.is_unique","text":"","title":"is_unique"},{"location":"reference/#ghidralib.Varnode.offset","text":"","title":"offset"},{"location":"reference/#ghidralib.Varnode.simple","text":"Convert Varnode to a primitive value (int or a string representation) More specifically, this will convert constants and addresses into integers, for registers names are returned, and for unique and hash varnodes ad-hoc string encoding is used (hash:ID or uniq:ID where ID is varnode identifier). This is useful for simple analyses when programmer already knows what type of value is expected at the given position.","title":"simple"},{"location":"reference/#ghidralib.Varnode.size","text":"","title":"size"},{"location":"reference/#ghidralib.Varnode.symbol","text":"","title":"symbol"},{"location":"reference/#ghidralib.Varnode.value","text":"Get the value of this varnode. Will raise RuntimeError if varnode doesn't have a constant value. Use has_value to check for this before getting the value.","title":"value"},{"location":"reference/#ghidralib.Varnode.rename","text":"Try to rename the current varnode. This only makes sense for variables. Source code in ghidralib.py 289 290 291 def rename ( self , new_name ): # type: (str) -> None \"\"\"Try to rename the current varnode. This only makes sense for variables.\"\"\" self . symbol . rename ( new_name )","title":"rename"},{"location":"reference/#ghidralib.can_resolve","text":"Check if a passed value address can be resolved. This is useful for checking if resolve() will succeed. See resolve documentation for more details. Source code in ghidralib.py 132 133 134 135 136 137 def can_resolve ( addr ): # type: (Addr) -> bool \"\"\"Check if a passed value address can be resolved. This is useful for checking if `resolve()` will succeed. See `resolve` documentation for more details.\"\"\" return isinstance ( addr , ( GenericAddress , int , long , str ))","title":"can_resolve"},{"location":"reference/#ghidralib.collect_iterator","text":"Collect a Java iterator to a Python list. Source code in ghidralib.py 86 87 88 89 90 91 def collect_iterator ( iterator ): \"\"\"Collect a Java iterator to a Python list.\"\"\" result = [] while iterator . hasNext (): result . append ( iterator . next ()) return result","title":"collect_iterator"},{"location":"reference/#ghidralib.create_data","text":"Force the type of the data defined at the given address to datatype . This function will clear the old type if it already has one Parameters: address \u2013 address of the data. datatype \u2013 datatype to use for the data at address . Source code in ghidralib.py 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 def create_data ( address , datatype ): # type: (Addr, DataType) -> None \"\"\"Force the type of the data defined at the given address to `datatype`. This function will clear the old type if it already has one :param address: address of the data. :param datatype: datatype to use for the data at `address`.\"\"\" try : createData ( resolve ( address ), unwrap ( datatype )) except : clearListing ( resolve ( address )) createData ( resolve ( address ), unwrap ( datatype ))","title":"create_data"},{"location":"reference/#ghidralib.current_location","text":"Get the current location in the program. current_location() 0x1000 Source code in ghidralib.py 1689 1690 1691 1692 1693 1694 1695 def current_location (): # type: () -> int \"\"\"Get the current location in the program. >>> current_location() 0x1000 \"\"\" return currentLocation . getAddress () . getOffset ()","title":"current_location"},{"location":"reference/#ghidralib.enhex","text":"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' Parameters: s \u2013 raw bytes to encode. Source code in ghidralib.py 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def enhex ( s ): # type: (str | list[int]) -> str \"\"\"Convert raw bytes to a hex string. >>> enhex([0x01, 0x02]) '0102' :param s: raw bytes to encode.\"\"\" if isinstance ( s , str ): s = [ ord ( x ) for x in s ] return s . encode ( \"hex\" ) # type: ignore <- py2","title":"enhex"},{"location":"reference/#ghidralib.from_bytes","text":"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 Parameters: b \u2013 byte stream to decode. Source code in ghidralib.py 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 def from_bytes ( b ): # type: (str | list[int]) -> int \"\"\"Decode a byte stream as a little-endian integer. >>> from_bytes([0x01, 0x02]) 0x0201 :param b: byte stream to decode.\"\"\" if isinstance ( b , str ): b = [ ord ( x ) for x in b ] return sum (( v % 256 ) << ( i * 8 ) for i , v in enumerate ( b ))","title":"from_bytes"},{"location":"reference/#ghidralib.get_string","text":"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at adress was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use read_cstring instead. >>> get_string(0x1000) 'Hello, world!' Parameters: address \u2013 address where string should be located. Source code in ghidralib.py 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 def get_string ( address ): # type: (Addr) -> str|None \"\"\"Get the string defined at the given address. This function will return None if the data defined in Ghidra at the given address is not a string. This function will also return None if the string at `adress` was not defined in Ghidra. To read a null-terminated string from Ghidra memory, use `read_cstring` instead. >>> get_string(0x1000) 'Hello, world!' :param address: address where string should be located.\"\"\" string = getDataAt ( resolve ( address )) if string and string . hasStringValue (): return string . getValue () return None","title":"get_string"},{"location":"reference/#ghidralib.read_bytes","text":"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' Parameters: address \u2013 address from which to read. length \u2013 number of bytes to read. Source code in ghidralib.py 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 def read_bytes ( address , length ): # type: (Addr, int) -> str \"\"\"Read a byte stream from program at address. >>> read_bytes(0x1000, 4) 'test' :param address: address from which to read. :param length: number of bytes to read.\"\"\" address = resolve ( address ) return \"\" . join ( chr ( x % 256 ) for x in getBytes ( address , length ))","title":"read_bytes"},{"location":"reference/#ghidralib.read_cstring","text":"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyt is encountered. >>> read_cstring(0x1000) 'Hello, world!' Parameters: address \u2013 address from which to start reading. Source code in ghidralib.py 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 def read_cstring ( address ): # type: (Addr) -> str \"\"\"Read a null-terminated string from Ghidra memory. This function ignores metadata available to Ghidra and just reads the bytes until a nullbyt is encountered. >>> read_cstring(0x1000) 'Hello, world!' :param address: address from which to start reading.\"\"\" address = resolve_to_int ( address ) string = \"\" while True : c = read_u8 ( address ) if c == 0 : break string += chr ( c ) address += 1 return string","title":"read_cstring"},{"location":"reference/#ghidralib.read_u16","text":"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1708 1709 1710 1711 1712 1713 1714 1715 def read_u16 ( address ): # type: (Addr) -> int \"\"\"Read a 16bit integer from program at address. >>> read_u16(0x1000) 0x0102 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 2 ))","title":"read_u16"},{"location":"reference/#ghidralib.read_u32","text":"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1718 1719 1720 1721 1722 1723 1724 1725 def read_u32 ( address ): # type: (Addr) -> int \"\"\"Read a 32bit integer from program at address. >>> read_u32(0x1000) 0x01020304 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 4 ))","title":"read_u32"},{"location":"reference/#ghidralib.read_u8","text":"Read a byte from program at address. >>> read_u8(0x1000) 0x01 Parameters: address \u2013 address from which to read. Source code in ghidralib.py 1698 1699 1700 1701 1702 1703 1704 1705 def read_u8 ( address ): # type: (Addr) -> int \"\"\"Read a byte from program at address. >>> read_u8(0x1000) 0x01 :param address: address from which to read.\"\"\" return from_bytes ( read_bytes ( address , 1 ))","title":"read_u8"},{"location":"reference/#ghidralib.resolve","text":"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: A Ghidra Address object An integer representing an address A string representing a symbol name This function is responsible from converting the addressable values ( Addr ) to Ghidra addresses ( GenericAddress ). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 Parameters: addr \u2013 An addressable value. Returns: \u2013 A GenericAddress object representing the passed address. Source code in ghidralib.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def resolve ( addr ): # type: (Addr) -> GenericAddress \"\"\"Convert an arbitrary addressable value to a Ghidra Address object. This library accepts one of three things as addressses: 1. A Ghidra Address object 2. An integer representing an address 3. A string representing a symbol name This function is responsible from converting the addressable values (`Addr`) to Ghidra addresses (`GenericAddress`). >>> resolve(0x1234) 0x1234 >>> resolve(Symbol(\"main\")) 0x1234 >>> resolve(toAddr(0x1234)) 0x1234 :param addr: An addressable value. :return: A GenericAddress object representing the passed address. \"\"\" if isinstance ( addr , GenericAddress ): return addr if isinstance ( addr , ( int , long )): return toAddr ( addr ) if isinstance ( addr , str ): return toAddr ( Symbol ( addr ) . address ) print ( type ( addr )) raise TypeError ( \"Address must be a ghidra Address, int, or str\" )","title":"resolve"},{"location":"reference/#ghidralib.resolve_to_int","text":"Convert an addressable value to an integer representation. Source code in ghidralib.py 127 128 129 def resolve_to_int ( addr ): # type: (Addr) -> int \"\"\"Convert an addressable value to an integer representation.\"\"\" return resolve ( addr ) . getOffset ()","title":"resolve_to_int"},{"location":"reference/#ghidralib.unhex","text":"Decode a hex string. >>> unhex(\"01 02\") '0102' Parameters: s \u2013 hex string to decode. Source code in ghidralib.py 1752 1753 1754 1755 1756 1757 1758 1759 def unhex ( s ): # type: (str) -> str \"\"\"Decode a hex string. >>> unhex(\"01 02\") '0102' :param s: hex string to decode.\"\"\" return s . replace ( \" \" , \"\" ) . replace ( \" \\n \" , \"\" ) . decode ( \"hex\" ) # type: ignore <- py2","title":"unhex"},{"location":"reference/#ghidralib.unwrap","text":"If the argument is a GhidraWrapper, return the underlying Java object. Source code in ghidralib.py 140 141 142 143 144 def unwrap ( wrapper_or_java_type ): # type: (JavaObject|GhidraWrapper) -> JavaObject \"If the argument is a GhidraWrapper, return the underlying Java object.\" \"\" if isinstance ( wrapper_or_java_type , GhidraWrapper ): return wrapper_or_java_type . raw return wrapper_or_java_type","title":"unwrap"},{"location":"reference/#ghidralib.xor","text":"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\u0001\", \"\u0004\") '\u0006' Parameters: a \u2013 the first bytestring. b \u2013 the second bytestring. Source code in ghidralib.py 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 def xor ( a , b ): # type: (str, str) -> str \"\"\"XOR two bytestrings together. If two bytestrings are not the same length, the result will be truncated to the length of the shorter string. >>> xor(\"\\x01\\x02\", \"\\x03\\x04\") '\\x02\\x06' :param a: the first bytestring. :param b: the second bytestring.\"\"\" return \"\" . join ( chr ( ord ( x ) ^ ord ( y )) for x , y in zip ( a , b ))","title":"xor"}]}